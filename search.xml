<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[常见排序算法总结（归并排序）——Java语言（二）]]></title>
      <url>/2018/09/13/2018-9-13-16-36-10/</url>
      <content type="html"><![CDATA[<p>未完结</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL复习（一）]]></title>
      <url>/2018/09/07/2018-9-7-21-12-48/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备将自己所学的知识好好的复习一遍，看到了MySQL，对于MySQL，很多东西还是停留在知识点，实际应用还是差一大截，刚好是在网上看到一篇博文，本文主要是根据这篇博文，加上一些关于MySQL的知识点交叉串起来，方便自己复习。</p>
<h1 id="常见的MySQL操作的命令大全"><a href="#常见的MySQL操作的命令大全" class="headerlink" title="常见的MySQL操作的命令大全"></a>常见的MySQL操作的命令大全</h1><p>以下是一些比较常用的MySQL的操作命令，并非查询语句。当然可以使用一些可视化的工具来代替这些命令，比如比较好用的Navicat，这里使用的是IDEA自带的database工具。</p>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为mysqlpractice的数据库</span><br><span class="line">create database mysqlpractice;</span><br><span class="line"></span><br><span class="line"># 显示所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line"># 删除数据库mysqlpractice</span><br><span class="line">drop database mysqlpractice;</span><br><span class="line"># 一般会在删除之前进行判断，判断是否存在该数据库,如果对不存在的数据库进行删除会报错，对表的删除同理。</span><br><span class="line">drop database if exists mysqlpractice;</span><br><span class="line"></span><br><span class="line"># 选择名为mysqlpractice的数据库,只有选择了某个数据库，才能对数据库中的表进行操作</span><br><span class="line">use mysqlpractice;</span><br><span class="line"></span><br><span class="line">#显示当前数据库下的course表的字段信息，以下两种方式均可</span><br><span class="line">show columns from course;</span><br><span class="line">describe course;</span><br><span class="line"></span><br><span class="line"># 显示创建数据库的mysql语句</span><br><span class="line">show create database mysqlpractice;</span><br><span class="line"></span><br><span class="line"># 显示创建表的sql语句</span><br><span class="line">show create table course;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line">drop table course;</span><br><span class="line">#一般会在删除数据库表之前进行判断，如果存在就进行删除</span><br><span class="line">drop table if exists course;</span><br><span class="line"></span><br><span class="line"># 删除表中的数据，不删除表delete方式</span><br><span class="line">delete</span><br><span class="line">from course;</span><br><span class="line"># 删除表中的数据，不删除表truncate方式</span><br><span class="line">truncate table course;</span><br><span class="line"></span><br><span class="line"># 以上两种方式都可以删除表中的数据，但是还是由区别的</span><br><span class="line"># 1、truncate是不可以rollback的，delete可以rollback。</span><br><span class="line"># 2、truncate删除后会重置索引（自增类型的id会从0开始），而delete不会删除索引。</span><br><span class="line"># 3、delete可以返回受影响的行数，且delete可以按照条件删除。</span><br><span class="line"># 4、truncate不会触发任何的delete触发器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 表结构的修改</span><br><span class="line">## 增加一个字段int类型的test1</span><br><span class="line">alter table course</span><br><span class="line">  add column (test1 int);</span><br><span class="line"></span><br><span class="line">## 指定字段test1之后插入一个int类型的字段test2</span><br><span class="line">## 需要和上面一个命令区别开来，上面的命令是必须要带括号的，下面这个命令是不能带括号的</span><br><span class="line">alter table course</span><br><span class="line">  add column test2 int</span><br><span class="line">  after test1;</span><br><span class="line"></span><br><span class="line">## 删除一个test1字段</span><br><span class="line">alter table course</span><br><span class="line">  drop test1;</span><br><span class="line"></span><br><span class="line">## 修改字段的名称test1为newtest1，类型为char</span><br><span class="line"></span><br><span class="line">alter table course</span><br><span class="line">  change test1 newtest1 char(32);</span><br><span class="line"></span><br><span class="line">## 修改表的名字，将course表的名称修改为newCourse</span><br><span class="line"></span><br><span class="line">alter table course</span><br><span class="line">rename to newCourse;</span><br></pre></td></tr></table></figure>
<h1 id="学生-课程-教师-成绩SQL练习题"><a href="#学生-课程-教师-成绩SQL练习题" class="headerlink" title="学生-课程-教师-成绩SQL练习题"></a>学生-课程-教师-成绩SQL练习题</h1><h2 id="表的架构"><a href="#表的架构" class="headerlink" title="表的架构"></a>表的架构</h2><p>ps：</p>
<p>原文是采用的S#这种写法来表示id的，在navicat以及idea自带的一些插件中是不能识别的，所以以下全部改为sno这种形式。</p>
<h3 id="Student表"><a href="#Student表" class="headerlink" title="Student表"></a>Student表</h3><p>Student表具有学号sno，学生姓名sname，年龄sage以及性别ssex。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- auto-generated definition</span><br><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">  sno   int         null,</span><br><span class="line">  sname varchar(32) null,</span><br><span class="line">  sage  int         null,</span><br><span class="line">  ssex  varchar(8)  null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>对于Student表插入的测试数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">insert into Student</span><br><span class="line">select 1, N&apos;刘一&apos;, 18, N&apos;男&apos;</span><br><span class="line">union all</span><br><span class="line">select 2, N&apos;钱二&apos;, 19, N&apos;女&apos;</span><br><span class="line">union all</span><br><span class="line">select 3, N&apos;张三&apos;, 17, N&apos;男&apos;</span><br><span class="line">union all</span><br><span class="line">select 4, N&apos;李四&apos;, 18, N&apos;女&apos;</span><br><span class="line">union all</span><br><span class="line">select 5, N&apos;王五&apos;, 17, N&apos;男&apos;</span><br><span class="line">union all</span><br><span class="line">select 6, N&apos;赵六&apos;, 19, N&apos;女&apos;;</span><br></pre></td></tr></table></figure>
<p>插入6条学生数据信息，数据显示如下：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908114254-201898.png" alt="QQ截图20180908114254-201898"></p>
<h3 id="course表"><a href="#course表" class="headerlink" title="course表"></a>course表</h3><p>course有三个属性，分别是课程的编号，课程的名称，以及该课程的老师id<br>创表语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE course</span><br><span class="line">(</span><br><span class="line">  cno    INT,</span><br><span class="line">  cname nvarchar(32),</span><br><span class="line">  tno    INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>插入数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into Course</span><br><span class="line">select 1, N&apos;语文&apos;, 1</span><br><span class="line">union all</span><br><span class="line">select 2, N&apos;数学&apos;, 2</span><br><span class="line">union all</span><br><span class="line">select 3, N&apos;英语&apos;, 3</span><br><span class="line">union all</span><br><span class="line">select 4, N&apos;物理&apos;, 4;</span><br></pre></td></tr></table></figure></p>
<p>数据插入完成后的表如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908115655-201898.png" alt="QQ截图20180908115655-201898"></p>
<h3 id="Teacher表"><a href="#Teacher表" class="headerlink" title="Teacher表"></a>Teacher表</h3><p>创表语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table teacher</span><br><span class="line">(</span><br><span class="line">  tno   int         null,</span><br><span class="line">  tname varchar(16) null</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>向表中插入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into Teacher</span><br><span class="line">select 1, N&apos;叶平&apos;</span><br><span class="line">union all</span><br><span class="line">select 2, N&apos;贺高&apos;</span><br><span class="line">union all</span><br><span class="line">select 3, N&apos;杨艳&apos;</span><br><span class="line">union all</span><br><span class="line">select 4, N&apos;周磊&apos;;</span><br></pre></td></tr></table></figure></p>
<p>教师表创建完成后的表如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908115853-201898.png" alt="QQ截图20180908115853-201898"></p>
<h3 id="sc表-成绩、课程及学生的关联表"><a href="#sc表-成绩、课程及学生的关联表" class="headerlink" title="sc表-成绩、课程及学生的关联表"></a>sc表-成绩、课程及学生的关联表</h3><p>创建表的语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- auto-generated definition</span><br><span class="line">create table sc</span><br><span class="line">(</span><br><span class="line">  sno   int null,</span><br><span class="line">  cno   int null,</span><br><span class="line">  score int null</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>插入测试数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">insert into SC</span><br><span class="line">select 1, 1, 56</span><br><span class="line">union all</span><br><span class="line">select 1, 2, 78</span><br><span class="line">union all</span><br><span class="line">select 1, 3, 67</span><br><span class="line">union all</span><br><span class="line">select 1, 4, 58</span><br><span class="line">union all</span><br><span class="line">select 2, 1, 79</span><br><span class="line">union all</span><br><span class="line">select 2, 2, 81</span><br><span class="line">union all</span><br><span class="line">select 2, 3, 92</span><br><span class="line">union all</span><br><span class="line">select 2, 4, 68</span><br><span class="line">union all</span><br><span class="line">select 3, 1, 91</span><br><span class="line">union all</span><br><span class="line">select 3, 2, 47</span><br><span class="line">union all</span><br><span class="line">select 3, 3, 88</span><br><span class="line">union all</span><br><span class="line">select 3, 4, 56</span><br><span class="line">union all</span><br><span class="line">select 4, 2, 88</span><br><span class="line">union all</span><br><span class="line">select 4, 3, 90</span><br><span class="line">union all</span><br><span class="line">select 4, 4, 93</span><br><span class="line">union all</span><br><span class="line">select 5, 1, 46</span><br><span class="line">union all</span><br><span class="line">select 5, 3, 78</span><br><span class="line">union all</span><br><span class="line">select 5, 4, 53</span><br><span class="line">union all</span><br><span class="line">select 6, 1, 35</span><br><span class="line">union all</span><br><span class="line">select 6, 2, 68</span><br><span class="line">union all</span><br><span class="line">select 6, 4, 71;</span><br></pre></td></tr></table></figure></p>
<p>插入完成后的数据如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908120101-201898.png" alt="QQ截图20180908120101-201898"></p>
<h2 id="SQL练习题"><a href="#SQL练习题" class="headerlink" title="SQL练习题"></a>SQL练习题</h2><p>1、查询课程号为1比课程号为2的成绩高的所有学生的学号：<br>解决思路：<br>  使用两个子表，一个字表装课程号为1的信息，一个表装课程号为2的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	a.sno </span><br><span class="line">FROM</span><br><span class="line">	( SELECT sno, score FROM sc WHERE cno = &apos;1&apos; ) a,</span><br><span class="line">	( SELECT sno, score FROM sc WHERE cno = &apos;2&apos; ) b </span><br><span class="line">WHERE</span><br><span class="line">	a.score &gt; b.score </span><br><span class="line">	AND a.sno = b.sno;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908171025-201898.png" alt="QQ截图20180908171025-201898"><br>2、查询平均成绩大于60分的同学的学号和平均成绩:<br>解决思路：<br>  使用group by 将数据按照学号sno进行分组，这样就能和聚合函数avg一起，算出平均分，再使用having将得到的数据进行筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	sno,</span><br><span class="line">	avg( score ) </span><br><span class="line">FROM</span><br><span class="line">	sc </span><br><span class="line">GROUP BY</span><br><span class="line">	sno </span><br><span class="line">HAVING</span><br><span class="line">	avg( score ) &gt; 60;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908170644-201898.png" alt="QQ截图20180908170644-201898"></p>
<p>3、查询所有同学的学号、姓名、选课数、总成绩：</p>
<p>解决思路：<br>  因为需要对每一个同学进行单独处理，所以一定要用到分组，所以group by 是必须的，选课数和总成绩这些就需要拥挤聚合函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	student.sno,</span><br><span class="line">	student.sname,</span><br><span class="line">	count( sc.sno ),</span><br><span class="line">	sum( score ) </span><br><span class="line">FROM</span><br><span class="line">	student</span><br><span class="line">	LEFT JOIN sc ON student.sno = sc.sno </span><br><span class="line">GROUP BY</span><br><span class="line">	student.sno</span><br></pre></td></tr></table></figure>
<p>结果如图：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908170614-201898.png" alt="QQ截图20180908170614-201898"></p>
<p>4、查询姓“李”的老师的个数：</p>
<p>解决思路：</p>
<p>使用聚合函数count，需要注意的是需要对结果进行distinct处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	count( DISTINCT ( tname ) ) </span><br><span class="line">FROM</span><br><span class="line">	teacher </span><br><span class="line">WHERE</span><br><span class="line">	tname LIKE &apos;李%&apos;</span><br></pre></td></tr></table></figure>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908171738-201898.png" alt="QQ截图20180908171738-201898"></p>
<p>5、查询没有学过”叶平”老师课的同学学号，姓名：</p>
<p>解决思路：<br>  首先找出所有选修的叶平老师的学生的学号，这个可以通过sc表来进行查找。然后从student表中找出学号不在上面表中的学号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	student.sno,</span><br><span class="line">	student.sname </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">WHERE</span><br><span class="line">	student.sno NOT IN (</span><br><span class="line">	SELECT</span><br><span class="line">		sno </span><br><span class="line">	FROM</span><br><span class="line">		sc,</span><br><span class="line">		teacher,</span><br><span class="line">		course </span><br><span class="line">	WHERE</span><br><span class="line">		teacher.tname = &quot;叶平&quot; </span><br><span class="line">		AND teacher.tno = course.tno </span><br><span class="line">	AND course.cno = sc.cno </span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180908175856-201898.png" alt="QQ截图20180908175856-201898"></p>
<p>6、查询学过课程号为1同时课程号为2的同学的学号、姓名：</p>
<p>关于exists的使用参看：<a href="https://www.cnblogs.com/V1haoge/p/6385312.html" target="_blank" rel="noopener">https://www.cnblogs.com/V1haoge/p/6385312.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	student.sno,</span><br><span class="line">	student.sname </span><br><span class="line">FROM</span><br><span class="line">	student,</span><br><span class="line">	sc </span><br><span class="line">WHERE</span><br><span class="line">	student.sno = sc.sno </span><br><span class="line">	AND sc.cno = &quot;1&quot; </span><br><span class="line">	AND EXISTS ( SELECT * FROM sc AS sc2 WHERE sc2.sno = sc.sno AND sc2.cno = &quot;2&quot; )</span><br></pre></td></tr></table></figure></p>
<p>7、查询学过“叶平”老师所教的课的同学的学号、姓名：</p>
<h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>本文主要是参考一些很优秀的博文，链接如下：</p>
<ul>
<li><a href="http://www.cnblogs.com/qixuejia/p/3637735.html" target="_blank" rel="noopener">sql面试题（学生表<em>课程表</em>成绩表_教师表）</a></li>
</ul>
<p><a href="https://www.cnblogs.com/shenqz/p/6962493.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenqz/p/6962493.html</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[解决IDEA下的Terminal 乱码（unicode 编码）问题]]></title>
      <url>/2018/09/05/2018-8-27-09-57-25/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用IDEA进行开发的时候，难免会用到Git，两个窗口切换来切换去的很不方便，为了简单，我将IDEA自带的Terminal设置为Git的，这样就能达到在IDEA上敲Git命令的效果。</p>
<p>这里简单的介绍下具体的配置流程以及使用Git会引起的Unicode的解决方案。</p>
<p>更多IDEA配置参看 <a href="http://www.bianxiaofeng.com/2018/07/23/2018-7-23-09-36-27/">Intellij IDEA  2018.02 最新版 优化配置</a></p>
<h1 id="配置IDEA使用Git的Terminal"><a href="#配置IDEA使用Git的Terminal" class="headerlink" title="配置IDEA使用Git的Terminal"></a>配置IDEA使用Git的Terminal</h1><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180827094225.png" alt="enter description here" title="IDEA配置Git Terminal"></p>
<h1 id="解决使用IDEA-Terminal引起的中文-Unicode编码问题"><a href="#解决使用IDEA-Terminal引起的中文-Unicode编码问题" class="headerlink" title="解决使用IDEA Terminal引起的中文 Unicode编码问题"></a>解决使用IDEA Terminal引起的中文 Unicode编码问题</h1><p> 乱码现象如下：</p>
<p> <img src="http://p2sj58chj.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180827093139.png" alt="enter description here" title="乱码现象"></p>
<p>解决方案：</p>
<p>在Git的安装目录下的etc目录下bash.bashrc文件，在最后一行添加：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 解决IDEA下的terminal中文Unicode编码问题</span><br><span class="line">export LANG=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">export LC_ALL=<span class="string">"zh_CN.UTF-8"</span></span><br></pre></td></tr></table></figure>
<p>重启IDEA就可以了。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> Terminal </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用个人备份笔记]]></title>
      <url>/2018/08/24/2018-8-24-10-00-54/</url>
      <content type="html"><![CDATA[<h1 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h1><p>1、在当前目录下创建一个Git代码库</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure>
<p>创建的.git默认是隐藏的，使用命令ls -ah显示出来。</p>
<p>2、新建一个目录，并初始化为Git的代码库</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init [<span class="keyword">dir</span>-name]</span><br></pre></td></tr></table></figure>
<p>3、克隆一个项目包括其提交历史</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">[url</span>] [local-dir-name]</span><br></pre></td></tr></table></figure>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>1、显示当前Git配置</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--list</span></span><br></pre></td></tr></table></figure>
<p>2、设置提交的时候的用户信息</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">config</span> [--<span class="keyword">global</span>] user<span class="variable">.name</span> <span class="string">"username"</span></span><br><span class="line">git <span class="keyword">config</span> [--<span class="keyword">global</span>] user<span class="variable">.email</span> <span class="string">"email address"</span></span><br></pre></td></tr></table></figure>
<h1 id="三、增加删除文件"><a href="#三、增加删除文件" class="headerlink" title="三、增加删除文件"></a>三、增加删除文件</h1><p>1、添加指定文件到暂存区</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment">[file1]</span> <span class="comment">[file2]</span> ···</span><br></pre></td></tr></table></figure>
<p>2、添加指定目录到暂存区，包括子目录</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add </span>[<span class="keyword">dir </span>name]</span><br></pre></td></tr></table></figure>
<p>3、将当前目录下的所有文件到暂存区（包括当前目录下的已经修改的文件夹）</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br></pre></td></tr></table></figure>
<p>4、删除工作区文件，并且将这次删除放入到暂存区</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm <span class="comment">[file1]</span> <span class="comment">[file2]</span></span><br></pre></td></tr></table></figure>
<p>从版本库中找回rm的文件</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --[<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<p>5、停止追踪指定文件，但该文件会保留到工作区，文件内容不变。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<h1 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h1><p>1、提交暂存区到版本库</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="comment">[message]</span></span><br></pre></td></tr></table></figure>
<p>2、提交暂存区的指定文件到仓库</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit [<span class="string">file1</span>][<span class="symbol">file2</span>]··· -m [message]</span><br></pre></td></tr></table></figure>
<p>3、提交工作区自上次commit之后的变化，直接到仓库区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<p>4、提交时显示所有的diff信息</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git commit -v</span></span><br></pre></td></tr></table></figure>
<p>5、使用一次新的commit，代替上一次提交；如果代码没有变化，就用来改写上一次的commit提交信息。commit的SHA1会发生改变，上一次的提交的内容不会发生改变。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend -m [meesage]</span></span><br></pre></td></tr></table></figure>
<p>6、重做上一次的commit，并包括指定文件的新变化（此时不需要讲file1和file2添加到暂存区）</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend <span class="comment">[file1]</span> <span class="comment">[file2]</span></span><br></pre></td></tr></table></figure>
<h1 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h1><p>1、列出所有的分支</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git branch</span></span><br></pre></td></tr></table></figure>
<p>2、列出所有的远程分支</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -<span class="built_in">r</span></span><br></pre></td></tr></table></figure>
<p>3、新建一个新的分支，但还是停留在当前的分支。工作区会复用，即在master上面修改的内容还没有提交，那么如果新建了一个分支，并切换过去，master的未提交的内容也会跟着带到新的分支。</p>
<figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch-<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>4、新建一个分支，并切换到该分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> [branch-name]</span><br></pre></td></tr></table></figure>
<p>5、新建一个分支，并指定指向的commit，此时如果工作区不干净，切换可能会出现失败，需要使用git stash 将当前工作区的修改给隐藏掉。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="comment">[branch-name]</span> <span class="comment">[commit id]</span></span><br></pre></td></tr></table></figure>
<p>6、切换到上一个分支</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> branch -</span><br></pre></td></tr></table></figure>
<p>7、在当前的分支和指定的远程分支之间建立追踪关系</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream <span class="comment">[branch] [remote-branch]</span></span><br></pre></td></tr></table></figure>
<p>8、合并指定分支到当前分支</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">merge</span> [branch]</span><br></pre></td></tr></table></figure>
<p>9、删除分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch-name]</span><br></pre></td></tr></table></figure>
<p>10、删除一个没有被合并过的分支需要使用-D参数：</p>
<figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D [branch-<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>11、删除远程分支</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> [<span class="built_in">origin</span>-name] --d [branch-name]</span><br></pre></td></tr></table></figure>
<p>12、新建一个分支，指向某个tag</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="comment">[branch]</span> <span class="comment">[tag]</span></span><br></pre></td></tr></table></figure>
<p>13、显示分支图</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">log</span> --<span class="keyword">graph</span></span><br></pre></td></tr></table></figure>
<p>14、修改分支名称</p>
<figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git banch -m [old-<span class="keyword">name</span>] [new-<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>15、合并多次commit</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [commit]</span><br></pre></td></tr></table></figure>
<p>上面的命令表示的是head分支到commit上一个commit的合并，注意不包括该commit。</p>
<p>在弹出的Vim编辑页面输入命令：  </p>
<p> Commands:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br></pre></td></tr></table></figure></p>
<p> 然后wq保存，再弹出一个Vim编辑框，修改commit信息。</p>
<p>16、恢复删除的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog 查看之前的这个已经删除的分支的提交历史</span><br><span class="line">git branch &lt;之前提交的那个分支的名字&gt; &lt;上一步操作查询到sha1&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h1><p>1、列出所有标签</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git tag</span></span><br></pre></td></tr></table></figure>
<p>2、新建一个指向当前commit的tag</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">[tag-name</span>]</span><br></pre></td></tr></table></figure>
<p>3、新建一个tag在指定的commit</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">[tag-nam</span>] [commit]</span><br></pre></td></tr></table></figure>
<p>4、删除本地tag</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-d</span> [<span class="keyword">tag</span>-name]</span><br></pre></td></tr></table></figure>
<p>5、删除远程tag</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [origin-name]<span class="symbol">:refs/tags/</span>[tag-name]</span><br></pre></td></tr></table></figure>
<p>6、查看tag信息</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">show</span> tag</span><br></pre></td></tr></table></figure>
<p>7、提交本地所有tag</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> [<span class="built_in">origin</span>-name] --tags</span><br></pre></td></tr></table></figure>
<p>8、提交指定tag</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> [<span class="built_in">origin</span>-name] [tag]</span><br></pre></td></tr></table></figure>
<h1 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h1><p>1、查看有变更的文件</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">status</span></span><br></pre></td></tr></table></figure>
<p>2、显示当前分支的版本历史</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>3、显示commit历史，以及每次commit发生变更的文件</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">log</span> --<span class="keyword">stat</span></span><br></pre></td></tr></table></figure>
<p>4、显示代码差异</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">diff</span></span><br></pre></td></tr></table></figure>
<p>暂存区没有文件：比较的是当前工作区和上一次的commit的差别。</p>
<p>暂存区有文件：比较的是当前工作区和暂存区的差别。</p>
<p>5、显示暂存区和上一次commit的差异</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">diff </span>--<span class="keyword">cached </span>[file]</span><br></pre></td></tr></table></figure>
<p>6、显示工作区和当前分支的最新commit的差异</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">diff</span> head</span><br></pre></td></tr></table></figure>
<p>7、显示两次提交之间的差异（commit1 和 commit的顺序需要注意，不一样会导致新增和删除错位）</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment">[commit1]</span> <span class="comment">[commit2]</span></span><br></pre></td></tr></table></figure>
<p>8、显示某次提交的元数据的和内容变化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">show</span> [<span class="keyword">commit</span>]</span><br></pre></td></tr></table></figure>
<h1 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h1><p>配置远程仓库：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> <span class="built_in">test</span> http://xxxx@git.XXXX.com/scm/wbqa/xxxx.git</span></span><br></pre></td></tr></table></figure>
<p>test为远程仓库的别名，后面的htpp为远程仓库地址。<br>删除远程仓库：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">rm</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure>
<p>test为别名</p>
<p>1、下载远程仓库的所有变动</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment">[remote]</span></span><br></pre></td></tr></table></figure>
<p>2、显示所有的远程仓库</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote -v</span></span><br></pre></td></tr></table></figure>
<p>和git remote的差别</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git remote</span><br><span class="line">origin</span><br><span class="line"><span class="symbol">$</span> git remote -v</span><br><span class="line">origin  https:<span class="comment">//github.com/DimpleFeng/GitTest.git (fetch)</span></span><br><span class="line">origin  https:<span class="comment">//github.com/DimpleFeng/GitTest.git (push)</span></span><br></pre></td></tr></table></figure>
<p>3、取回远程仓库的变化，并和本地分支合并</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">[remote]</span> <span class="comment">[branch]</span></span><br></pre></td></tr></table></figure>
<p>4、上传本地指定分支到远程仓库</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">[remote]</span> <span class="comment">[branch]</span></span><br></pre></td></tr></table></figure>
<p>5、强行推送当前分支到远程仓库即使有冲突</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span> [remote] --force</span><br></pre></td></tr></table></figure>
<p>6、git remote 通常用于查看别人的进行，因为取回的代码对本地没有影响。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add <span class="tag">&lt;<span class="name">主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">网址</span>&gt;</span> 添加远程主机</span><br><span class="line">git remote rm <span class="tag">&lt;<span class="name">主机名</span>&gt;</span> 删除远程主机</span><br><span class="line">git remote rename <span class="tag">&lt;<span class="name">原主机名</span>&gt;</span><span class="tag">&lt;<span class="name">新主机名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>7、git pull 取回远程主机某个分支的更新，再和本地的分支进行合并。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>取回origin主机的next分支，与本地的master合并</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pulll origin <span class="keyword">next</span>:master</span><br></pre></td></tr></table></figure>
<p>如果远程分支是和当前的分支进行合并，则冒号后面可以省略。</p>
<p>在某些场合，Git会自动在远程分支和本地分支之间创建一个追踪关系，如果当前分支和远程分支存在着追踪关系，就可以省略远程分支名称。</p>
<p>如果当前分支只有一个追踪分支，远程主机名也可以省略。</p>
<p>8、git push 将本地分支的更新，推送到远程主机</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span><span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果省略远程分支名，表示将本地分支推送给与之存在追踪关系的远程分支，如果该分支不存在会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支：git push origin :master<br>如果当前分支和远程分支存在追踪关系，则本地分支和远程分支都可以省略。<br>如果只存在一个追踪分支，那么主机名可以省略.</p>
<p>如果远程主机的版本比本地的新，那么推送到Git的时候会报错，这个时候可以采用git push –force origin强制覆盖远程主机的版本。</p>
<h1 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h1><p>1、恢复暂存区的指定文件到工作区。会丢失提交到暂存区后对该文件的所有操作。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<p>2、恢复某次commit的指定文件到暂存区和工作区（git处于等待commit状态，同时会丢失在这之前对工作区的修改的内容）</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">[commit]</span> <span class="comment">[file]</span></span><br></pre></td></tr></table></figure>
<p>3、恢复暂存区所有文件到工作区。会丢失在提交到暂存区之后的对文件的所有修改。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>
<p>4、重置暂存区和工作区，与上一次commit一致</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard</span></span><br></pre></td></tr></table></figure>
<p>5、重置当前分支的head为指定的commit，同时重置暂存区和工作区，与指定commit一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard [commit]</span></span><br></pre></td></tr></table></figure>
<p>git reset [file] 将file从暂存区回退到工作区（修改内容不会丢失）</p>
<p>6、将未保存的变化隐藏</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git stash</span></span><br></pre></td></tr></table></figure>
<p>弹出</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="keyword">pop</span></span><br></pre></td></tr></table></figure>
<p>7、查看历史命令</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git reflog</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE中的过滤器和拦截器[未完结]]]></title>
      <url>/2018/08/23/2018-8-23-14-51-13/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于Interceptor和Filter，在很多时候都可以混淆使用，都是可以拦截用户请求，然后做一些事情。为了不混淆两者关系，在此整理了关于拦截器和过滤器的相关知识和区别。</p>
<h1 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h1><h2 id="Filter说明"><a href="#Filter说明" class="headerlink" title="Filter说明"></a>Filter说明</h2><p>过滤器是处于客户端和服务器资源文件之间的一道过滤网，在访问资源之前，通过一系列的拦截器，即构成的拦截器链FilterChain，对响应进行过滤拦截和修改。</p>
<p>Filter是JavaEE规范中的，是Servlet最实用的技术，通过Filter，就可以对Web服务器管理的所有Web资源如JSP、Servlet等等进行拦截，</p>
<p>具体的应用场景应该有URL级别的权限访问控制，过滤敏感词汇，压缩响应信息等等。</p>
<p>主要用作对用户请求进行预处理，也可以对response进行后处理。Filter的处理流程：Filter对用户请求进行预处理，接着讲请求交给Servlet进行处理并生成响应，最后Filter对服务器响应进行后处理。自定义的Filter还需要实现Filter接口。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180823151130-2018823.png" alt="TIM截图20180823151130-2018823"></p>
<h2 id="Filter工作原理"><a href="#Filter工作原理" class="headerlink" title="Filter工作原理"></a>Filter工作原理</h2><p>可以从上图看到，Filter接口中有三个方法，分别为init、doFilter、destroy，分别对应着初始化，过滤、销毁。</p>
<p>当我们写好了Filter的时候，还需要配置该Filter是要对哪些资源进行过滤。</p>
<p>当每次用户请求到达服务器后，在未到达具体请求的资源之前，Web服务器都会先调用Filter的doFilter方法进行处理，然后该方法传入的参数有一个FilterChain，如果处理完成放行会继续执行该FilterChain的doFilter方法，如果不放行就不继续执行该FilterChain的doFilter方法。</p>
<h2 id="Filter的编写流程"><a href="#Filter的编写流程" class="headerlink" title="Filter的编写流程"></a>Filter的编写流程</h2><p>1、编写一个类实现Filter接口，并实现其带的init、doFilter、destroy方法。</p>
<p>2、在doFilter方法中编写具体的逻辑，根据逻辑需要选择放行FilterChain。</p>
<p>3、在web.xml文件中配置过滤器（注册和映射），需要使用标签<filter>以及<filter-mapping></filter-mapping></filter></p>
<h2 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h2><h3 id="Filter创建"><a href="#Filter创建" class="headerlink" title="Filter创建"></a>Filter创建</h3><p>Filter的创建和销毁由Web容器负责，在Web应用启动的时候，Web服务器将创建Filter的实例对象，并调用init方法完成对象的初始化。</p>
<p>Filter对象只会创建一次，init方法也只会执行一次。通过init方法的参数FilterConfig可以获得代表当前Filter的Config。</p>
<p>而这些参数，一般来源于web.xml中的init-param。在web.xml文件中配置的时候可以通过<init-param>来为Filter配置一些启动参数。</init-param></p>
<p>FilterConfig常用方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    String filterName = filterConfig.getFilterName();//获取Filter的Name</span><br><span class="line">    String initParam = filterConfig.getInitParameter(&quot;initParam&quot;);//获取名称为initParam的初始参数的值</span><br><span class="line">    Enumeration&lt;String&gt; initParameterNames = filterConfig.getInitParameterNames();//获取所有的初始化参数的美聚集和while (initParameterNames.hasMoreElements()) &#123;</span><br><span class="line">        System.out.println(initParameterNames.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Filter的销毁"><a href="#Filter的销毁" class="headerlink" title="Filter的销毁"></a>Filter的销毁</h3><p>在Web容器关闭之前，会调用Filter的destroy方法来销毁Filter，在此方法中，可以释放掉过滤器使用的资源。</p>
<h1 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h1><p>拦截器在开源框架中很常见，依赖的技术就是JavaJDK的动态代理，当然还有基于CGLIB的动态代理，关于这两种的代理区别，JDK的动态代理是需要用到接口Interface的，没有接口就不能实现动态代理，而CGLIB就可以不需要接口。</p>
<p>在这里呢，说下Spring中的Interceptor，依赖于Web框架，也是一种AOP的运用。由于拦截器是Web框架的调用，因此可以使用Spring的DI依赖注入，同时一个Controller可以在一个Controller的生命周期中多次被调用。</p>
<p>Interceptor只能拦截Controller，对于一些静态资源则不能拦截处理。</p>
<h2 id="实现一个自定义的Interceptor"><a href="#实现一个自定义的Interceptor" class="headerlink" title="实现一个自定义的Interceptor"></a>实现一个自定义的Interceptor</h2><p>1、需要实现HandlerInterceptor接口，并实现以下的三个方法，关于多个Interceptor执行，在preHandler执行完毕后的返回值会影响接下来执行的Interceptor，这里不做说明。</p>
<p>2、在Spring的配置文件中配置Interceptor。注意拦截器的执行顺序和配置文件的顺序有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class MyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 在Dispatcher之前执行</span><br><span class="line">	 *</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param handler</span><br><span class="line">	 * @return true：表示继续执行拦截器链，如果返回为false，就不会继续执行Controller</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 在Controller执行完毕之后，在视图解析器之前被执行</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param handler</span><br><span class="line">	 * @param modelAndView</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 在视图解析器执行完毕后，在返回给客户端之前执行</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param handler</span><br><span class="line">	 * @param ex</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 过滤器，拦截器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java读取Properties文件的几种方式]]></title>
      <url>/2018/08/16/2018-08-16-03-58-02/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Spring的时候，通过XML配置文件的方式进行配置数据库连接池的时候，就会使用==context:property-placeholder==标签进行读取，在这里呢，也是通过Java几种比较基础的方式来读取Properties文件。</p>
<p>在开始之前，说下目前比价常用的几种方式：</p>
<pre><code>1. 使用java.util.Properties类,可以使用它的load方法加载inputStream字节流。
2. 使用java.util.ResourceBundle类来读取。
</code></pre><h1 id="使用Properties类"><a href="#使用Properties类" class="headerlink" title="使用Properties类"></a>使用Properties类</h1><p>Properties类继承自Hashtable，而Hashtable是实现了Map接口的，所以对Properties类的操作和Map有些相似。</p>
<p>使用Properties来加载.properties文件的主要关键是在于load方法。而load方法需要的是InputStream流。</p>
<p>这里比较常用的流的获取有以下几种：</p>
<ol>
<li>使用当前类的ClassLoader()的getResourceAsStream()，getResourcesAsStream返回一个InputStream。</li>
<li>使用ClassLoader类的getSystemResourceAsStream()，该方法也返回一个InputStream。</li>
<li>使用文件输入流的方式。</li>
</ol>
<p>具体示例如下，为了方便，我直接使用的log4j.properties。文件位置如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180816161804.png" alt="位置图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 单独抽取的方法，用户检测能否正确操纵Properties</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException 为了排版美观，直接抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeyValue</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">		properties.load(inputStream);</span><br><span class="line">		Set&lt;Object&gt; keys = properties.keySet();</span><br><span class="line">		<span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">			System.out.println(key + <span class="string">" = "</span> + properties.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/***</span></span><br><span class="line"><span class="comment">	 * 从当前的类加载器的getResourcesAsStream来获取.</span></span><br><span class="line"><span class="comment">	 * 使用Class.class.getClassLoader().getResourcesAsStream()进行获取的时候，所填写的路径只能为项目的绝对路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPropertiesFromResourceAsStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStream resourceAsStream = PropertiesUtils.class.getClassLoader().getResourceAsStream(<span class="string">"com/dimple/getproperityfile/mylog4j.properties"</span>);</span><br><span class="line">		printKeyValue(resourceAsStream);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/***</span></span><br><span class="line"><span class="comment">	 * 从文件中获取,使用InputStream字节</span></span><br><span class="line"><span class="comment">	 * 主要是需要加上src这个文件夹名。。。路径配置需要精确到绝对地址级别</span></span><br><span class="line"><span class="comment">	 * 什么意思，就是如果这个mylog4j文件在com/dimple/getproperityfile/mylog4j.properties下，而这个com文件夹</span></span><br><span class="line"><span class="comment">	 * 又在src目录下，那么写的时候需要加上这个src，这样的相对路径+项目地址能够构成一个完整的访问地址即可</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPropertiesFromFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"src/com/dimple/getproperityfile/mylog4j.properties"</span>));</span><br><span class="line">		printKeyValue(inputStream);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用Class类的getSystemResourceAsStream方法</span></span><br><span class="line"><span class="comment">	 * 和使用当前类的ClassLoader是一样的</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPropertiesFromClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStream systemResourceAsStream = ClassLoader.getSystemResourceAsStream(<span class="string">"com/dimple/getproperityfile/mylog4j.properties"</span>);</span><br><span class="line">		printKeyValue(systemResourceAsStream);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用ResourceBundle类"><a href="#使用ResourceBundle类" class="headerlink" title="使用ResourceBundle类"></a>使用ResourceBundle类</h1><p>使用ResourcesBundle类也两种方法可以读取到配置文件</p>
<ol>
<li>使用类ResourcesBundle的getBundle方法加载properties文件。</li>
<li>使用其派生类PropertyResourceBundle()，通过传入一个InputStream来读取数据。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">	 * 使用java.util.ResourceBundle类来加载properties文件，注意不需要带上后缀名。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPropertiesFromResourceBundle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="string">"com/dimple/getproperityfile/mylog4j"</span>);</span><br><span class="line">		Enumeration&lt;String&gt; keys = resourceBundle.getKeys();</span><br><span class="line">		<span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">			String s = keys.nextElement();</span><br><span class="line">			System.out.println(s + <span class="string">" = "</span> + resourceBundle.getString(s));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用InputStream流来进行操作ResourceBundle，获取流的方式由以上几种。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPropertiesFromResourceBundleInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStream systemResourceAsStream = ClassLoader.getSystemResourceAsStream(<span class="string">"com/dimple/getproperityfile/mylog4j.properties"</span>);</span><br><span class="line">		ResourceBundle resourceBundle = <span class="keyword">new</span> PropertyResourceBundle(systemResourceAsStream);</span><br><span class="line">		Enumeration&lt;String&gt; keys = resourceBundle.getKeys();</span><br><span class="line">		<span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">			String s = keys.nextElement();</span><br><span class="line">			System.out.println(s + <span class="string">" = "</span> + resourceBundle.getString(s));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上代码的的方法具体有什么用已经表明了，遇到的问题已经不是代码问题了。而是路径。对于这个路径，相对路径，绝对路径，项目路径，这个路径确实让我有些头痛，在File的Test代码哪里，文件路径近乎是我试出来的。当然读者可能会说，直接拿鼠标去点，能点进去的就是对的，但是，在File那里，我没有加src，是可以点击去的，但是项目报错提示FileNotFound，加上src就能正常访问，但是点不进去。这个原因是因为IDEA这里，有一个工程路径的说法，工程路径并不包含src，而代码是写在src下的，所以导致最后的绝对路径不可达，所以报错。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> properties </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的前置++和后置++的理解]]></title>
      <url>/2018/08/14/2018-08-14-04-38-57/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C、C++等编程语言中都会存在i++，++i,在实际运用中我们总能记住一句话==i++(后置++)是先使用在+1，而++i(前置++)是先自增再使用==。但是在一些很烧脑的场合，这种规律就会“失效”。</p>
<p>本文会首先简单的介绍下前置和后置++在一些场合的实际应用，可以看到的是合理的使用++会使得代码简洁不少。</p>
<h1 id="前置后置的实际使用"><a href="#前置后置的实际使用" class="headerlink" title="++前置后置的实际使用"></a>++前置后置的实际使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dimple.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JavaSEProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试++运算符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Dimple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-08-14 16:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOpt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		String[] people = &#123;<span class="string">"Dennis Ritchie"</span>, <span class="string">"Bjarne Stroustrup"</span>, <span class="string">"James Gosling"</span>&#125;;</span><br><span class="line">		System.out.println(Arrays.asList(people).toString());</span><br><span class="line">		System.out.println(<span class="string">"preposition ++"</span>);</span><br><span class="line">		System.out.println(<span class="string">"        before operation···"</span>);</span><br><span class="line">		System.out.println(<span class="string">"        i= "</span>+i);</span><br><span class="line">		System.out.println(<span class="string">"        "</span>+people[i++]);</span><br><span class="line">		System.out.println(<span class="string">"        after operation···"</span>);</span><br><span class="line">		System.out.println(<span class="string">"        i= "</span>+i);</span><br><span class="line">		System.out.println(<span class="string">"postposition ++"</span>);</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		System.out.println(<span class="string">"        before operation···"</span>);</span><br><span class="line">		System.out.println(<span class="string">"        i= "</span>+i);</span><br><span class="line">		System.out.println(<span class="string">"        "</span>+people[++i]);</span><br><span class="line">		System.out.println(<span class="string">"        after operation···"</span>);</span><br><span class="line">		System.out.println(<span class="string">"        i= "</span>+i);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Dennis Ritchie, Bjarne Stroustrup, James Gosling]</span><br><span class="line">preposition ++</span><br><span class="line">        before operation···</span><br><span class="line">        i= <span class="number">0</span></span><br><span class="line">        Dennis Ritchie</span><br><span class="line">        after operation···</span><br><span class="line">        i= <span class="number">1</span></span><br><span class="line">postposition ++</span><br><span class="line">        before operation···</span><br><span class="line">        i= <span class="number">0</span></span><br><span class="line">        Bjarne Stroustrup</span><br><span class="line">        after operation···</span><br><span class="line">        i= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上面的都是很基础的，只是单纯的为了回忆一下，所有需要记住的是：</p>
<p>==前置++（++i）是先进行++操作后再赋值==<br>==后置++（i++）是先进行赋值再进行++操作==</p>
<p>最近在网上看到这样一个题，本文的主要目的是这道题。</p>
<h1 id="一道很烧脑的题"><a href="#一道很烧脑的题" class="headerlink" title="一道很烧脑的题"></a>一道很烧脑的题</h1><p>朋友在面试的时候遇到了一道题,然后我们一起交流的时候,他把这道题给我说了下,结果我也做错了.所以在此记录下:</p>
<p>题是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dimple.javabase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JavaSEProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 面试题中的一道烧脑题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Dimple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-08-14 17:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Increment</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span> ;i++)&#123;</span><br><span class="line">			j=j++;</span><br><span class="line">			k=k++;</span><br><span class="line">			n=++n;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(j);</span><br><span class="line">		System.out.println(k);</span><br><span class="line">		System.out.println(n);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案出乎我的意料：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>不需要去看编译后的字节码，其实很简单的就可以看出来：</p>
<p>分析：<br>在分析之前我们还是先看一个这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dimple.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JavaSEProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试++运算符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Dimple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-08-14 16:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOpt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">		 j = j++;</span><br><span class="line">		System.out.println(j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码如果我们使用的是IDEA编译器的话，在j下面有一个小波浪线提示以下话：</p>
<blockquote>
<p>The value changed at ‘j++’ is never used less… (Ctrl+F1)<br>Inspection info: This inspection points out the cases where a variable value is never used after its assignment, i.e.:  - the variable never gets read after assignment OR  - the value is always overwritten with another assignment before the next variable read OR  - the variable initializer is redundant (for one of the above two reasons)</p>
</blockquote>
<p>以上提示说的是：该j变量并没有被使用。emmmmm不是让它=j了吗？以上只是一个小的插曲，接下来开始我们的分析。</p>
<p>首先我们看到==j=j++;==这样的一句话，本身是有问题的（为了说明，我们把表达式左边的j叫做j1，右边的j叫做j2（注意，只是叫做！））：</p>
<pre><code>1. 执行时，首先是会执行等号右边的话，也就是==j1=j2==这一句话，那么这样的一句话，得到的结果是j1=0，对吧。
2. 这个时候如果按照正常的逻辑，那么应该是执行j++这句话了对吧。是这样没错，肯定是会执行j++这一句话的。注意：执行这个j2++的时候，并不和j1在同一个工作区，j2++完了之后，并没有任何的变量去接收它。导致j2++废弃。所以j一直都是0.
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>–操作符同理，其实细致点这个问题是可以看出来的，还是需要修炼基本功呀···</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 前置++ </tag>
            
            <tag> 后置++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对HashMap的思考]]></title>
      <url>/2018/08/09/2018-08-09-09-29-20/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap是一个散列表，它存储的内容是==Key-Value==键值对的映射。</p>
<p>类原型如下：</p>
<p>继承自抽象类AbstractMap<k,v>，实现Map接口，Cloneable主要是用于clone方法，以及序列化接口。</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<h1 id="Map的常用类型"><a href="#Map的常用类型" class="headerlink" title="Map的常用类型"></a>Map的常用类型</h1><p><img src="http://p2sj58chj.bkt.clouddn.com/blog/java.util.map类图.png" alt="enter description here"><br>继承Map接口的有以下几种：</p>
<ul>
<li>HashMap：根据键的HashCode值进行数据的存储，可以直接根据键获取值，访问速度很快。是非同步的，即线程不安全。==key和value都可以为null，但是只能有一个为null的key，value无限制。==</li>
<li>TreeMap：能够根据底层的红黑二叉树来对插入的数据按照==key==进行从小到大的排序。且其key不能为null，value可以为null。==key为null时，在代码编写阶段不会报错，但运行时报NullPointerException。==同时TreeMap非同步的，线程不安全。</li>
<li>HashTable：HashTable的key与value是不能为null，且和HashMap最大的区别是HashTable是线程安全的，其方法都是有==synchronized==关键字修饰的，其继承自==Dictionary==。但是不建议使用，因为并发不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。</li>
<li>LinkHashMap：采用的是链表的方式存储数据，使用Iterator进行遍历的时候，先得到的是最先插入的，即==保留了记录的插入顺序==，和HashMap的底层实现不同，导致使用LinkHashMap的时候的遍历效率比HashMap慢。同时key和value都可以为null，非同步，线程不安全。</li>
</ul>
<h1 id="HashMap的JDK1-6-1-7实现"><a href="#HashMap的JDK1-6-1-7实现" class="headerlink" title="HashMap的JDK1.6\1.7实现"></a>HashMap的JDK1.6\1.7实现</h1><p>在JDK1.6,1.7中，HashMap采用的是数组+链表的方式，即使用数组存放链表。同一个HashCode值的元素都是存储在一个链表里面，但是如果位于同一个链表的元素（就是HashCode值相等的元素）增多的时候，查找元素的时候就不能很好的发挥HashMap的功效了。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180809101056.png" alt="enter description here"></p>
<p>如图：</p>
<p>当调用map的put方法放入key-value键值对，那么首先会根据key的hashCode值，计算出在给定的key在数组中的位置，然后放在其后的单链表中。</p>
<p>这样的设计的好处是减少了Hash碰撞，即HashCode值相同并不一定意味着对象是相同的。那么这些HashCode怎么转化为数组空间的呢？一般是hash(key)%length来得到的。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>1、如果多个key通过hashCode%length这样的算法得到的index都是相同的，会不会被覆盖？</p>
<p>不会。当A通过计算得到index=1，放在链表中，如果接下来来了一个B，B通过计算得到的index也=1，那么做的事情就是使用头插法将新来的元素插入到链表的头结点。为什么使用头插法呢？可能是觉得新来的元素被查找的概率要高一点吧，毕竟查找是从头开始。</p>
<p>2、HashMap是允许存入key-value为null的Entry的，那么他们在什么位置呢？</p>
<p>null key总是放在entry的第一个元素。</p>
<p>3、get操作原理</p>
<p>get的函数原型如下：<code>public V get(Object key)</code>，先根据key的HashCode定位到数组的index，然后在这个index位置的链表进行遍历。</p>
<h1 id="HashMap在JDK1-8的实现"><a href="#HashMap在JDK1-8的实现" class="headerlink" title="HashMap在JDK1.8的实现"></a>HashMap在JDK1.8的实现</h1><p>在JDK1.8之后，也许是意识到了当链表长度过长带来的遍历效率的问题，因此，在JDK1.8中最重要的变化之一就是引入了红黑树，当同一个hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树。</p>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>
<p>有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><table>
<thead>
<tr>
<th>clear()</th>
<th>从 Map 中删除所有映射</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove(Object key)</td>
<td>从 Map 中删除键和关联的值</td>
</tr>
<tr>
<td>put(Object key, Object value)</td>
<td>将指定值与指定键相关联</td>
</tr>
<tr>
<td>putAll(Map t)</td>
<td>将指定 Map 中的所有映射复制到此 map</td>
</tr>
<tr>
<td>entrySet()</td>
<td>返回 Map 中所包含映射的 Set 视图。Set 中的每个元素都是一个 Map.Entry 对象，可以使用 getKey() 和 getValue() 方法（还有一个 setValue() 方法）访问后者的键元素和值元素</td>
</tr>
<tr>
<td>keySet()</td>
<td>返回 Map 中所包含键的 Set 视图。删除 Set 中的元素还将删除 Map 中相应的映射（键和值）</td>
</tr>
<tr>
<td>values()</td>
<td>返回 map 中所包含值的 Collection 视图。删除 Collection 中的元素还将删除 Map 中相应的映射（键和值）</td>
</tr>
<tr>
<td>get(Object key)</td>
<td>返回与指定键关联的值</td>
</tr>
<tr>
<td>containsKey(Object key)</td>
<td>如果 Map 包含指定键的映射，则返回 true</td>
</tr>
<tr>
<td>containsValue(Object value)</td>
<td>如果此 Map 将一个或多个键映射到指定值，则返回 true</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>如果 Map 不包含键-值映射，则返回 true</td>
</tr>
<tr>
<td>size()</td>
<td>返回 Map 中的键-值映射的数目</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC文件AJAX上传+JQuery文件进度条]]></title>
      <url>/2018/08/08/2018-08-08-05-56-11/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文件上传是一个很常用的功能，比如头像上传，视频上传等等，本文主要使用SpringMVC+Ajax实现文件上传，下载，删除等操作，同时重写CommonsMultipartResolver添加监听器ProgressListener，通过客户端轮询的方式来获取上传文件的进度。本文会首先介绍文件AJAX上传并获取进度的操作。</p>
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#文件上传">文件上传</a><ul>
<li><a href="#前端设计">前端设计</a></li>
<li><a href="#java后端设计">Java后端设计</a></li>
<li><a href="#commonsmultipartresolver文件上传解析器">CommonsMultipartResolver文件上传解析器</a></li>
<li><a href="#监听器">监听器</a></li>
<li><a href="#progress-bean">Progress Bean</a></li>
<li><a href="#controller">controller</a></li>
</ul>
</li>
<li><a href="#误区">误区</a><ul>
<li><a href="#在spring的配置文件中的commonmutipartresolver配置的id名称">在Spring的配置文件中的CommonMutipartResolver配置的id名称</a></li>
<li><a href="#轮询的方式">轮询的方式</a></li>
<li><a href="#demo文件下载地址">Demo文件下载地址</a></li>
</ul>
</li>
</ul>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>一般就文件上传的方式来说，有两种：</p>
<ul>
<li>第一种：使用FORM表单提交的方式，在这种提交的方式中，需要将FORM表单的==method==设置为POST方式，同时需要将==enctype==设置为multipart/form-data</li>
<li>第二种：使用AJAX的方式，使用这种方式来获取form表单中的二进制流也有两种实现策略：<ul>
<li>1、使用FormData对象：FormData对象是HTML5 的一个对象，目前的很多浏览器已经兼容。</li>
<li>2、使用Jquery.form.js插件：它提供了大量的操作表单的方法。<a href="http://jquery.malsup.com/form/" target="_blank" rel="noopener">详情可以点击这里查看官方文档</a></li>
</ul>
</li>
</ul>
<p>在开始之前需要添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h2><p>效果如图：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/blog/20180808205344.png" alt=""></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span></span><br><span class="line"><span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;文件上传下载&lt;/title&gt;</span><br><span class="line">    &lt;script src="jquery/jquery-3.3.1.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #progressbar &#123;</span><br><span class="line">        width: <span class="number">200</span>px;</span><br><span class="line">        border: <span class="number">1</span>px solid darkgray;</span><br><span class="line">        height: <span class="number">15</span>px;</span><br><span class="line">        border-radius: <span class="number">1</span>rem;</span><br><span class="line">        margin-top: -<span class="number">10</span>px;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    #fill &#123;</span><br><span class="line">        height: <span class="number">15</span>px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: <span class="number">15</span>px;</span><br><span class="line">        border-radius: <span class="number">1</span>rem;</span><br><span class="line">        background-color: mediumturquoise;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"progressbar"</span>&gt;</span><br><span class="line">    &lt;div id="fill"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;form action=<span class="string">"#"</span> id=<span class="string">"form"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"上传"</span> onclick=<span class="string">"upload()"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    var interval;</span><br><span class="line">    <span class="function">function <span class="title">upload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var formData = <span class="keyword">new</span> FormData($(<span class="string">"form"</span>)[<span class="number">0</span>]);</span><br><span class="line">        interval = setInterval(getProgress, <span class="number">100</span>);<span class="comment">//开启定时器（间歇调用）</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">"/upload"</span>,</span><br><span class="line">            type: <span class="string">"POST"</span>,</span><br><span class="line">            data: formData,</span><br><span class="line">            cache: <span class="keyword">false</span>,</span><br><span class="line">            processData: <span class="keyword">false</span>,<span class="comment">//此处需要设置为false</span></span><br><span class="line">            contentType: <span class="keyword">false</span>,<span class="comment">//此处需要设置为false</span></span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//轮询获取文件上传进度的方法</span></span><br><span class="line">    <span class="function">function <span class="title">getProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $(<span class="string">"#progressbar"</span>).show()</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">"getInfo"</span>,</span><br><span class="line">            type: <span class="string">"get"</span>,</span><br><span class="line">            success: function (progressdata) &#123;</span><br><span class="line">                <span class="keyword">if</span> (progressdata == <span class="string">"stop"</span>) &#123;</span><br><span class="line">                    clearInterval(interval);</span><br><span class="line">                &#125;</span><br><span class="line">                $(<span class="string">"#fill"</span>).css(<span class="string">"width"</span>, progressdata+<span class="string">"%"</span>);</span><br><span class="line">                $(<span class="string">"#fill"</span>).text(progressdata+<span class="string">"%"</span>);</span><br><span class="line">                console.log(progressdata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这里解释下：</p>
<p>使用的是刚才说到的第一种方式，即使用FormData对象的方式来进行ajax上传。</p>
<h2 id="Java后端设计"><a href="#Java后端设计" class="headerlink" title="Java后端设计"></a>Java后端设计</h2><p>刚才说到了我们的核心思想分为下面几步：</p>
<h2 id="CommonsMultipartResolver文件上传解析器"><a href="#CommonsMultipartResolver文件上传解析器" class="headerlink" title="CommonsMultipartResolver文件上传解析器"></a>CommonsMultipartResolver文件上传解析器</h2><p>1、重写CommonsMultipartResolver文件上传解析器，如果只是文件上传是不需要重写的，这里需要用到重写是因为需要设置文件上传的监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CustomMultipartResolver.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMultipartResolver</span> <span class="keyword">extends</span> <span class="title">CommonsMultipartResolver</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	FileUploadProgressListener progressListener;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MultipartParsingResult <span class="title">parseRequest</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">		String encoding = determineEncoding(request);<span class="comment">//获取字符编码，这个很重要</span></span><br><span class="line">		FileUpload fileUpload = prepareFileUpload(encoding);<span class="comment">//获取FileUpload对象</span></span><br><span class="line">		progressListener.setSession(request.getSession());<span class="comment">//保存数据到session</span></span><br><span class="line">		fileUpload.setProgressListener(progressListener);<span class="comment">//设置监听器</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request);<span class="comment">//解析数据</span></span><br><span class="line">			<span class="keyword">return</span> parseFileItems(fileItems, encoding);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileUploadBase.SizeLimitExceededException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MaxUploadSizeExceededException(fileUpload.getSizeMax(), ex);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileUploadException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MultipartException(<span class="string">"Could not parse multipart servlet request"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了以上的代码除了需要自己添加设置监听器的代码，其他的可以参考源码实现：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/blog/20180808211423.png" alt="enter description here"></p>
<p>为了让Spring知道这个multipartResolver的存在，还需要在springMVC.xml中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"com.dimple.resolver.CustomMultipartResolver"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;property name="defaultEncoding" value="UTF-8"/&gt;--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;property name="maxUploadSize" value="102400000 "/&gt;   &amp;lt;!&amp;ndash; 最大文件大小限制 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>2、既然说到了要监听，那么就需要设置一个监听器，此监听器是实现了ProgressListener接口，重写了update方法。</p>
<p>监听器代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*FileUploadProgressListener.java*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadProgressListener</span> <span class="keyword">implements</span> <span class="title">ProgressListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> HttpSession session;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置Session，这样能够将状态保存在session域中</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSession</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.session = session;</span><br><span class="line">		Progress status = <span class="keyword">new</span> Progress();</span><br><span class="line">		session.setAttribute(<span class="string">"status"</span>, status);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 文件上传会回调的update方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytesRead 已经读取到的字节数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> contentLength 该上传文件的总字节数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> items 当前是上传第几个文件，默认为1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> bytesRead, <span class="keyword">long</span> contentLength, <span class="keyword">int</span> items)</span> </span>&#123;</span><br><span class="line">		Progress status = (Progress) session.getAttribute(<span class="string">"status"</span>);</span><br><span class="line">		status.setBytesRead(bytesRead);</span><br><span class="line">		status.setContentLength(contentLength);</span><br><span class="line">		status.setItems(items);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Progress-Bean"><a href="#Progress-Bean" class="headerlink" title="Progress Bean"></a>Progress Bean</h2><p>3、以上可以看到有一个Progress类，此类为JavaBean，方便数据传递。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Progress.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Progress</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> bytesRead;<span class="comment">//已经上传的字节数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> contentLength;<span class="comment">//所有文件的总长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();<span class="comment">//开始上传的时间</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> items;<span class="comment">//正在上传第几个文件</span></span><br><span class="line">    <span class="comment">/*Geter and Seter*/</span></span><br><span class="line">    <span class="comment">/*toString*/</span></span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>4、以上所有都是为了Controller服务的，在Controller中，需要实现两个目标：</p>
<pre><code>- 实现文件上传
- 实现进度查询
</code></pre><p>文件上传的方式很简单：通过File类来设置文件上传的路径的问题，比如这个要放到哪个文件夹中，判断文件夹是否存在等等，还有文件的删除也需要用到File类。创建好文件夹后，便需要将它上传到刚才创建好的文件夹中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FileUploadController.java*/</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 文件上传的处理</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request request用于获取Session，方便向session存值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> file    文件上传类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 文件上传状态字符串：ok，error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, method = RequestMethod.POST)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(HttpServletRequest request, @RequestParam(<span class="string">"file"</span>)</span> CommonsMultipartFile[] file) </span>&#123;</span><br><span class="line">		String path = request.getSession().getServletContext().getRealPath(<span class="string">"upload"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; file.length; i++) &#123;</span><br><span class="line">			String fileName = file[i].getOriginalFilename();<span class="comment">//获取原始的文件名称</span></span><br><span class="line">			System.out.println(path);</span><br><span class="line">			File targetFile = <span class="keyword">new</span> File(path, fileName);</span><br><span class="line">			<span class="keyword">if</span> (!targetFile.exists()) &#123;</span><br><span class="line">				targetFile.mkdirs();<span class="comment">//创建文件夹</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				file[i].transferTo(targetFile);<span class="comment">//将文件转移到指定的文件夹中</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用于处理客户端轮询获取文件上传进度</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request 用于从session中取出值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果文件上传完毕返回stop，告诉客户端停止轮询；如果还没有上传完，返回当前进度。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"getInfo"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getProgress</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Progress progress = (Progress) request.getSession().getAttribute(<span class="string">"status"</span>);</span><br><span class="line">		System.out.println(progress);</span><br><span class="line">		DecimalFormat decimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"0"</span>);</span><br><span class="line">		String result = decimalFormat.format((<span class="keyword">float</span>) progress.getBytesRead() / (<span class="keyword">float</span>) progress.getContentLength() * <span class="number">100</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">"100"</span>.equals(result)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"stop"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getProgress方法中，就很简单了，由于监听器是将数据放在session域里面的，只需要将数据取出来进行处理传递到客户端即可。</p>
<h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><h2 id="在Spring的配置文件中的CommonMutipartResolver配置的id名称"><a href="#在Spring的配置文件中的CommonMutipartResolver配置的id名称" class="headerlink" title="在Spring的配置文件中的CommonMutipartResolver配置的id名称"></a>在Spring的配置文件中的CommonMutipartResolver配置的id名称</h2><p>此处的id必须要为multipartResolver，因为在SpringMV的DispatcherServlet中有一个==initMultipartResolver==方法，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the MultipartResolver used by this class.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If no bean is defined with the given name in the BeanFactory for this namespace,</span></span><br><span class="line"><span class="comment">	 * no multipart handling is provided.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Using MultipartResolver ["</span> + <span class="keyword">this</span>.multipartResolver + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			<span class="comment">// Default is no multipart resolver.</span></span><br><span class="line">			<span class="keyword">this</span>.multipartResolver = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Unable to locate MultipartResolver with name '"</span> + MULTIPART_RESOLVER_BEAN_NAME +</span><br><span class="line">						<span class="string">"': no multipart request handling provided"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在注释上就说明了如果不按照这个名字进行配置的话，就不会有multipart处理。</p>
<h2 id="轮询的方式"><a href="#轮询的方式" class="headerlink" title="轮询的方式"></a>轮询的方式</h2><p>在这个例子中，使用的是普通的轮询方法，就是隔一段时间就向客户端发送请求，服务器收到请求后马上返回响应消息并马上关闭连接。这种写法很简单，但是带来的问题也是显而易见的，因为这样的请求中，就拿我们的文件上传的进度来说，如果文件足够大，500ms去请求服务器，可能很多次都是获取的同样的数据，这样的方式占用带宽比较严重，比较浪费服务器的资源。</p>
<h2 id="Demo文件下载地址"><a href="#Demo文件下载地址" class="headerlink" title="Demo文件下载地址"></a>Demo文件下载地址</h2><p><a href="https://github.com/DimpleFeng/FileUploadSSM" target="_blank" rel="noopener">Click Me</a></p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 进度条 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Error running 'Tomcat'Unable to open debugger port (127.0.0.1:2148)的解决办法]]></title>
      <url>/2018/08/03/2018-8-3-20-36-12/</url>
      <content type="html"><![CDATA[<p>在Web项目运行的时候，IDEA可能会报Error running ‘Tomcat’: Unable to open debugger port (127.0.0.1:2148): java.net.SocketException “socket closed”错误，启动不了Tomcat，在这种时候，网上的解决办法大多都是修改端口的这种方式，但是这种方式治标不治本。</p>
<p>错误截图如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180803144001.png" alt="QQ截图20180803144001"></p>
<p>解决办法：</p>
<p>打开CMD命令行界面：</p>
<p>输入以下命令，查看1099端口号的占用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | find &quot;1099&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里看到的是PID为5440的进程占用1099端口，所以输入以下命令终止进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill -f -pid 5440</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180803210031.png" alt="QQ截图20180803210031"></p>
<p>重新启动Web项目就不会报错了</p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中接口和抽象类]]></title>
      <url>/2018/08/01/2018-8-1-20-35-28/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经常看到关于Java中的接口和抽象类的比较，看着这两难兄难弟确实还是有些像，又有些不想，借此，想好好总结下他们两。</p>
<h1 id="关于抽象类"><a href="#关于抽象类" class="headerlink" title="关于抽象类"></a>关于抽象类</h1><p>在Java中，抽象类是以abstract关键字修饰的。有抽象方法的一定是抽象类，反之，抽象类不一定有抽象方法，这句话是《Java编程思想》这本书中提到的，说的是只要是被关键字abstract修饰的类都叫抽象类，而不管这个类中是否含有抽象方法。抽象类的定义格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstaract class ClassName&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法： 抽象方法是一种特殊的方法，只有方法的声明，但是没有方法的实现。抽象方法的声明格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract void function();</span><br></pre></td></tr></table></figure></p>
<p>抽象类是为了继承而存在的，抽象出子类共有的一些特点，然后交给其具体的实现。</p>
<p>抽象类并不一定包含抽象方法，它和普通的类一样，也是可以拥有成员变量和普通的成员方法。</p>
<p>抽象类和普通的类的三点区别：</p>
<ul>
<li><p>抽象方法必须为public或者protected，缺省默认为public。</p>
</li>
<li><p>抽象方法不能用来创建对象。</p>
</li>
<li><p>如果一个类继承自一个抽象类，那么需要实现这个类的所有方法，如果没有实现这个类的所有方法，那么该类也需要被定义为abstract。<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801205707.png" alt="TIM截图20180801205707"></p>
</li>
</ul>
<p><strong>另外抽象类是可以有构造器的。</strong></p>
<h1 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h1><p>接口（interface）是对行为的抽象。在java 中定义一个接口的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface InterfaceName&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口中可以含有方法和变量。其中变量会被隐式的指定为public final static 类型。其中的方法会被隐式的指定为public abstract，且不能有方法的实现（“Interface abstract methods cannot have body”）。</p>
<p>实现一个接口需要用到implements关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements InterfaceA,InterfaceB&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个类可以实现多个接口。如果一个抽象类implements某个接口，可以不实现这个接口中的方法。非抽象类implements某个结构就必须要实现该接口中的所有方法。</p>
<h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><p>区别之处：</p>
<p>1、接口中的所有方法都是隐含的abstract的，而抽象类亦可以同时包含抽象和非抽象的方法。</p>
<p>2、一个类可以实现很多接口，但是只能继承自一个抽象类。</p>
<p>3、类可以不实现抽象类和接口中的所有方法，这种情况下的类需要被声明为abstract。</p>
<p>4、接口中的变量都是被默认声明为public static final的，而抽象类中的成员变量可以是各种类型的。</p>
<p>5、Java接口中的成员函数默认都是public的，抽象类中的成员函数可以是private、protected、public的。</p>
<p>其他：</p>
<p>1、接口是可以被接口继承的，通过extends关键字声明一个接口是一个接口的子接口，由于接口中的方法和常量都是public的，子接口将继承胡接口的全部方法和常量。</p>
<p>2、抽象类可以继承自实体类。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 接口 </tag>
            
            <tag> 抽象类 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jacoco服务器代码覆盖率测试工具使用（二）（远程Tomcat Web部署的方式）]]></title>
      <url>/2018/08/01/2018-8-1-16-37-56/</url>
      <content type="html"><![CDATA[<p>本文为系列文章：</p>
<p><a href="http://www.bianxiaofeng.com/2018/08/01/2018-8-1-15-32-13/">Jacoco服务器代码覆盖率测试工具使用（一）（IDEA插件的方式）</a><br><a href="http://www.bianxiaofeng.com/2018/08/01/2018-8-1-16-37-56/">Jacoco服务器代码覆盖率测试工具使用（二）（远程Tomcat Web部署的方式）</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了使用IDEA的方式进行代码覆盖率测试，当然这种方式是有一种局限就是只能在本地跑，而且需要安装IDEA的插件（Eclipse貌似插件下不了，也就不能使用了），如果想要测试已经部署在服务器上的Web项目的代码覆盖率的话，就需要用到下面说到的方法。</p>
<p>远程的服务器有Tomcat，galssfish等等，也可能用到一些中间件，如金蝶中间件等等。所以不同的远程服务器可能配置方式不同，但原理一样。</p>
<h1 id="安装部署前的说明"><a href="#安装部署前的说明" class="headerlink" title="安装部署前的说明"></a>安装部署前的说明</h1><p>本文主要是用到ant + jacoco的方式进行部署的。分为服务器和客户端，分别需要安装的软件环境配置如下：</p>
<p>服务器端： Java环境（这个肯定是有的，因为部署Tomcat这些是需要用到Java的），Jacoco JAR包；</p>
<p>客户端： Java环境，Ant环境，Jacoco JAR包。</p>
<p>需要安装的东西打包下载：</p>
<p><a href="https://download.csdn.net/download/qq_32454537/10577733" target="_blank" rel="noopener">点击我</a></p>
<h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>服务器端我分为两部分来说明，一个是Windows的服务器端，一个是Linux的服务器端，读者可以根据你自己的服务器系统来选择看哪部分的说明。服务器端使用的服务器环境统一为Tomcat。</p>
<h2 id="Windows端"><a href="#Windows端" class="headerlink" title="Windows端"></a>Windows端</h2><h3 id="安装Jacoco"><a href="#安装Jacoco" class="headerlink" title="安装Jacoco"></a>安装Jacoco</h3><p>在合适的目录，比如我直接就在C盘，把Jacoco的文件夹拷贝到此处就行，当然你也可以选择其他地方。</p>
<h3 id="修改服务器启动参数"><a href="#修改服务器启动参数" class="headerlink" title="修改服务器启动参数"></a>修改服务器启动参数</h3><p>首先打开tomcat的安装位置，找到bin目录下的catalina.bat文件，使用notepad++打开，添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">···set JAVA_OPTS=%JAVA_OPTS% -javaagent:C:\jacoco\lib\jacocoagent.jar=includes=*,output=tcpserver,address=192.168.73.130,port=4399,append=true,</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801171253.png" alt="TIM截图20180801171253"></p>
<p>说明如下（只说关键配置）：</p>
<p>A： 这段需要注意的是，写的是实际的Jacoco的jacocoagent.jar的位置，如果你是放在其他地方的，一定要保证其在服务器本地是可达状态的。  </p>
<p>B:  此处写的是服务器端的IP地址。</p>
<p>C： 此处是开放的端口，是指服务器上要开放给客户端的端口，只要是不被占用的端口号就可以。</p>
<p>服务器上的配置到此就结束了。</p>
<h2 id="Linux端"><a href="#Linux端" class="headerlink" title="Linux端"></a>Linux端</h2><p>Linux作为服务器是很多公司或者个人开发者的首选，Linux深度可配置，而且效率比Windows要高。</p>
<p>在Linux上也需要进行配置。</p>
<h3 id="Jacoco安装"><a href="#Jacoco安装" class="headerlink" title="Jacoco安装"></a>Jacoco安装</h3><p>首先是Jacoco的安装，同Windows的安装一样，放在合适的位置,示例是放在/home/dimple/Depo/jacoco目录下</p>
<h3 id="修改服务器启动参数-1"><a href="#修改服务器启动参数-1" class="headerlink" title="修改服务器启动参数"></a>修改服务器启动参数</h3><p>修改Tomcat的catalina.sh文件<br>加入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:home/dimple/Depo/jacoco/lib/jacocoagent.jar=includes=*,output=tcpserver,address=192.168.73.130,port=4399,append=true,</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801174001.png" alt="TIM截图20180801174001"><br>代码含义如上。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端也可以为Windows或者Linux，这里主要讲Windows的配置方式，Linux自测。</p>
<p>Windows需要配置Java环境，这里略过。</p>
<h2 id="下载Ant"><a href="#下载Ant" class="headerlink" title="下载Ant"></a>下载Ant</h2><p>下载Ant包：<a href="https://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">https://ant.apache.org/bindownload.cgi</a><br><img src="http://p2sj58chj.bkt.clouddn.com/101801.png" alt="101801"></p>
<p>下载解压到合适的目录，本示例解压到C:\work\apache-ant-1.10.5</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>【计算机】——【属性】——【高级系统设置】——【环境变量】，在系统环境变量下新建ANT_HOME；</p>
<p>然后在系统变量的【PATH】后追加%ANT_HOME%\bin<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801174615.png" alt="TIM截图20180801174615"><br>测试安装成功：<br>CMD输入：ant -version<br> <img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801180417.png" alt="TIM截图20180801180417"></p>
<h2 id="配置build-xml"><a href="#配置build-xml" class="headerlink" title="配置build.xml"></a>配置build.xml</h2><p>在ant的安装目录下的bin下新建一个buil.xml文件内容如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801182919.png" alt="TIM截图20180801182919"></p>
<p>对应的目录结构如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801183001.png" alt="TIM截图20180801183001"><br>在ant的bin目录下，打开命令行窗口，输入:ant dump生成jacoco.exec文件。<br><img src="http://p2sj58chj.bkt.clouddn.com/xyz.png" alt="xyz"><br> 输入ant report 生成测试报告。<br> <img src="http://p2sj58chj.bkt.clouddn.com/xyy.png" alt="xyy"><br>在build.xml文件中设置的report文件的保存地址中找到对应的report文件。</p>
<p>绿颜色表示代码被单元测试覆盖到<br>黄色表示部分覆盖<br>红色则表示完全没有覆盖到</p>
<p>到此教程结束。</p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Jacoco </tag>
            
            <tag> 代码覆盖率 </tag>
            
            <tag> 远程Tomcat部署 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 出现 “unable to access ''OpenSSL SSL_connectSSL_ERROR_SYSCALL in connection to github.com” 的解决办法]]></title>
      <url>/2018/08/01/2018-8-1-16-23-49/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天写了一篇博客，然后准备推到GitHub的时候发现报以下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unable to access &apos;https://github.com/DimpleFeng/dimplefeng.github.io.git/&apos;: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br></pre></td></tr></table></figure>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>Git支持三种协议，分别是：git://、ssh://和http://<br>因为HEXO也是将博文编译为静态的文件,然后再push到Git 上的。解决方法是取消http代理。</p>
<p>打开Git Bash输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>
<p>然后再提交HEXO博文就没问题了。</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jacoco服务器代码覆盖率测试工具使用（一）（IDEA插件的方式）]]></title>
      <url>/2018/08/01/2018-8-1-15-32-13/</url>
      <content type="html"><![CDATA[<p>本文为系列文章：</p>
<p><a href="http://www.bianxiaofeng.com/2018/08/01/2018-8-1-15-32-13/">Jacoco服务器代码覆盖率测试工具使用（一）（IDEA插件的方式）</a><br><a href="http://www.bianxiaofeng.com/2018/08/01/2018-8-1-16-37-56/">Jacoco服务器代码覆盖率测试工具使用（二）（远程Tomcat Web部署的方式）</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要以自己的实际项目经历写下一份Jacoco的使用总结，首先是IDEA的使用，在IDEA上有直接的插件可以使用。接下来的第二篇会说到远程Tomcat Web服务器的代码覆盖率测试。</p>
<p>代码覆盖（Code coverage）是软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80%或 90%。于是乎，测试人员费尽心思设计案例覆盖代码。用代码覆盖率来衡量，有利也有弊。</p>
<p>本文中，不会使用单元测试的方式来得到代码的覆盖率，因为IDEA有直接的插件（下面会顺手说明下这个插件）。一般来说，代码覆盖率这种东西应该是测试工程师做的工作，但是作为Java开发的我就是手痒想搞一搞呀···</p>
<h1 id="IDEA中的Coverage插件使用"><a href="#IDEA中的Coverage插件使用" class="headerlink" title="IDEA中的Coverage插件使用"></a>IDEA中的Coverage插件使用</h1><p>下载插件：<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801154145.png" alt="TIM截图20180801154145"></p>
<p>安装完成之后就可以在IDEA上看到：<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801154450.png" alt="TIM截图20180801154450"></p>
<p>点击这个按钮表示以代码覆盖统计的方式运行。（在此之前还是先进入到Tomcat的配置中设置为Jacoco的方式）<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801155443.png" alt="TIM截图20180801155443"></p>
<p>然后点击上述按钮进行运行。<br>运行完毕后关闭服务器，会在IDEA上弹出一个小框，如下，在下面的图片上就可以看到代码覆盖测试结果。<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180801160739.png" alt="TIM截图20180801160739"></p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Jacoco </tag>
            
            <tag> 代码覆盖率 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Intellij IDEA  2018.02 最新版 优化配置]]></title>
      <url>/2018/07/23/2018-7-23-09-36-27/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好吧工欲善其事必先利其器，我平时比较喜欢使用IDEA，这个软件可以很大程度上提高工作效率。<a href="http://www.jetbrains.com/" target="_blank" rel="noopener">IDEA</a>全称IntelliJ IDEA，是用于java语言开发的集成环境（也可用于其他语言），IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。<br>一直都有想过写一篇关于IDEA的设置优化的博文，因为确实网上的不是很适合我的风格。且网上的优化教程不是很多，自己摸索出来一下，希望能够帮到大家。</p>
<p>本文呢，会分为一下四部分进行说明：</p>
<ol>
<li><p>IDEA设置优化</p>
</li>
<li><p>IDEA的插件优化</p>
</li>
<li><p>IDEA的快捷键优化</p>
</li>
<li><p>IDEA使用过程中的一些问题（不定期更新）</p>
</li>
</ol>
<p>其中呢，会针对个别插件进行说明。</p>
<h1 id="IDEA设置优化"><a href="#IDEA设置优化" class="headerlink" title="IDEA设置优化"></a>IDEA设置优化</h1><p>这里不合适的插一脚：<br>使用的是最新版的IDEA，破解方法是采用<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a> 的方法。另外提供破解补丁的方法：</p>
<p>JetBrains全系列破解补丁v1.0： </p>
<p><a href="https://www.ghpym.com/jetbrainspath.html" target="_blank" rel="noopener">https://www.ghpym.com/jetbrainspath.html</a></p>
<h2 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h2><p>默认是区分大小写的，这样的代码提示不是很舒服，改！<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814173153.png" alt="代码提示修改"></p>
<h2 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h2><p>项目中的包只有很少数的时候是会冲突，那么，每次写代码的时候，每次都要手动导包？不行，改！<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814173628.png" alt="自动导包"></p>
<h2 id="启动的时候不自动进入到上一次的工程"><a href="#启动的时候不自动进入到上一次的工程" class="headerlink" title="启动的时候不自动进入到上一次的工程"></a>启动的时候不自动进入到上一次的工程</h2><p>项目运行的时候，想换一个工程？每次IDEA都要自动打开？不行，改！<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814174055.png" alt="enter description here"></p>
<h2 id="鼠标滑轮调整编辑区字体大小"><a href="#鼠标滑轮调整编辑区字体大小" class="headerlink" title="鼠标滑轮调整编辑区字体大小"></a>鼠标滑轮调整编辑区字体大小</h2><p>写代码的时候突然近视怎么办？放大，放大操作台繁琐？不行，改！<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814174413.png" alt="更改字体大小"></p>
<h2 id="自动保存文件"><a href="#自动保存文件" class="headerlink" title="自动保存文件"></a>自动保存文件</h2><p>还在ctrl+s保存文件？费时间，在编辑区失去鼠标焦点的时候进行自动保存岂不是更好？改！<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814174724.png" alt="自动保存文件"></p>
<h2 id="显示空白符，方法分隔符"><a href="#显示空白符，方法分隔符" class="headerlink" title="显示空白符，方法分隔符"></a>显示空白符，方法分隔符</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814175326.png" alt="显示空白符"></p>
<h2 id="设置模板"><a href="#设置模板" class="headerlink" title="设置模板"></a>设置模板</h2><p>请<a href="https://blog.csdn.net/u013412790/article/details/52807102" target="_blank" rel="noopener">参考</a>这个博文。</p>
<h2 id="设置只带的Terminal为Git-Bash"><a href="#设置只带的Terminal为Git-Bash" class="headerlink" title="设置只带的Terminal为Git Bash"></a>设置只带的Terminal为Git Bash</h2><p>Git是一定要使用的，使用的时候还需要单独切出去开一个Bash就太不方便了（个人不喜欢使用类似于小乌龟的Git GUI软件，认为减少了使用Git的乐趣）。</p>
<p><img src="htpp://p2sj58chj.bkt.clouddn.com/QQ截图20180821113239-2018821.png" alt="QQ截图20180821113239-2018821"></p>
<p>设置完成后正常情况下Terminal是要自动转换为unicode编码的。解决方案如下：</p>
<p>打开Git的安目录下的etc目录：我的是在D:\Program Files\Git\etc下：，找到bash.bashrc文件在其最后面添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 解决中文乱码</span><br><span class="line">export LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">export LC_ALL=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure>
<p>重新启动IDEA即可！</p>
<h1 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h1><h2 id="Custom-Postfix-Templates"><a href="#Custom-Postfix-Templates" class="headerlink" title="Custom Postfix Templates"></a>Custom Postfix Templates</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/blog/640.gif" alt="图片来源网络，致谢"></p>
<h2 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/blog/640 (1" alt="图片来源网络，致谢">.gif)<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/640.webp" alt="图片来源网络，致谢"></p>
<h2 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h2><p>彩色日志<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/64012.webp" alt="图片来源网络，致谢"></p>
<p>配上我自己比较喜欢的一套代码配色<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/QQ截图20180814180435.png" alt="代码配色"><br>JRebel for IntelliJ<br>配色方案：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Type        Color</span><br><span class="line">verbose:    #BBB</span><br><span class="line">debug:      #33B5E5</span><br><span class="line">info:       #9C0</span><br><span class="line">assert:     #A6C</span><br><span class="line">error:      #F44</span><br><span class="line">warning:    #FB3</span><br></pre></td></tr></table></figure>
<h2 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h2><p>JSON报文 –&gt; Java POJO 快速转换。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/blog/twst.gif" alt="GsonFormat"></p>
<h2 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h2><p>阿里巴巴Java开发规约扫描插件。</p>
<h2 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h2><p>彩虹括号。自动给代码块内花括号和括号加颜色。<br><img src="http://p2sj58chj.bkt.clouddn.com/blog/6402.webp" alt="Rainbow Brackets"></p>
<h1 id="IDEA的快捷键优化"><a href="#IDEA的快捷键优化" class="headerlink" title="IDEA的快捷键优化"></a>IDEA的快捷键优化</h1><h2 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Alt+O 优化导入的类和包 </span><br><span class="line">Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） </span><br><span class="line">fori/sout/psvm + Tab </span><br><span class="line">Ctrl+Alt+T 生成try catch 或者 Alt+enter </span><br><span class="line"><span class="built_in">CTRL</span>+ALT+T 把选中的代码放在 TRY&#123;&#125; IF&#123;&#125; ELSE&#123;&#125; 里 </span><br><span class="line">Ctrl + O 重写方法 </span><br><span class="line">Ctrl + I 实现方法 </span><br><span class="line">Ctr+shift+U 大小写转化 </span><br><span class="line">ALT+回车 导入包,自动修正 </span><br><span class="line">ALT+/ 代码提示 </span><br><span class="line"><span class="built_in">CTRL</span>+J 自动代码 </span><br><span class="line">Ctrl+Shift+J，整合两行为一行 </span><br><span class="line"><span class="built_in">CTRL</span>+空格 代码提示 </span><br><span class="line"><span class="built_in">CTRL</span>+SHIFT+SPACE 自动补全代码 </span><br><span class="line"><span class="built_in">CTRL</span>+ALT+L 格式化代码 </span><br><span class="line"><span class="built_in">CTRL</span>+ALT+I 自动缩进 </span><br><span class="line"><span class="built_in">CTRL</span>+ALT+O 优化导入的类和包 </span><br><span class="line">ALT+INSERT 生成代码(如GET,SET方法,构造函数等) </span><br><span class="line"><span class="built_in">CTRL</span>+E 最近更改的代码 </span><br><span class="line"><span class="built_in">CTRL</span>+ALT+SPACE 类名或接口名提示 </span><br><span class="line"><span class="built_in">CTRL</span>+P 方法参数提示 </span><br><span class="line"><span class="built_in">CTRL</span>+Q，可以看到当前方法的声明</span><br><span class="line"></span><br><span class="line">Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) </span><br><span class="line">Ctrl+Alt+V 提取变量</span><br></pre></td></tr></table></figure>
<h2 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Ctrl＋<span class="built_in">Shift</span>＋Backspace可以跳转到上次编辑的地 </span><br><span class="line">CTRL+ALT+ left/right 前后导航编辑过的地方 </span><br><span class="line">ALT+<span class="number">7</span> 靠左窗口显示当前文件的结构 </span><br><span class="line">Ctrl+F12 浮动显示当前文件的结构 </span><br><span class="line">ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </span><br><span class="line">CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方</span><br><span class="line"></span><br><span class="line">Ctrl+<span class="built_in">Shift</span>+Alt+N 查找类中的方法或变量 </span><br><span class="line">双击<span class="built_in">SHIFT</span> 在项目的所有目录查找文件 </span><br><span class="line">Ctrl+N 查找类 </span><br><span class="line">Ctrl+<span class="built_in">Shift</span>+N 查找文件 </span><br><span class="line">CTRL+G 定位行 </span><br><span class="line">CTRL+F 在当前窗口查找文本 </span><br><span class="line">CTRL+<span class="built_in">SHIFT</span>+F 在指定窗口查找文本 </span><br><span class="line">CTRL+R 在 当前窗口替换文本 </span><br><span class="line">CTRL+<span class="built_in">SHIFT</span>+R 在指定窗口替换文本 </span><br><span class="line">ALT+<span class="built_in">SHIFT</span>+C 查找修改的文件 </span><br><span class="line">CTRL+E 最近打开的文件 </span><br><span class="line">F3 向下查找关键字出现位置 </span><br><span class="line"><span class="built_in">SHIFT</span>+F3 向上一个关键字出现位置 </span><br><span class="line">选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </span><br><span class="line">F4 查找变量来源</span><br><span class="line"></span><br><span class="line">CTRL+<span class="built_in">SHIFT</span>+O 弹出显示查找内容</span><br><span class="line"></span><br><span class="line">Ctrl+W 选中代码，连续按会有其他效果 </span><br><span class="line">F2 或<span class="built_in">Shift</span>+F2 高亮错误或警告快速定位 </span><br><span class="line">Ctrl+Up/Down 光标跳转到第一行或最后一行下</span><br><span class="line"></span><br><span class="line">Ctrl+B 快速打开光标处的类或方法 </span><br><span class="line">CTRL+ALT+B 找所有的子类 </span><br><span class="line">CTRL+<span class="built_in">SHIFT</span>+B 找变量的类</span><br><span class="line"></span><br><span class="line">Ctrl+<span class="built_in">Shift</span>+上下键 上下移动代码 </span><br><span class="line">Ctrl+Alt+ left/right 返回至上次浏览的位置 </span><br><span class="line">Ctrl+X 删除行 </span><br><span class="line">Ctrl+D 复制行 </span><br><span class="line">Ctrl+/ 或 Ctrl+<span class="built_in">Shift</span>+/ 注释（// 或者/…/ ）</span><br><span class="line"></span><br><span class="line">Ctrl+H 显示类结构图 </span><br><span class="line">Ctrl+Q 显示注释文档</span><br><span class="line"></span><br><span class="line">Alt+F1 查找代码所在位置 </span><br><span class="line">Alt+<span class="number">1</span> 快速打开或隐藏工程面板</span><br><span class="line"></span><br><span class="line">Alt+ left/right 切换代码视图 </span><br><span class="line">ALT+ ↑/↓ 在方法间快速移动定位 </span><br><span class="line">CTRL+ALT+ left/right 前后导航编辑过的地方 </span><br><span class="line">Ctrl＋<span class="built_in">Shift</span>＋Backspace可以跳转到上次编辑的地 </span><br><span class="line">Alt+<span class="number">6</span> 查找TODO</span><br></pre></td></tr></table></figure>
<h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SHIFT+ENTER 另起一行 </span><br><span class="line"><span class="built_in">CTRL</span>+Z 倒退(撤销) </span><br><span class="line"><span class="built_in">CTRL</span>+SHIFT+Z 向前(取消撤销) </span><br><span class="line"><span class="built_in">CTRL</span>+ALT+F12 资源管理器打开文件夹 </span><br><span class="line">ALT+F1 查找文件所在目录位置 </span><br><span class="line">SHIFT+ALT+INSERT 竖编辑模式 </span><br><span class="line"><span class="built_in">CTRL</span>+F4 关闭当前窗口 </span><br><span class="line">Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </span><br><span class="line">Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单</span><br></pre></td></tr></table></figure>
<h2 id="svn快捷键"><a href="#svn快捷键" class="headerlink" title="svn快捷键"></a>svn快捷键</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+k 提交代码到SVN </span><br><span class="line">ctrl+<span class="built_in">t</span> 更新代码</span><br></pre></td></tr></table></figure>
<h2 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h2><p>其实常用的 就是F8 F7 F9 最值得一提的 就是Drop Frame 可以让运行过的代码从头再来</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alt+F8 <span class="built_in">debug</span>时选中查看值 </span><br><span class="line">Alt+<span class="keyword">Shift+F9，选择 </span><span class="built_in">Debug</span> </span><br><span class="line">Alt+<span class="keyword">Shift+F10，选择 </span>Run </span><br><span class="line">Ctrl+<span class="keyword">Shift+F9，编译 </span></span><br><span class="line">Ctrl+<span class="keyword">Shift+F8，查看断点</span></span><br><span class="line"><span class="keyword">F7，步入 </span></span><br><span class="line"><span class="keyword">Shift+F7，智能步入 </span></span><br><span class="line">Alt+<span class="keyword">Shift+F7，强制步入 </span></span><br><span class="line">F8，步过 </span><br><span class="line"><span class="keyword">Shift+F8，步出 </span></span><br><span class="line">Alt+<span class="keyword">Shift+F8，强制步过</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Alt+F9，运行至光标处 </span></span><br><span class="line">Ctrl+Alt+F9，强制运行至光标处 </span><br><span class="line">F9，恢复程序 </span><br><span class="line">Alt+F10，定位到断点</span><br></pre></td></tr></table></figure>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Alt+Shift+T，弹出重构菜单 </span><br><span class="line">Shift+F6，重命名 </span><br><span class="line">F6，移动 </span><br><span class="line">F5，复制 </span><br><span class="line">Alt+<span class="keyword">Delete</span>，安全删除 </span><br><span class="line">Ctrl+Alt+<span class="keyword">N</span>，内联</span><br></pre></td></tr></table></figure>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>1、IDEA Terminal中文乱码：</p>
<p><a href="http://www.bianxiaofeng.com/2018/08/27/2018-8-27-09-57-25/">http://www.bianxiaofeng.com/2018/08/27/2018-8-27-09-57-25/</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java创建对象的几种方式]]></title>
      <url>/2018/07/22/2018-7-22-21-20-34/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java是一门面向对象的程序设计语言，在日常开发中可能最常见的就是使用new关键字进行对象的创建了。其实创建对象的方式有很多中，在此，准备将实例化对象的方式进行总结，归纳整理。</p>
<p>在此之前，先简单的说明一般会有以下五种方式实例化对象：</p>
<p>①、使用new关键字；</p>
<p>②、使用Class类的newInstance方法；</p>
<p>③、使用Constructor类的newInstance方法；</p>
<p>④、使用Object类的clone方法；</p>
<p>⑤、使用反序列化的方式；</p>
<h1 id="实例化对象的几种方式"><a href="#实例化对象的几种方式" class="headerlink" title="实例化对象的几种方式"></a>实例化对象的几种方式</h1><h2 id="new关键字实例化对象"><a href="#new关键字实例化对象" class="headerlink" title="new关键字实例化对象"></a>new关键字实例化对象</h2><p>最常见，也是最简单的实例化对象的方式，通过这种方式，可以调用任意一个构造函数。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = new Student();</span><br><span class="line">Student student = new Student(&quot;小明&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="使用Class类的newInstance方法"><a href="#使用Class类的newInstance方法" class="headerlink" title="使用Class类的newInstance方法"></a>使用Class类的newInstance方法</h2><p>使用Class类的newInstance方法，此方法会默认调用对象的无参构造器，所以如果有重写构造器的话需要显式写出无参构造器，否则会报”InstantiationException”异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student classStudent = (Student) Class.forName(&quot;com.dimple.NewObject.Student&quot;).newInstance();//需要无参构造器，使用Class的</span><br><span class="line">classStudent.sayHello();</span><br></pre></td></tr></table></figure>
<p>当然了，也可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Student classStudent = Student.class.newInstance();</span><br><span class="line">classStudent.sayHello();</span><br></pre></td></tr></table></figure></p>
<p><em>使用Student.class代替常常的全限定名。</em></p>
<h2 id="使用Constructor的newInstance方法"><a href="#使用Constructor的newInstance方法" class="headerlink" title="使用Constructor的newInstance方法"></a>使用Constructor的newInstance方法</h2><p>java.lang.reflect.Constructor类中也有一个newInstance方法可以反射创建对象。<br>查看源码可以看到newInstance的方法如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/TIM截图20180722213916.png" alt="TIM截图20180722213916"></p>
<p>可以看到该方法是有不定参数的，而这个参数最终是调用ConstructorAccessor的newInstance方法的参数，所以Contstructor的newInstance方法是可以调用有参构造器的。</p>
<p>反观Class类的newInstance方法是没有任何参数可以传递的，这也就意味它不能调用有参构造，只能是使用默认的构造器进行实例化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Constructor&lt;Student&gt; constructor = Student.class.getConstructor(String.class);</span><br><span class="line">Student constructorStudent = constructor.newInstance(&quot;小明&quot;);</span><br></pre></td></tr></table></figure>
<p><em>Spring、Hibernate、Struts等开源框架，也是采用的这种方式进行实例化对象，并采用复杂的处理对它们进行管理。</em></p>
<h2 id="使用Clone方法"><a href="#使用Clone方法" class="headerlink" title="使用Clone方法"></a>使用Clone方法</h2><p>Clone方法是Object类的方法，而我们知道所有的类的父类都是Object，所以每个类都是可以使用clone方法的。在此之前，此类需要实现Cloneable接口，否则会触发CloneNotSupportedException异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student clone = (Student) constructorStudent.clone();</span><br><span class="line">clone.sayHello();</span><br></pre></td></tr></table></figure>
<p>当调用一个对象的clone方法的时候，JVM会创建一个新的对象，然后将该对象的内容全部拷贝到新的对象中。需要注意的是，使用clone方法不会调用构造函数。</p>
<h2 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h2><p>很早之前，在学习流的时候，有一个ObjectInputStream，在书上介绍的时候说到是序列化的时候用到的，当然了，现在整理这些知识的的时候也能够将以前的知识给串通。</p>
<p>把对象转换为字节序列的过程称为对象的序列化。<br>把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。  </p>
<p>java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p>
<p>为了实现序列化，需要让该类实现Serializable接口，否则会触发NotSerializableException异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;data.o&quot;));</span><br><span class="line">objectOutputStream.writeObject(clone);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;data.o&quot;));</span><br><span class="line">Student studentSerialization = (Student) objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line">studentSerialization.sayHello();</span><br></pre></td></tr></table></figure>
<p>首先是将对象序列化，然后通过反序列化获得一个新的对象，这种方式也是不走构造器的，直接由JVM创建对象。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>为了方便说明，也是直接写了几行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.dimple.NewObject;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Dimple on 2018/7/22/20:04</span><br><span class="line"> */</span><br><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	//含参构造器</span><br><span class="line">	public Student(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//无参构造器</span><br><span class="line">	public Student() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//定义的方法</span><br><span class="line">	public void sayHello() &#123;</span><br><span class="line">		System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//所有异常全部抛出</span><br><span class="line">	public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, CloneNotSupportedException, IOException &#123;</span><br><span class="line">//		1、使用new关键字创建对象</span><br><span class="line">		Student newStudent = new Student(&quot;小明&quot;);</span><br><span class="line">//		调用对象的方法</span><br><span class="line">		newStudent.sayHello();</span><br><span class="line">//		2、使用Class类的newInstance方法</span><br><span class="line">		Student classStudent = Student.class.newInstance();//需要无参构造器</span><br><span class="line">		classStudent.setName(&quot;小明&quot;);</span><br><span class="line">		classStudent.sayHello();</span><br><span class="line">//		3、使用Constructor类的newInstance方法</span><br><span class="line">		Constructor&lt;Student&gt; constructor = Student.class.getConstructor(String.class);//说明有参构造器的形参类型</span><br><span class="line">		Student constructorStudent = constructor.newInstance(&quot;小明&quot;);//使用的是有参构造器</span><br><span class="line">		constructorStudent.sayHello();</span><br><span class="line">//		4、使用Object类的clone方法，需要实现Cloneable接口</span><br><span class="line">		Student clone = (Student) constructorStudent.clone();</span><br><span class="line">		clone.sayHello();</span><br><span class="line">//		5、使用反序列化创建对象，需要实现Serializable接口</span><br><span class="line">//		    先进行序列化</span><br><span class="line">		ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;data.o&quot;));</span><br><span class="line">		objectOutputStream.writeObject(clone);</span><br><span class="line">		objectOutputStream.close();</span><br><span class="line">//		    再反序列化成为一个新的对象</span><br><span class="line">		ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;data.o&quot;));</span><br><span class="line">		Student studentSerialization = (Student) objectInputStream.readObject();</span><br><span class="line">		objectInputStream.close();</span><br><span class="line">		studentSerialization.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> new </tag>
            
            <tag> Class </tag>
            
            <tag> reflect </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线程相关总结]]></title>
      <url>/2018/07/22/2018-7-22-19-04-46/</url>
      <content type="html"><![CDATA[<h2 id="1、Object类的wait-、notify-；Thread类中接口、synchronized关键字。"><a href="#1、Object类的wait-、notify-；Thread类中接口、synchronized关键字。" class="headerlink" title="1、Object类的wait()、notify()；Thread类中接口、synchronized关键字。"></a>1、Object类的wait()、notify()；Thread类中接口、synchronized关键字。</h2><p>五种状态：</p>
<p><strong>New 新建状态</strong>：线程被创建后就进入到了新建状态，Thread thread=new Thread();</p>
<p><strong>Runnable 就绪状态</strong>：线程被创建后，其他线程调用该线程的start方法来启动该线程。处于就绪状态的线程，随时可能被CPU调度。</p>
<p><strong>Running 运行状态</strong>：线程获取CPU执行。线程只能从就绪状态转为运行状态。</p>
<p><strong>Blocked 阻塞状态：</strong> 线程因为某种原因放弃CPU的使用。只有直到线程进入到就绪状态，才有机会转入运行状态。</p>
<p><strong>等待阻塞</strong>： 调用线程的wait()方法，让线程等待某工作完成。</p>
<p><strong>同步阻塞</strong>： 线程在获取synchronized同步锁失败（同步锁被其他线程占用），会进入到同步阻塞状态。</p>
<p><strong>其他阻塞</strong>： 通过调用线程的sleep()或join或发出IO请求。</p>
<p><strong>Dead 死亡状态</strong>：线程执行完毕或者因为一场退出run()方法。</p>
<h2 id="2、实现多线程的两种方式"><a href="#2、实现多线程的两种方式" class="headerlink" title="2、实现多线程的两种方式"></a>2、实现多线程的两种方式</h2><ul>
<li><p>实现runnable接口</p>
</li>
<li><p>继承Thread类，该类实现了runnable接口</p>
</li>
</ul>
<p>Thread 和 Runnable 的相同点：都是“多线程的实现方式”。</p>
<p>Thread 和 Runnable 的不同点：</p>
<p>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>
<p>此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。</p>
<p>通常，建议通过“Runnable”实现多线程！</p>
<h2 id="3、start-和run-的区别"><a href="#3、start-和run-的区别" class="headerlink" title="3、start()和run()的区别"></a>3、start()和run()的区别</h2><p>start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。<br>run()   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>
<p>target是一个runnale对象，run()就是直接调用Thread的Runnable的run()方法。</p>
<h2 id="4、Synchronized关键字"><a href="#4、Synchronized关键字" class="headerlink" title="4、Synchronized关键字"></a>4、Synchronized关键字</h2><p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。</p>
<p>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。</p>
<p>不同线程对同步锁的访问是互斥的。</p>
<p>原则</p>
<p>第一条：当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>
<p>第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</p>
<p>第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>
<p>##5、线程的等待与唤醒<br>在Object类中定义了wait()、notify()和notifyAll()等接口；</p>
<p>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁；<br>而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程；</p>
<p>Object类中关于等待/唤醒的API详细信息如下：</p>
<p>notify()        – 唤醒在此对象监视器上等待的单个线程。</p>
<p>notifyAll()   – 唤醒在此对象监视器上等待的所有线程。</p>
<p>wait()                                         – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</p>
<p>wait(long timeout)                    – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<p>wait(long timeout, int nanos)  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<h2 id="6、线程让步"><a href="#6、线程让步" class="headerlink" title="6、线程让步"></a>6、线程让步</h2><p>方法：yieId()<br>作用：让步，让当前的线程由运行状态进入到就绪状态，从而让其他具有相同优先级的线程获得执行权。但是不能保证其他线程就一定能获得执行权，也有可能是当前线程又进入到运行状态继续运行。</p>
<p>yieId和wait区别：</p>
<p>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p>
<p>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>
<h2 id="7、线程休眠"><a href="#7、线程休眠" class="headerlink" title="7、线程休眠"></a>7、线程休眠</h2><p>sleep在一下Thread类中，作用是让当前的线程休眠，即当前线程会从运行状态进入到阻塞状态。当时间到了的时候，会从阻塞状态变为就绪状态，等待CPU调度。</p>
<p>sleep和wait的比较：</p>
<p>wait的作用是让当前线程由运行状态进入到阻塞状态，同时释放掉同步锁。而sleep的作用也是让当前线程进入到阻塞状态，但是不会释放掉同步锁。</p>
<h2 id="8、join"><a href="#8、join" class="headerlink" title="8、join"></a>8、join</h2><p>join()定义在Thread类中。<br>作用为：让“主线程”等待“子线程”结束之后才运行。</p>
<h2 id="9、interrupt-和线程终止方式"><a href="#9、interrupt-和线程终止方式" class="headerlink" title="9、interrupt()和线程终止方式"></a>9、interrupt()和线程终止方式</h2><p>interrupt()的作用是中断本线程。本线程中断自己是被允许的，其他线程调用本线程的interrupt方法的时候，会通过checkAccess()检查权限，这有可能抛出SecurityException异常。</p>
<p>通常我们会通过中断方式终止处于“阻塞状态”的线程。</p>
<p>当线程由于调用了sleep()、wait()、join()等方法而进入到阻塞状态；此时若调用线程的interrupt()方法将线程的中断标记设为了true，由于处于阻塞状态，中断标记会被清除，同时产生一个interruptException异常。将interruptException放在适当的位置就能终止线程；</p>
<p>interrupt()并不会终止“运行状态”的线程，它会将线程的中断标记设为true。（通过isInterrupted()方法判断线程是不是处于中断状态）。</p>
<p>终止线程的通用写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 1. isInterrupted()保证，只要中断标记为true就终止线程。</span><br><span class="line">        while (!isInterrupted()) &#123;</span><br><span class="line">            // 执行任务...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException ie) &#123;  </span><br><span class="line">        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>
<h2 id="10、线程优先级和守护线程"><a href="#10、线程优先级和守护线程" class="headerlink" title="10、线程优先级和守护线程"></a>10、线程优先级和守护线程</h2><p>Java 中的线程的优先级是1—10，默认优先级是5。</p>
<p>Java中有两种线程，用户线程和守护线程。可以通过isDaemon()（守护线程）方法来区别。用户线程一般执行用户级线程，而守护线程也就是后台线程。</p>
<p>PS：Java虚拟机在“用户线程”都结束后退出。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次实际项目从Eclipse转到IDEA的经历]]></title>
      <url>/2018/07/07/2018-7-7-16-35-54/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我的印象中，<strong>Eclipse</strong>是所有从事与Java开发相关的人员都熟知的一个IDE，在C/C++领域有微软的VS，VS也是号称宇宙第一IDE，足见它的强大。IDEA作为一个更好用的IDE工具，也是饱饱的吸引了我们的眼球。</p>
<p>此文会一个完整的项目作为引子，逐步讲解如何将一个<strong>Eclipse</strong>的JavaWeb项目转到IDEA上面，本文不会像到某度上面搜到的东西那样千篇一律，而是会完完整整的介绍该如何操作，也包括了IDEA和<strong>Eclipse</strong>的URL的问题。</p>
<h1 id="具体实施步骤"><a href="#具体实施步骤" class="headerlink" title="具体实施步骤"></a>具体实施步骤</h1><h2 id="Eclipse环境"><a href="#Eclipse环境" class="headerlink" title="Eclipse环境"></a><strong>Eclipse</strong>环境</h2><p>在这里首先说一下<strong>Eclipse</strong>的项目的相关环境，项目是采用直接配置<strong>Jar</strong>包的，所有的<strong>Jar</strong>包在<strong>Eclipse</strong>的<strong>WEB-INF</strong>的<strong>lib</strong>文件夹中。项目是采用的是主机名+端口号+项目名称作为首页的这种配置方式的，即<a href="http://localhost:8080/special" target="_blank" rel="noopener">http://localhost:8080/special</a> 这样的方式。</p>
<h2 id="1、导入项目"><a href="#1、导入项目" class="headerlink" title="1、导入项目"></a>1、导入项目</h2><p>首先打开IDEA，来到欢迎页面，选择import Project</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707164640.png" alt="QQ截图20180707164640"></p>
<h2 id="2、选择项目所在的文件夹"><a href="#2、选择项目所在的文件夹" class="headerlink" title="2、选择项目所在的文件夹"></a>2、选择项目所在的文件夹</h2><p>选择OK打开</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707164801.png" alt="QQ截图20180707164801"></p>
<h2 id="3、选择Eclipse项目"><a href="#3、选择Eclipse项目" class="headerlink" title="3、选择Eclipse项目"></a>3、选择Eclipse项目</h2><p>打开后界面如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707164952.png" alt="QQ截图20180707164952"></p>
<h2 id="4、选择Eclipse项目的位置"><a href="#4、选择Eclipse项目的位置" class="headerlink" title="4、选择Eclipse项目的位置"></a>4、选择Eclipse项目的位置</h2><p>这里保持默认即可</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707165053.png" alt="QQ截图20180707165053"></p>
<h2 id="5、然后一路next保持默认，此处省略图。"><a href="#5、然后一路next保持默认，此处省略图。" class="headerlink" title="5、然后一路next保持默认，此处省略图。"></a>5、然后一路next保持默认，此处省略图。</h2><h2 id="6、Facets配置"><a href="#6、Facets配置" class="headerlink" title="6、Facets配置"></a>6、Facets配置</h2><p>项目加载完成后，一般来说会在右下角有一个绿色的<strong>FrameWords Detected</strong>的提示，点击进去，IDEA会自动配置好相关的<strong>Facets</strong>，如果没有的不要慌，后面会介绍二般的情况。<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707165544.png" alt="QQ截图20180707165544"></p>
<p>点击后会自动加载Hibernate和Web的Facets，这里说一句，根据不同的项目架构，会有不同的Facets，但是可能存在不全的情况。比如这里是SSH架构的，只提示配置Hibernate的，这样肯定是不行的。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707173845.png" alt="QQ截图20180707173845"></p>
<h2 id="7、添加Facets"><a href="#7、添加Facets" class="headerlink" title="7、添加Facets"></a>7、添加Facets</h2><p><strong>Ctrl+Alt+Shift+S</strong> 进入到项目结构，然后侧边栏选择<strong>Facets</strong>，添加其他的<strong>Facet</strong>，这里添加的是<strong>Spring</strong>，以及<strong>Struts2</strong>的。</p>
<p>这里以Spring的为例：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170143.png" alt="QQ截图20180707170143"></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170220.png" alt="QQ截图20180707170220"></p>
<p>选中项目中<strong>Spring</strong>的配置文件就可</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707173948.png" alt="QQ截图20180707173948"></p>
<p><strong>Struts2</strong>也是一样，这里省略。<br>这里提示下，<strong>Struts2</strong>的配置文件，需要在Web的目录下，不是在项目的文件下，注意！</p>
<p>完整的Facets如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170623.png" alt="QQ截图20180707170623"></p>
<h2 id="8、配置Artifacts"><a href="#8、配置Artifacts" class="headerlink" title="8、配置Artifacts"></a>8、配置Artifacts</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170900.png" alt="QQ截图20180707170900"></p>
<p>选择该项目<strong>Modules</strong>即可：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170955.png" alt="QQ截图20180707170955"></p>
<h2 id="9、配置输出路径"><a href="#9、配置输出路径" class="headerlink" title="9、配置输出路径"></a>9、配置输出路径</h2><p>（这里很重要，尤其是一些项目是将spring的配置文件这些东西，全部放在<strong>Eclipse</strong>的默认输出路径的，如果你的项目是没有一些比较奇葩的操作的，可以这里不用改）</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707171612.png" alt="QQ截图20180707171612"></p>
<p>注意还需要配置一处：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707171654.png" alt="QQ截图20180707171654"></p>
<h2 id="10、配置Web容器"><a href="#10、配置Web容器" class="headerlink" title="10、配置Web容器"></a>10、配置Web容器</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170713.png" alt="QQ截图20180707170713"></p>
<p>选择<strong>Add Configuration</strong></p>
<p>选择<strong>Tomcat</strong></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707170759.png" alt="QQ截图20180707170759"></p>
<p>然后将Artifact添加到该容器中</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707171753.png" alt="QQ截图20180707171753"></p>
<p>如果，项目比较大，且很多路径已经写死了，这里就需要修改一下URL，因为IDEA是默认的localhost:8080就能访问到项目的。如果你的项目运行404或者在<strong>Eclipse</strong>的时候就是localhost:8080/projectname，就在这里修改一下。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707171945.png" alt="QQ截图20180707171945"></p>
<h2 id="10、删除一些没用的东西"><a href="#10、删除一些没用的东西" class="headerlink" title="10、删除一些没用的东西"></a>10、删除一些没用的东西</h2><p>这里可以删除<strong>Eclipse</strong>的一些配置文件<br>如图：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707174116.png" alt="QQ截图20180707174116"><br>同时 ，一般来说，IDEA中<strong>resource</strong>目录中存的都是一些配置文件，这个时候，更希望是将文件夹标记为<strong>resource</strong></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180707174047.png" alt="QQ截图20180707174047"></p>
<p>到此本文完···</p>
]]></content>
      
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC拦截器]]></title>
      <url>/2018/07/01/2018-7-1-20-55-35/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>拦截器是Spring MVC中强大的控件，它可以在处理器之前做一些操作，或者是在处理器完成后做一个操作，甚至是在渲染视图，也就是viewResolver之后做一些操作。我们知道，在web.xml网站描述文件中，我们会配置DispatchServlet，然后SpringMVC启动的时候就回通过@requestMapping的注解解析统一资源定位符URI和处理器handler之间的关系，在运行的时候，通过URL请求找到对应的HandlerMapping，然后构建HandlerExecuteChain对象，再交给handleradapter执行。</p>
<h1 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h1><p>一般要实现拦截器，需要实现HandlerInterceptor接口，这个接口有三个方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,</span><br><span class="line">			@Nullable ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,</span><br><span class="line">			@Nullable Exception ex) throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个方法意义：</p>
<p>1、preHandler():在处理器之前执行的前置方法，这样SpringMVC可以在进入到处理器之前进行一些处理，需要注意的是，这里返回的是一个Boolean，这会影响到后面的SpringMVC的执行。<br>2、postHandler():在处理器执行之后执行的后置方法，处理器handler执行完毕会调用它。<br>3、afterCompletion():无论是否产生异常，都会在渲染视图之后执行。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180701211936.png" alt="QQ截图20180701211936"></p>
<p>这里需要注意的是，当preHandler返回false后，就不会执行postHandler和afterCompletion方法。</p>
<h2 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h2><p>拦截器需要实现HandlerInterceptor接口，在SpringMVC中，可以通过一个虚类拦截器来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还需要在SpringMVC的配置文件中设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;!--配置拦截器拦截的路径--&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/*.do&quot;/&gt;</span><br><span class="line">        &lt;!--配置拦截器--&gt;</span><br><span class="line">        &lt;bean class=&quot;com.dimple.interceptor.RoleInterceptor&quot;/&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>
<h2 id="多个拦截器"><a href="#多个拦截器" class="headerlink" title="多个拦截器"></a>多个拦截器</h2><p>这里限于篇幅，只是随便说一下多个拦截器执行的顺序，当配置了多个拦截器后，执行的顺序和责任链的执行顺序一样。<br>按照配置文件配置：<br>    如果在配置文件中按照顺序配置拦截器1、拦截器2、拦截器3</p>
<p>在正常情况下，Spring会从第一个拦截器进入到前置方法，这样前置方法是按照配置顺序执行的，然后再运行处理器的代码，最后再运行后置方法。<strong>注意这里的后置方法和前置方法是逆序的，和责任链的运行顺序是一样的。</strong></p>
<p>如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">preHandler1</span><br><span class="line">preHandler2</span><br><span class="line">preHandler3</span><br><span class="line">···</span><br><span class="line">/**控制器执行的方法*/</span><br><span class="line">···</span><br><span class="line">postHandler3</span><br><span class="line">postHandler2</span><br><span class="line">postHandler1</span><br><span class="line">···</span><br><span class="line">afterCompletion3</span><br><span class="line">afterCompletion2</span><br><span class="line">afterCompletion1</span><br></pre></td></tr></table></figure>
<p>但是如果前置方法返回false，那么后面的prehandler方法也不会执行了，而控制器和所有的postHandler也不会执行。执行过preHandler方法且方法返回为true的拦截器的完成方法afterCompletion会按照配置顺序的逆序执行。</p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaEE </tag>
            
            <tag> springMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC和Struts2的区别]]></title>
      <url>/2018/06/27/2018-6-27-10-38-53/</url>
      <content type="html"><![CDATA[<p>1、    springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。<br>2、    springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。<br>3、    Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Jquery的attr()和prop()方法]]></title>
      <url>/2018/06/27/2018-6-27-09-22-28/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在jQuery中有许多的功能能够简化开发流程，jQuery是一个JavaScript的库，封装了许多方法，很多时候，你会发现，在实现某个功能的时候，会发现这个功能的实现可以使用多种方法。</p>
<p>本文主要是介绍jQuery设置属性的两个方法：attr（attributes）和prop（properties）。</p>
<h1 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h1><p>我们知道有的浏览器在input表单项中写disabled或者checked就可以了，但是有的浏览器需要写成disabled=”disabled”或者checked=”checked”才可以，比如用attr(“checked”)获取checkbox的checked属性时选中的时候可以取到值,值为”checked”但没选中获取值就是undefined。</p>
<p>jQuery1.6之后，使用prop来获取这些属性就能解决问题，使用统一的返回true或者false。</p>
<p>在jQuery的3.3.1中有以下说明，截图如下：</p>
<h2 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180627093125.png" alt="QQ截图20180627093125"></p>
<h2 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180627093151.png" alt="QQ截图20180627093151"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>对于以上，官方文档上说到：</p>
<p>对于prop：</p>
<blockquote>
<p>获取在匹配的元素集中的第一个元素的属性值。<br>随着一些内置属性的DOM元素或window对象，如果试图将删除该属性，浏览器可能会产生错误。jQuery第一次分配undefined值的属性，而忽略了浏览器生成的任何错误</p>
</blockquote>
<p>对于attr：</p>
<blockquote>
<p>设置或返回被选元素的属性值。</p>
</blockquote>
<h2 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;嘿咻&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;%--此处的库需要换成你自己的或者是cdn--%&gt;</span><br><span class="line">    &lt;script src=&quot;jquery/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">c1:&lt;input id=&quot;c1&quot; name=&quot;checkbox&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;&lt;/br&gt;</span><br><span class="line">c2:&lt;input id=&quot;c2&quot; name=&quot;checkbox&quot; type=&quot;checkbox&quot; checked=true/&gt;&lt;/br&gt;</span><br><span class="line">c3:&lt;input id=&quot;c3&quot; name=&quot;checkbox&quot; type=&quot;checkbox&quot; checked=&quot;&quot;/&gt;&lt;/br&gt;</span><br><span class="line">c4:&lt;input id=&quot;c4&quot; name=&quot;checkbox&quot; type=&quot;checkbox&quot; checked/&gt;&lt;/br&gt;</span><br><span class="line">c5:&lt;input id=&quot;c5&quot; name=&quot;checkbox&quot; type=&quot;checkbox&quot; /&gt;&lt;/br&gt;</span><br><span class="line">c6:&lt;input id=&quot;c6&quot; name=&quot;checkbox&quot; type=&quot;checkbox&quot; checked=false/&gt;&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var a1=$(&quot;#c1&quot;).attr(&quot;checked&quot;);</span><br><span class="line">    var a2=$(&quot;#c2&quot;).attr(&quot;checked&quot;);</span><br><span class="line">    var a3=$(&quot;#c3&quot;).attr(&quot;checked&quot;);</span><br><span class="line">    var a4=$(&quot;#c4&quot;).attr(&quot;checked&quot;);</span><br><span class="line">    var a5=$(&quot;#c5&quot;).attr(&quot;checked&quot;);</span><br><span class="line">    var a6=$(&quot;#c6&quot;).attr(&quot;checked&quot;);</span><br><span class="line"></span><br><span class="line">    var p1=$(&quot;#c1&quot;).prop(&quot;checked&quot;);</span><br><span class="line">    var p2=$(&quot;#c2&quot;).prop(&quot;checked&quot;);</span><br><span class="line">    var p3=$(&quot;#c3&quot;).prop(&quot;checked&quot;);</span><br><span class="line">    var p4=$(&quot;#c4&quot;).prop(&quot;checked&quot;);</span><br><span class="line">    var p5=$(&quot;#c5&quot;).prop(&quot;checked&quot;);</span><br><span class="line">    var p6=$(&quot;#c6&quot;).prop(&quot;checked&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;a1:&quot;+a1);</span><br><span class="line">    console.log(&quot;a2:&quot;+a2);</span><br><span class="line">    console.log(&quot;a3:&quot;+a3);</span><br><span class="line">    console.log(&quot;a4:&quot;+a4);</span><br><span class="line">    console.log(&quot;a5:&quot;+a5);</span><br><span class="line">    console.log(&quot;a6:&quot;+a6);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;p1:&quot;+p1);</span><br><span class="line">    console.log(&quot;p2:&quot;+p2);</span><br><span class="line">    console.log(&quot;p3:&quot;+p3);</span><br><span class="line">    console.log(&quot;p4:&quot;+p4);</span><br><span class="line">    console.log(&quot;p5:&quot;+p5);</span><br><span class="line">    console.log(&quot;p6:&quot;+p6);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180627095316.png" alt="QQ截图20180627095316"></p>
<p>可以看到使用attr去获取标签的固有属性的时候，返回的是undefined。而prop返回的是true或者false。</p>
<p>那么什么时候使用atrr什么时候使用prop呢：</p>
<p>总结如下：</p>
<ul>
<li><p>添加属性名称就能够生效的时候使用prop，比如checked和selected</p>
</li>
<li><p>具有true和false两个返回值的属性使用prop方法</p>
</li>
<li><p>对于HTML元素本身就带有的固有属性，在处理时，使用prop方法</p>
</li>
<li><p>对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Jquery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于REST风格的编程]]></title>
      <url>/2018/06/26/2018-6-26-09-47-10/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。</p>
</blockquote>
<p>REST本身不是架构，只是一种架构风格，理解它的时候要参考这个架构风格出现的环境所施加的约束条件。<br>REST的目的是“建立十年内不会过时的软件系统架构”，所以它具备三个特点：</p>
<ol>
<li>状态无关 —— 确保系统的横向拓展能力  </li>
<li>超文本驱动，Fielding的原话是”hypertext-driven” —— 确保系统的演化能力</li>
<li>对 resource 相关的模型建立统一的原语，例如：uri、http的method定义等 —— 确保系统能够接纳多样而又标准的客户端。</li>
</ol>
<p>这样对URL进行了限制，用于定义资源。简单来说就是定义了<strong>如何设计系统来对外提供服务</strong>。使用HTTP+JSON就可以搞定一切。</p>
<h1 id="REST详解"><a href="#REST详解" class="headerlink" title="REST详解"></a>REST详解</h1><p>REST究竟是什么？因为REST的内涵非常丰富，所以很难用一两句话解释清楚这个问题。</p>
<p>首先，REST是Web自身的架构风格。REST也是Web之所以取得成功的技术架构方面因素的总结。REST是世界上最成功的分布式应用架构风格（成功案例：Web，还不够吗？）。它是为 运行在互联网环境 的 分布式 超媒体系统量身定制的。互联网环境与企业内网环境有非常大的差别，最主要的差别是两个方面：</p>
<p>可伸缩性需求无法控制：并发访问量可能会暴涨，也可能会暴跌。</p>
<p>安全性需求无法控制：无法控制客户端发来的请求的格式，很可能会是恶意的请求。</p>
<p>而所谓的“超媒体系统”，即，使用了超文本的系统。可以把“超媒体”理解为超文本+媒体内容。</p>
<p>REST是HTTP/1.1协议等Web规范的设计指导原则，HTTP/1.1协议正是为实现REST风格的架构而设计的。新的Web规范，其设计必须符合REST的要求，否则整个Web的体系架构会因为引入严重矛盾而崩溃。这句话不是危言耸听，做个类比，假如苏州市政府同意在市区著名园林的附近大型土木，建造大量具有后现代风格的摩天大楼，那么不久之后世界闻名的苏州园林美景将不复存在。</p>
<p>上述这些关于“REST是什么”的描述，可以总结为一句话：REST是所有Web应用都应该遵守的架构设计指导原则。当然，REST并不是法律，违反了REST的指导原则，仍然能够实现应用的功能。但是违反了REST的指导原则，会付出很多代价，特别是对于大流量的网站而言。</p>
<h1 id="SpringMVC的REST风格请求"><a href="#SpringMVC的REST风格请求" class="headerlink" title="SpringMVC的REST风格请求"></a>SpringMVC的REST风格请求</h1><p>在HTTP协议里面，有以下几个表示操作方式的动词：<br>GET、POST、PUT、DELETE，分别对应着查询、增加、修改、删除操作。</p>
<p>在SpringMVC中可以使用rest风格占位符的方式，使用注解@PAthVariable实现将URL中的数据复制到Java的具体变量上。</p>
<p>比如以下：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th style="text-align:center">HTTP方式</th>
<th style="text-align:right">解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://localhost:8080/stu/1" target="_blank" rel="noopener">http://localhost:8080/stu/1</a></td>
<td style="text-align:center">GET</td>
<td style="text-align:right">获取id为1的数据（这里假设要取的是学生数据） </td>
</tr>
<tr>
<td><a href="http://localhost:8080/stu" target="_blank" rel="noopener">http://localhost:8080/stu</a></td>
<td style="text-align:center">GET</td>
<td style="text-align:right">获取所有的学生数据 </td>
</tr>
<tr>
<td><a href="http://localhost:8080/stu/1" target="_blank" rel="noopener">http://localhost:8080/stu/1</a></td>
<td style="text-align:center">DELETE</td>
<td style="text-align:right">删除id为1的学生的数据信息</td>
</tr>
<tr>
<td><a href="http://localhost:8080/stu/1" target="_blank" rel="noopener">http://localhost:8080/stu/1</a></td>
<td style="text-align:center">PUT</td>
<td style="text-align:right">修改id为1的学生的数据信息</td>
</tr>
<tr>
<td><a href="http://localhost:8080/stu" target="_blank" rel="noopener">http://localhost:8080/stu</a></td>
<td style="text-align:center">POST</td>
<td style="text-align:right">新增一条学生数据</td>
</tr>
</tbody>
</table>
<p>对于以上的URL可以采用以下controller处理：</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>对应URL：<a href="http://localhost:8080/stu" target="_blank" rel="noopener">http://localhost:8080/stu</a> 获取所有的学生的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@responseBody//表示返回的JSON数据</span><br><span class="line">@RequestMapping(value=&quot;/stu&quot;,method=RequestMethod.GET)</span><br><span class="line">public Msg toAddPage()&#123;//这里的Msg是自己封装的utils，封装了返回给client端的数据</span><br><span class="line">    //获取到service端处理的数据</span><br><span class="line">    return Msg.success().add(&quot;students&quot;,studentService.getStudents());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应URL：<a href="http://localhost:8080/stu/1" target="_blank" rel="noopener">http://localhost:8080/stu/1</a> 获取学生id为1的学生数据</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>对应URL：<a href="http://localhost:8080/stu" target="_blank" rel="noopener">http://localhost:8080/stu</a> 新增一条数据</p>
<p>所有的数据都在formData中（可以F12查看网络请求）,使用SpringMVC自动封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@responseBody//表示返回的JSON数据</span><br><span class="line">@RequestMapping(value=&quot;/stu&quot;,method=RequestMethod.POST)</span><br><span class="line">public Msg toAddPage(Student student)&#123;//这里的Msg是自己封装的utils，封装了返回给client端的数据</span><br><span class="line">    studentService.saveStudent(student);</span><br><span class="line">    return Msg.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>对应的URL：<a href="http://localhost:8080/stu/1" target="_blank" rel="noopener">http://localhost:8080/stu/1</a> 更新学生id为1的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@responseBody//表示返回的JSON数据</span><br><span class="line">@RequestMapping(value=&quot;/stu&#123;id&#125;&quot;,method=RequestMethod.PUT)</span><br><span class="line">public Msg toAddPage(Student student)&#123;//这里的Msg是自己封装的utils，封装了返回给client端的数据</span><br><span class="line">    studentService.updateStudentById(id);//此时student中是有id的，是SpringMVC封装好了的</span><br><span class="line">    return Msg.success().add(&quot;student&quot;,student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用PUT、DELETE方法的时候，还需要注意一点就是，底层的Tomcat容器是只支持POST方式的，为了方便的使用rest风格的URL,在SpringMVC中提供一个过滤器：HiddenHttpMethodFilter，配置好此过滤器就可以使用PUT这些方法了。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>对应的URL：<a href="http://localhost:8080/stu/1" target="_blank" rel="noopener">http://localhost:8080/stu/1</a> 删除id为1的学生的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@responseBody//表示返回的JSON数据</span><br><span class="line">@RequestMapping(value=&quot;/stu&#123;id&#125;&quot;,method=RequestMethod.PUT)</span><br><span class="line">public Msg toAddPage(@pathVariable(value=&quot;id&quot;Integer id))&#123;//这里的Msg是自己封装的utils，封装了返回给client端的数据</span><br><span class="line">    studentService.deleteStudentById(id);</span><br><span class="line">    return Msg.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> RESt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在线考试系统——项目说明]]></title>
      <url>/2018/06/13/2018-6-13-15-09-50/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇关于JavaEE的课程设计项目的部分文档部分。项目的名称为《学生在线考试系统》。</p>
<h2 id="项目名称：学生在线考试系统"><a href="#项目名称：学生在线考试系统" class="headerlink" title="项目名称：学生在线考试系统"></a>项目名称：<strong>学生在线考试系统</strong></h2><p><strong>分工：</strong><br>    边小丰：后端代码编写<br>    黄慧：项目前端代码编写，原型设计</p>
<p><strong>需求分析</strong></p>
<p>在线考试系统提高了考试的可靠性、有效性和工作效率，降低了考试成本,顺应了社会的网络化趋势,必将成为一种不可或缺的考试方式。本文研究的目的是设计一个易于管理和维护的面向教学的考试系统，具有一定的通用性，能够满足多门课程的测试与考核要求。为教师开展平时考核及期末考核提供一个考核平台；为学生利用网络自主学习提供条件；为不同课程的网上考试提供平台。</p>
<p>随着Internet 的迅速发展和广泛普及，网络化教育代表了教育改革的一个<br>发展方向，已经成为现代教育的一个特征，并对教育的发展形成新的推动力。远程教育成为现代教育技术未来发展的重要方向之一，考试测试作为远程教育的一个子系统也成为一个重要的研究领域。</p>
<p>Internet技术的发展使得考试的技术手段和载体发生了革命性的变化，Internet的开放性、分布性的特点和基于Internet的巨大的计算能力使得考试突破了时间和空间的限制。与传统考试模式相比，在线考试具有无可比拟的优越性，它可以将传统考试过程中的试卷组织、审定印制、传送收集、登记发放、评判归档各个环节缩小到一至两个环节，几乎屏蔽了所有人工直接干预考试活动的可能性，不但能够节约大量的时日、人力、物力与财力，而且还可以大幅度增加考试成绩的客观性和公正性。</p>
<p>传统的考试方式般要经过人工出卷、考生考试、人工阅卷等过程。对于一些课程来说，随着考生数量的增加，教师出卷阅卷的工作量将会越来越大，并且其工作十分烦琐和非常容易出错。在线考试系统课题产生的背景是当今教育信息化的趋势及我国高校教育信息化系统的建设，目的是充分利用学校现有的计算机软、硬件和网络资源实现无纸化考试以避免传统手工考试的不足。与传统考试模式相比，网上考试渗入了更多的技术环节，对实现安全性的途径、方法也提出了更高的技术要求。通过Internet来实现网上考试，是现代教育技术的一个具体体现，具有很重要的现实意义。</p>
<p>基于以上，项目具有较大的实行意义，对于需求的主要解释说明如下：</p>
<p>系统可以分为管理员和学生两大类。</p>
<ul>
<li><p>管理员端可以对对学生信息、试卷信息进行增加、删除、修改、查询等，同时可以指定试题所属的试卷，同时可以查询学生考试的成绩，修改密码，退出系统等。</p>
</li>
<li><p>学生端可以选择试卷进行考试，修改账号密码，查询考试成绩，退出系统等。</p>
</li>
</ul>
<p><strong>数据库库需求分析</strong></p>
<p>针对一般考试的需求，设计如下的数据项：</p>
<ul>
<li>管理员manager：管理员ID、管理员账号、管理员密码</li>
<li>试卷paper：创建时间、试卷ID、试卷名称</li>
<li>学生student：学生ID、学生姓名、学生性别、学生密码、学生专业、学生身份证号码</li>
<li>试题question：试题ID、试题题目、试题答案，试题选项、试题类型</li>
<li>题卷：ID、考试时间、考试试卷ID、考试学生ID、考试成绩</li>
</ul>
<p><strong>功能设计</strong></p>
<p><strong>流程图</strong></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/在线考试系.jpg" alt="在线考试系"></p>
<p><strong>用例图</strong></p>
<ul>
<li>管理员端：</li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/在线考试系统用例图·1.jpg" alt="在线考试系统用例图·1"></p>
<ul>
<li>学生端：</li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/在线考试系统用例图.jpg" alt="在线考试系统用例图"></p>
<p><strong>ER图</strong></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/在线考试系统数据库ER图.jpg" alt="在线考试系统数据库ER图"></p>
<p><strong>安全</strong></p>
<p>为了防止为登录用户通过URL链接直进入到系统，本系统通过将实时监测相关的session里面的currentUser是否为空来判断是否是合法用户。</p>
<p><strong>测试</strong></p>
<p>JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。</p>
<p>为了更加方便的测试某项功能是否能够根据输入得到合理的输出，系统通过Junit5进行单元测试。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ObjectMapper类]]></title>
      <url>/2018/06/07/2018-6-7-09-58-02/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ObjectMapper类是Jackson库的主要类。它提供一些功能将转换成Java对象匹配JSON结构，反之亦然。它使用JsonParser和JsonGenerator的实例实现JSON实际的读/写。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用Jackson，首先需要相关的jar包。对于使用maven的，需要添加以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>同时，也可以直接下载Jar包。</p>
<p><a href="https://download.csdn.net/download/qq_32454537/10475066" target="_blank" rel="noopener">点我直达</a></p>
<p>当然了，也可以通过maven的仓库，然后选择jar包下载。</p>
<p><a href="http://mvnrepository.com/" target="_blank" rel="noopener">点我直达</a></p>
<h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><h2 id="Java对象转换为JSON对象"><a href="#Java对象转换为JSON对象" class="headerlink" title="Java对象转换为JSON对象"></a>Java对象转换为JSON对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectMapper objectMapper = new ObjectMapper();  </span><br><span class="line">          </span><br><span class="line">        //序列化的时候序列对象的所有属性  </span><br><span class="line">        objectMapper.setSerializationInclusion(Include.ALWAYS);  </span><br><span class="line">          </span><br><span class="line">        //反序列化的时候如果多了其他属性,不抛出异常  </span><br><span class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);  </span><br><span class="line">          </span><br><span class="line">        //如果是空对象的时候,不抛异常  </span><br><span class="line">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);  </span><br><span class="line">          </span><br><span class="line">        //取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式  </span><br><span class="line">        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  </span><br><span class="line">        objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;))</span><br></pre></td></tr></table></figure>
<p>Person 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int id, String name, String password) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    /*省略get和set方法*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.dimple.ObjectMapperDemo;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">public class ObjectMapperTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JsonProcessingException &#123;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">        Person person = new Person(1, &quot;tom&quot;, &quot;123&quot;);</span><br><span class="line">        String jsonString = objectMapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(&quot;JsonString: &quot; + jsonString);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180612215912.png" alt="QQ截图20180612215912"></p>
<p>可以看到，使用Jackson类就可以将Java对象转换为Json对象。</p>
<p>PS：还需要注意，如果ObjectMapper的configure设置FAIL_ON_EMPTY_BEANS为false，那么对应的实体类的属性没有get方法也不会抛出异常，但是这个属性默认的是true，即必须要有get方法，这个需要注意。</p>
<p>错误如图：</p>
<blockquote>
<p>com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.dimple.ObjectMapperDemo.Person and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)</p>
</blockquote>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180612221201.png" alt="QQ截图20180612221201"></p>
<h2 id="JSON对象转为Java对象"><a href="#JSON对象转为Java对象" class="headerlink" title="JSON对象转为Java对象"></a>JSON对象转为Java对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectMapperTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);</span><br><span class="line">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);</span><br><span class="line">        Person person = new Person(1, &quot;tom&quot;, &quot;123&quot;);</span><br><span class="line">        String jsonString = objectMapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(&quot;JsonString: &quot; + jsonString);</span><br><span class="line"></span><br><span class="line">        Person person1 = objectMapper.readValue(jsonString, Person.class);</span><br><span class="line">        System.out.println(person1.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180612221454.png" alt="QQ截图20180612221454"></p>
<h2 id="Java数组对象和JSON数组对象转换"><a href="#Java数组对象和JSON数组对象转换" class="headerlink" title="Java数组对象和JSON数组对象转换"></a>Java数组对象和JSON数组对象转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectMapperTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">        //Java数组转换为JSON数组</span><br><span class="line">        Person person = new Person(1, &quot;tom&quot;, &quot;123&quot;);</span><br><span class="line">        Person person1 = new Person(2, &quot;jack&quot;, &quot;123445&quot;);</span><br><span class="line">        List&lt;Person&gt; personList = new ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(person);</span><br><span class="line">        personList.add(person1);</span><br><span class="line">        String jsonString = objectMapper.writeValueAsString(personList);</span><br><span class="line">        System.out.println(&quot;JsonString List: &quot; + jsonString);</span><br><span class="line">        //Json数组转换为Java数组</span><br><span class="line">        //JavaType</span><br><span class="line">        JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, Person.class);</span><br><span class="line">        List&lt;Person&gt; list = objectMapper.readValue(jsonString,javaType);</span><br><span class="line">        //打印出list中的值</span><br><span class="line">        for (Person person2 : list) &#123;</span><br><span class="line">            System.out.println(person2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> ObjectMapper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AJAX异步请求和JQuery的post,get,getJSON,ajax函数的使用]]></title>
      <url>/2018/06/05/2018-6-5-10-29-56/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>ajax:是一种与服务器交互的技术，在不刷新全部网页的情况下，更新某些表单项的数据。实现对部分网页的刷新。<br>常用场景：百度或者谷歌的时候，输入的时候给出具体的提示。</p>
</blockquote>
<h1 id="关于XHR（XMLHttpRequest）"><a href="#关于XHR（XMLHttpRequest）" class="headerlink" title="关于XHR（XMLHttpRequest）"></a>关于XHR（XMLHttpRequest）</h1><p>XHR时AJAX的基础，所有的浏览器都支持XMLHTTPRequest对象，老年版本的IE5/6使用的是ActiveXObject。所以一般来说，为了兼容性，还是会做一个判断，判断用户的浏览器支不支持XHR。检测的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">    xhr=new XMLHttpRequest();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    xhr=new ActiveXObject(&quot;Mircosoft.XMLHTTP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建XHR：<br><code>xhr=new XMLHttpRequest</code></p>
<p>老年IE：<br><code>xhr=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</code></p>
<h1 id="XHR请求"><a href="#XHR请求" class="headerlink" title="XHR请求"></a>XHR请求</h1><p>如果需要将请求发送到服务器，需要使用到XMLHttpRequest对象的open()和send()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(method,url,async);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p> 相当于设置参数。</p>
<p> 原型如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(method,url,async);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>method: 请求的类型，GET和POST。<br><em>注意：使用POST还是GET需要根据具体的情况，下面是一张比对图：</em><br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180605110537.png" alt="QQ截图20180605110537"></p>
</li>
<li><p>url：在服务器上访问的地址</p>
</li>
<li>async：Boolean，true（异步），false（同步，注意，如果为false，那么在加载数据的时候会直接禁止掉当前窗口，不能再做其他交互）</li>
</ul>
<h2 id="send-方法"><a href="#send-方法" class="headerlink" title="send()方法"></a>send()方法</h2><p>将请求发送到服务器。</p>
<p>当使用的是GET方法的时候，直接使用send()。如果使用的是POST方法，send(String string)。一般string的内容为要发送的数据。</p>
<h2 id="POST和GET请求服务器方式对比："><a href="#POST和GET请求服务器方式对比：" class="headerlink" title="POST和GET请求服务器方式对比："></a>POST和GET请求服务器方式对比：</h2><h3 id="不带参数："><a href="#不带参数：" class="headerlink" title="不带参数："></a>不带参数：</h3><p>POST：  </p>
<p>xhr.open(“POST”,”/test”,true);<br>xhr.send();</p>
<p>GET:</p>
<p>xhr.open(“GET’,”/test”,true);<br>xhr.send();</p>
<p>可以看到在不带参数的时候都一样的，区别在于，使用GET可能会导致查询到缓存数据，解决的办法是添加唯一标识，比如当前的时间或者随机数等。</p>
<h3 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h3><p>POST:</p>
<p>xhr.open(“POST”,”/test”,true);<br>xhr.send(“name=test&amp;age=19”);</p>
<p>GET:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr=open(&quot;GET&quot;,&quot;/test?name=test&amp;age=19&quot;,true);</span><br><span class="line">xhr=send();</span><br></pre></td></tr></table></figure>
<p>可以看到，这里的区别是使用GET是直接将参数添加到url中，使用POST是直接将参数添加到send()的形参中。</p>
<h1 id="XHR响应"><a href="#XHR响应" class="headerlink" title="XHR响应"></a>XHR响应</h1><p>使用XMLHttpRequest对象的responseText或responseXML属性。</p>
<ul>
<li>responseText：获取字符串形式的响应数据。</li>
<li>responseXML:获取XML形式的响应数据。</li>
</ul>
<h1 id="onreadystatechange事件"><a href="#onreadystatechange事件" class="headerlink" title="onreadystatechange事件"></a>onreadystatechange事件</h1><p>当请求被发送到服务器的时候，需要做一个基于响应的任务。<br>每当readyState改变时，就会触发onreadystatechange事件。</p>
<p>readyState属性存有XMLHTTPRequest的状态信息。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180605113646.png" alt="QQ截图20180605113646"></p>
<p>readyState有五个状态（0-4）：</p>
<ul>
<li>0：请求未初始化</li>
<li>1：服务器连接已建立</li>
<li>2：请求接收</li>
<li>3：请求处理</li>
<li>4：请求处理完成</li>
</ul>
<p>当readyState == 4的时候，表示后台已经处理完成了request，status == 200,表示返回的结果是OK的。（注：onreadystatechange事件被触发5次，对应着状态0-4）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr=function()&#123;</span><br><span class="line">    if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123;</span><br><span class="line">        /*执行操作*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Jquery使用AJAX"><a href="#Jquery使用AJAX" class="headerlink" title="Jquery使用AJAX"></a>Jquery使用AJAX</h1><p>一般来说，JQuery中有\$.get、\$.post、\$.getJSON以及最原始的ajax()函数等。</p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>写法如下：<code>$(selector).get(url,data,success(response,status,xhr),dataType)</code></p>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">  url: url,  </span><br><span class="line">  data: data,  </span><br><span class="line">  success: callback,  </span><br><span class="line">  dataType: dataType  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于参数含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:right">解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:right">表示请求的url </td>
</tr>
<tr>
<td>data</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示连同请求发送到服务器的数据 </td>
</tr>
<tr>
<td>success(response,status,xhr)</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示当请求成功后运行的函数。respose表示包含来回请求的结果数据。status表示请求的状态，xhr表示XMLHttpRequest对象。</td>
</tr>
<tr>
<td>dataType</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示预计的服务器响应的数据类型，默认JQuery会自动判断。</td>
</tr>
</tbody>
</table>
<h2 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h2><p>函数原型：<code>￥（selector）.post(url,data,success(response,status,xhr),dataType)</code></p>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">  url: url,  </span><br><span class="line">  data: data,  </span><br><span class="line">  success: callback,  </span><br><span class="line">  dataType: dataType  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于参数含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:right">解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:right">表示请求的url </td>
</tr>
<tr>
<td>data</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示连同请求发送到服务器的数据 </td>
</tr>
<tr>
<td>success(response,status,xhr)</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示当请求成功后运行的函数。respose表示包含来回请求的结果数据。status表示请求的状态，xhr表示XMLHttpRequest对象。</td>
</tr>
<tr>
<td>dataType</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示预计的服务器响应的数据类型，默认JQuery会自动判断。</td>
</tr>
</tbody>
</table>
<h2 id="getJSON"><a href="#getJSON" class="headerlink" title="getJSON()"></a>getJSON()</h2><p>函数原型：<code>$(selector).getJSON(url,data,success(data,status,xhr))</code><br>等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">  url: url,  </span><br><span class="line">  data: data,  </span><br><span class="line">  success: callback,  </span><br><span class="line">  dataType: json  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:right">解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:right">表示请求的url </td>
</tr>
<tr>
<td>data</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示连同请求发送到服务器的数据 </td>
</tr>
<tr>
<td>success(response,status,xhr)</td>
<td style="text-align:center">否</td>
<td style="text-align:right">表示当请求成功后运行的函数。respose表示包含来回请求的结果数据。status表示请求的状态，xhr表示XMLHttpRequest对象。</td>
</tr>
</tbody>
</table>
<p>函数没有type参数，返回的结果默认为json类型。</p>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax()"></a>ajax()</h2><p>ajax主要是执行异步请求，是JQUery的底层AKAX封装的实现，高层封装为$.get(),$.post()等。另外ajax()方法返回一个XMLHTTPRequest对象。</p>
<p>比如下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xmlHttpRequest=$.ajax(&#123;url:&quot;test&quot;,async:false&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在进行前端代码编写的时候，如果只是更改小规模的数据的时候，采用ajax的方式能更好的方便用户体验，而使用JS的底层的代码显得相对复杂，JQuery能够帮助我们更好的进行开发。同时\$.get()和\$.post()方法返回的都是字符串（不设置dataType的情况）,\$.getJSON()返回的是JSON数据。使用\$.ajax()，返回的是一个XMLHttpRequest对象。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> JQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java异常]]></title>
      <url>/2018/05/31/2018-5-31-15-40-24/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在面试的过程中一般会问道关于Java的异常处理相关的内容，异常处理是一般容易被忽略的，但是确是很考验一个程序员功底的方面。本文会介绍关于异常，以及关于异常的面试会问到的一些问题。</p>
<h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><blockquote>
<p>异常：程序在运行的过程中，如果程序执行出错，阻止了程序的正常运行，那么就会产生异常。而在Java中有一套解决方案，这就是异常处理机制。Java中的异常机制是针对正常运行程序的一个必要补充，一般来说没有加入异常机制，程序也能正常运行，但是，由于入参、程序逻辑的严谨度，总会有期望之外的结果生成，因此加入异常机制的补充，就是为了更好的处理意料之外的结果。</p>
</blockquote>
<p>首先说第一点：</p>
<p><strong>所有的异常类的父类是throwable</strong>，这个出现在我的笔试题上面，是一道判断题，但是当时没有回答正确。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180531155359.png" alt="QQ截图20180531155359"><br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180531155458.png" alt="QQ截图20180531155458"></p>
<p>通过以上两张图就能看到Exception和Error的直接父类是Throwable，而Throwable是实现了Serializable接口，Object的子类。</p>
<p>以上就是它们三者的关系。</p>
<p>首先具体说下Exception。</p>
<h1 id="Exception的分类"><a href="#Exception的分类" class="headerlink" title="Exception的分类"></a>Exception的分类</h1><p>Java中的异常分为两大类：</p>
<ul>
<li>Checked Exception （受检异常，也叫非运行时异常）</li>
<li>Unchecked Exception （也叫RuntimeException，运行时异常）</li>
</ul>
<p>所有的运行时异常都是直接或者间接的继承自RuntimeException类的，比如下面图中的空指针异常。<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180531160546.png" alt="QQ截图20180531160546">  </p>
<p>凡是没有继承RuntimeException而是直接继承的Exception的，叫做受检异常。<br>比如IO异常。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180531160737.png" alt="QQ截图20180531160737"></p>
<p>接下来具体的说明这些异常：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/858860-20170911125844719-1230755033.png" alt="858860-20170911125844719-1230755033"></p>
<p>其他要说的：</p>
<h2 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h2><p>对于Checked Exception ，Java要求程序员对这样的操作进行预处理。即用try、catch、finally或者throws，要么在方法中使用TCF三连，或者直接抛出交给他的上一级进行处理。</p>
<p>对于这样的情况是必须要进行处理的，如果不进行处理，程序都不能被编译。</p>
<p>比如常见的加载驱动：<br><code>Class.forName(&quot;xxx&quot;)</code>就必须要进行处理，否则会抛出ClassNotFoundException受检异常，不处理是不能通过编译的。</p>
<h2 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h2><p>对于Unchecked Exception来说，一般是不需要进行处理的，程序能正常的通过编译。但是为了程序的严谨性，一般还是会在可能发生异常的地方进行TCF三连处理。这类异常常见的如下：</p>
<ul>
<li>ArithmeticException 算术异常</li>
<li>NullPointerException 空指针异常</li>
<li>ClassCastException 类转换异常</li>
<li>ArrayIndexOutOfBoundsException 数组索引越界异常</li>
</ul>
<p>OK，再说下异常的捕获，关于异常，<strong>一般是先捕获小的异常（子类），再捕获大的异常（父类）</strong>。一般是不建议直接用Exception来全给捕获了。</p>
<p>最后加一个面试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void testException1() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           System.out.println(&quot;In try first&quot;);</span><br><span class="line">           int i = 3 / 0;</span><br><span class="line">           System.out.println(&quot;In try&quot;);</span><br><span class="line">           return;</span><br><span class="line">       &#125; catch (ArithmeticException a) &#123;</span><br><span class="line">           System.out.println(&quot;In catch&quot;);</span><br><span class="line">       &#125;finally &#123;</span><br><span class="line">           System.out.println(&quot;In finally&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(&quot;In end&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public void testException2() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           int i = 3 / 0;</span><br><span class="line">           System.out.println(&quot;In try&quot;);</span><br><span class="line">           return;</span><br><span class="line">       &#125; catch (ArithmeticException a) &#123;</span><br><span class="line">           System.out.println(&quot;In catch&quot;);</span><br><span class="line">       &#125;finally &#123;</span><br><span class="line">           System.out.println(&quot;In finally&quot;);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(&quot;In end&quot;);        </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>关于以上的代码，可以自己打断点看一下运行过程：</p>
<p>结论如下：</p>
<p>1、在TCF语句中，try部分的代码如果产生了异常，会被catch到然后转入catch语句块中进行处理，最后调用finally语句块（如果有的话）进行最后的资源清理等等工作。</p>
<p>2、但是如果在finally语句块中有return语句，那么是不会再执行下面的语句的。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的内存回收与内存泄漏的防治]]></title>
      <url>/2018/05/31/2018-5-31-10-00-19/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于JVM（Java虚拟机）的GC（垃圾回收机制）来说，是否回收一个对象的标准是：是否还有引用变量指向该对象。只有有引用变量指向该对象，那么JVM就不会考虑去回收它。</p>
<p>而在学习Java的时候，一般都是会说：Java有一套完整的垃圾回收机制，程序员可以不需要考虑内存。但是在实际应用中，还是会出现“内存泄漏”的情况。  </p>
<h1 id="对象在内存中的状态"><a href="#对象在内存中的状态" class="headerlink" title="对象在内存中的状态"></a>对象在内存中的状态</h1><p>基本上可以将JVM中的对象引用理解为离散中学到的有向图。</p>
<p>将对象当做有向图的<strong>顶点</strong>，将引用关系当做有向图的有向边，有向边总是从引用端指向被引用的变量。在JVM中，Java的各种对象都是由各个线程创建的，所以可以将Java的线程对象作为有向图的起点。</p>
<p>如果按照上述的方式，对于某一个对象来说，始终有大于等于一条路径能够从起点指到它，那么它就不会被GC。当然，如果找不到一条路径能够指向它，那么它就可能会被回收（注意这里说的是可能，因为GC的回收机制是由一套相对复杂的算法来决定的，所有的对象并不是失去引用马上就会被回收）。</p>
<p>那么，是不是所有的对象，只要有引用指向它，它就不会被回收呢？但是是否定的，原因请继续往下看。</p>
<p>而一般来说，对于Java中的对象引用有4种方式：强引用、弱引用、软引用和虚引用。</p>
<p>关于这几种引用的概念，简单的说明如如下：</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>对于强引用来说，可能我们平时在写代码的时候，都是用的强引用，被强引用的Java对象时不会被垃圾回收机制给回收的。即使系统资源非常紧张，即使有些变量以后都不会用到，JVM也不会强制回收被强类型引用的变量，如果系统内存实在不够，程序会直接抛出OutOfMemory异常。</p>
<p>而我们在平常的开发中，使用的最多的也是这种，比如<br><code>1Person person =new Person();</code></p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用需要通过SoftReference来实现，当一个对象只具有SoftReference时，它可能会被垃圾回收机制给回收，但是对于SoftReference的对象来说，当系统资源足够时，它是不会被系统回收，程序可以使用该对象，但是当系统资源不够的时候，GC会回收它。</p>
<p>使用的方法一般如下：</p>
<p><code>SoftReference&lt;Person&gt;[] persons=new SoftReference[1000000]</code></p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用和软引用有些相似，区别在于 弱引用的生命周期更短，弱引用需要通过WeakReference来实现，对于只有弱引用对象，当GC运行时，无论系统资源是否足够，该对象都会被回收。（这里还是需要提醒一下，GC的运行不是实时的，不是说当该对象不再被引用变量引用的时候，GC会立即运行来回收它）</p>
<p>当然了，这样的设计是有一定的道理的，这样是为了更加好的解决系统资源。由于GC的不定时，所以可能会遇到空指针异常，所以在进行业务逻辑处理的时候，建议在开始的时候，判断下该对象是不是为空。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用通过PhantomReference类实现，它完全类似于没有引用。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独被使用，虚引用必须要和引用队列（ReferenceQueue）一起使用。</p>
<h2 id="对象在堆中的几种状态"><a href="#对象在堆中的几种状态" class="headerlink" title="对象在堆中的几种状态"></a>对象在堆中的几种状态</h2><p>一个对象在堆中运行时，根据它在有向图中的状态可以分为3种：</p>
<h3 id="可达状态"><a href="#可达状态" class="headerlink" title="可达状态"></a>可达状态</h3><p>当一个对象被创建后，有一个以上的引用变量引用它，在有向图中可以从起始顶点导航到该对象，那么就处于可达状态。</p>
<h3 id="可恢复状态"><a href="#可恢复状态" class="headerlink" title="可恢复状态"></a>可恢复状态</h3><p>如果程序中某个对象不在有任何引用变量引用它，它将先进入可恢复状态，此时从有向图的顶点不能导航到该对象，在这个状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，会调用可恢复状态的对象的finalize方法进行资源清理，如果在系统调用finalize方法重新让一个以上的引用引用该对象，那么这个对象就可以变成可达状态。否则，该对象将进入到不可达状态。</p>
<h3 id="不可达状态"><a href="#不可达状态" class="headerlink" title="不可达状态"></a>不可达状态</h3><p>当对象的所有关联都被切断，且系统调用所有对象finalize依然没有使该对象变为可达状态，那这个对象将永久性的失去引用，当一个对象处于不可达状态时，系统才会真正的回收该对象所占用的资源。</p>
<h1 id="Java的内存泄漏"><a href="#Java的内存泄漏" class="headerlink" title="Java的内存泄漏"></a>Java的内存泄漏</h1><blockquote>
<p>定义：程序运行过程中会不断的分配内存空间，那些不再使用的内存空间应该立即回收它，从而保证系统再次使用这些内存，如果存在无用的内存被回收回来，那么就叫内存泄漏。</p>
</blockquote>
<h2 id="内存管理的技巧"><a href="#内存管理的技巧" class="headerlink" title="内存管理的技巧"></a>内存管理的技巧</h2><p>1、尽量使用直接量，比如String s=:”hello”;而不是String s=new String (“hello”)，这两种方法都会在再字符串缓冲池里面有缓存，区别是使用new的方式底层会创建一个char[]数组。</p>
<p>2、使用StringBuilder和StringBuffer进行字符串连接。如果使用String对象进行字符串连接，会生成大量的临时字符串会导致性能下降。</p>
<p>3、尽早释放无用对象的引用。</p>
<p>4、尽量少使用静态变量，因为静态变量的生命周期和类同步，只要class没有被卸载，那么就会一直常驻内存。</p>
<p>5、避免在经常调用的方法，循环中创建Java对象。这样会导致系统不断的为变量分配释放空间。</p>
<p>6、缓存经常使用的对象：如果有些对象需要被经常使用，那么可以考虑将这些对象用缓冲池保存起来，典型的缓存就是数据连接池。  </p>
<p>PS：缓存的设计本身就是一种牺牲系统空间来换取运行时间的方式。如何控制缓存容器占用的内存空间不至于太大，同时又能保存大部分需要使用到的对象，这是缓存的设计的关键。</p>
<p>7、尽量不要使用finalize方法</p>
<p>8、考虑使用softReference，但是要注意软引用的不确定性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引用对象有4个级别，其由高到低一次为：强引用、软引用、弱引用和虚引用。在需要严格考虑系统资源的情况下，还是需要考虑到这个系统的消耗的，这个时候就不能一味的使用强类型引用了。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE-SSH框架整合（Spring5.04+Struts2.5.16+Hibernate5.3）]]></title>
      <url>/2018/04/24/2018-4-25-114413/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是通过一个简单的注册登录来说明SSH框架的整合过程。在项目中，可以使用注解或者是XML的方式来配置依赖。</p>
<p>首先时Struts2和Spring和整合。</p>
<h1 id="导入的Jar包"><a href="#导入的Jar包" class="headerlink" title="导入的Jar包"></a>导入的Jar包</h1><h2 id="Struts2基本Jar包"><a href="#Struts2基本Jar包" class="headerlink" title="Struts2基本Jar包"></a>Struts2基本Jar包</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424061215929.png" alt=""></p>
<h2 id="Spring基本Jar包"><a href="#Spring基本Jar包" class="headerlink" title="Spring基本Jar包"></a>Spring基本Jar包</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424061255398.png" alt=""></p>
<h2 id="Hibernate基本Jar包"><a href="#Hibernate基本Jar包" class="headerlink" title="Hibernate基本Jar包"></a>Hibernate基本Jar包</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424061327015.png" alt=""></p>
<h2 id="Spring-Struts2整合需要的Jar包"><a href="#Spring-Struts2整合需要的Jar包" class="headerlink" title="Spring+Struts2整合需要的Jar包"></a>Spring+Struts2整合需要的Jar包</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424061407119.png" alt=""><br>PS：此Jar的位置在Struts的lib文件夹内。</p>
<h2 id="Spring-HIbernate整合需要的Jar包"><a href="#Spring-HIbernate整合需要的Jar包" class="headerlink" title="Spring+HIbernate整合需要的Jar包"></a>Spring+HIbernate整合需要的Jar包</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424061619096.png" alt=""></p>
<p>PS:此jar包在Spring的lib文件夹中。</p>
<h1 id="Spring整合Web项目"><a href="#Spring整合Web项目" class="headerlink" title="Spring整合Web项目"></a>Spring整合Web项目</h1><p>首先明确一个概念，现在我们学习的单个Spring，它是需要在代码中手动的进行启动，不能说web项目一启动就能够把Spring容器加载进来。在使用单个的Spring框架的时候，一般是采用的以下的方式来进行加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationConfig.xml&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这样的加载方式，无论怎样，都是需要时间的，需要时间就导致效率受到影响，这个时候一个比较折中的解决方案是把这个加载过程丢给服务器，就算服务器启动的时候任务多一点也没关系。</p>
<p>所以将这个过程丢给服务器。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>1、在服务器启动的时候，会为每一个项目创建一个<strong>ServletContext</strong>对象。</p>
<p>2、<strong>ServletContextListener</strong>监听器可以监听Web应用的启动和关闭。（此处说一下：监听Web事件的监听器，比如说到的<strong>ServletContextListener</strong>，还有<strong>HttpSessionListener</strong>等等，都是需要在<strong>web.xml</strong>进行配置的（使用xml不是唯一的方式，你也可以使用注解<strong>@WebListener</strong>在监听器接口时间的类上面））</p>
<p>3、监听到Web应用启动的时候就让它加载Spring容器。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>在Spring中可以通过<strong>ServletContextListener</strong>监听器，<strong>ServletContextListener</strong>监听器可以再Web应用启动的时候自动回调方法。</p>
<p>在Spring容器中有一个监听器类：<strong>ContextLoaderListener</strong>，该监听器类实现了<strong>ServletContextListener</strong>接口：<br><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424060513437.png" alt=""><br>该类可以作为<strong>Listener</strong>使用，在创建的时候自动加载在WEB——INF下面自动加载<strong>applicationConfig.xml</strong>文件，如果有多个配置文件需要加入(或者<strong>applicationConfig.xml</strong>文件在src目录下)，使用<strong>context-param</strong>标签来设置<strong>name</strong> 和<strong>value</strong>。其中name值为<strong>contextConfigLocation</strong>（这个值的位置在<strong>ContextLoaderListener</strong>的父类中有定义（截图如下）：）。<br><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180424060744311.png" alt=""><br>所以在web.xml中的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">       &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">       &lt;param-value&gt;classpath:applicationConfig.xml&lt;/param-value&gt;</span><br><span class="line"> &lt;/context-param&gt;</span><br><span class="line">   &lt;listener&gt;</span><br><span class="line">       &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">   &lt;/listener&gt;</span><br></pre></td></tr></table></figure>
<p>到此，Web应用启动的时候就会自动加载Spring容器。</p>
<h1 id="Struts2-Spring整合"><a href="#Struts2-Spring整合" class="headerlink" title="Struts2+Spring整合"></a>Struts2+Spring整合</h1><p>当然，使用Struts2，得首先掏出一个很关键的拦截器<strong>StrutsPrepareAndExecuteFilter</strong>拦截掉用户的所有请求。具体的配置当然是在web.xml中。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareA迟早dExecuteFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来是要创建做一个<strong>Action</strong>来接收用户的请求。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class LoginAndRegistAction extends ActionSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line">    private User user;</span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 处理登录</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String login() &#123;</span><br><span class="line">        System.out.println(&quot;In Action:&quot; + user.toString());</span><br><span class="line">        return userService.loginService(user)==true?SUCCESS:ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 处理注册</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String regist() &#123;</span><br><span class="line">        System.out.println(&quot;In Action:&quot; + user.toString());</span><br><span class="line">        return userService.registService(user)==true?SUCCESS:ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里顺带提一笔，在使用的时候都是<strong>面向接口</strong>的开发，即开发接口的实现类，这样能够达到一种<strong>高内聚低耦合</strong>，这样的设计能够更加的抽象，也更加的面向对象。关于面向接口的编程的一些具体原因请参看其他资料。</p>
<p>当然接下来还需要做的一件事就是修改<strong>struts.xml</strong>文件，我们需要在这个文件中配置逻辑视图和物理视图的相互连接关系。</p>
<p>贴下代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE struts PUBLIC</span><br><span class="line">        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;</span><br><span class="line">        &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&gt;</span><br><span class="line">&lt;struts&gt;</span><br><span class="line">    &lt;package name=&quot;myLogin&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot; strict-method-invocation=&quot;false&quot;&gt;</span><br><span class="line">        &lt;action name=&quot;Login_*&quot; class=&quot;userAction&quot; method=&quot;&#123;1&#125;&quot;&gt;</span><br><span class="line">            &lt;result name=&quot;success&quot;&gt;success.jsp&lt;/result&gt;</span><br><span class="line">            &lt;result name=&quot;error&quot;&gt;error.jsp&lt;/result&gt;</span><br><span class="line">        &lt;/action&gt;</span><br><span class="line">    &lt;/package&gt;</span><br><span class="line">&lt;/struts&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于本项目是实现了登录和注册的（其实在Dao层以前的东西都差不多，大可以当作同一个东西来看）。</p>
<p>虽然只是一个简单的登录注册，但也是麻雀虽小五脏俱全，使用了SSH框架，又进行了分层开发（Controller、Repository、Service），又是面向接口的程序设计。  </p>
<p>这里还要提一点的就是，注意到<strong>上面的action标签的class属性，这个属性的值为Spring的配置文件中action的bean的id</strong>。为什么要这么做，我们可以将所有的实体的创建全部交给spring帮助我们进行管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userAction&quot; class=&quot;com.dimple.action.LoginAndRegistAction&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意了：Action是多例的，这就是说，每当用户请求一次这个Action，那么这个Action就会创建一个实例。对比Servlet，这是一个单例，即在Web应用的整个生命周期中都只会创建一次。在Spring中，通过scope属性能够设置该bean是多实例（prototype）的还是单实例的(sington)。</p>
<p>这里还是顺手插一脚：<br>可能你会在项目中遇到这样的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardContext.listenerStart Exception sending context initialized event to listener instance of class [org.springframework.web.context.ContextLoaderListener]</span><br></pre></td></tr></table></figure>
<p>网上的解释：什么xml配置错误啊，什么applicationConfig配置错误啊，确实，可能会是这些问题，但都没一个提到是因为mysql没开启的吗？然后一群人跟风在那里说嗯，对，然后看到的博文都是一模一样···</p>
<p>解决方式很简单：如果你在仔细检查了xml文件，applicationConfig文件没有问题，其他地方也没有问题的时候，请看看数据库是不是处于启动的状态。如果没有启动，请手动开启(CMD )：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p>关于mysql的环境变量还是需要配置好的。当然你可以cd进bin开启。</p>
<h1 id="Spring-HIbernate整合"><a href="#Spring-HIbernate整合" class="headerlink" title="Spring+HIbernate整合"></a>Spring+HIbernate整合</h1><p>前面说了那么多，接下来的工作就很简单了。</p>
<p>导JAR包的过程省略，在文章开头已经说明了需要哪些JAR包。</p>
<h2 id="回忆Hibernate相关知识点"><a href="#回忆Hibernate相关知识点" class="headerlink" title="回忆Hibernate相关知识点"></a>回忆Hibernate相关知识点</h2><p>HIbernate是对象关系映射的模式（ORM），使用Hibenate框架可以通过直接操作实体类的属性来操作数据库的字段。  </p>
<p>首先回忆下单独使用Hibernate框架的时候的操作步骤：</p>
<p>1、创建实体类，这个实体类对应到数据库的表单。<br>2、创建了实体类，就需要配置实体类和数据库表单的映射关系。一般文件命名为：实体类名称.hbm.xml。在这个文件中，需要将实体类的属性和数据库表单的字段对应起来。当然还有设置什么主键映射策略的等等。<br>3、最后还有一个核心配置文件，一般命名为：hibernate.cfg.xml。在这个文件中，主要用来配置数据库的连接信息，配置hibernate，最后是把映射文件给包含进来。  </p>
<p>再来回忆下使用Hibernate的步骤：</p>
<p>1、首先需要加载配置文件文件，主要是通过Configuration这个类来实现的。代码贴在下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration configure = new Configuration().configure(&quot;hibernate.cfg.xml&quot;);</span><br></pre></td></tr></table></figure></p>
<p>2、通过Configuration对象，获取到SessionFactory对象。SessionFactory是线程安全的类，一般来说，在一个数据库表单中，只有一个SessionFactory对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sessionFactory = configure.buildSessionFactory();</span><br></pre></td></tr></table></figure></p>
<p>3、最终进行CRUD操作的是Session对象，Session是线程不安全的。所以在使用完了之后应该尽快关闭资源，一般是在Finally语句块中进行关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br></pre></td></tr></table></figure></p>
<p>4、为了保证数据的安全性，一般还是会使用事务来包裹着这个session操作。所以还需要开启事务，开启事务就要涉及到出现异常回滚(rollback)，最后还是需要提交事务(commit)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transaction transaction = session.beginTransaction();</span><br></pre></td></tr></table></figure></p>
<p>5、对数据进行CRUD操作，这里还涉及到实体类的三种状态（瞬时态、持久态、托管态）。当然hibernate还有一对多，多对多等的映射关系。还有为了增加hibernate的并发，会在一定数量后的操作之后，手动提交保存，然后刷新缓冲区等等。</p>
<p>OK，上面只是简单的思维发散了一下：接下来进入正题。</p>
<h2 id="Spring-Hibernate整合的步骤"><a href="#Spring-Hibernate整合的步骤" class="headerlink" title="Spring+Hibernate整合的步骤"></a>Spring+Hibernate整合的步骤</h2><p>当然，实体类还是要创建，映射文件信息还是要写（一般来说映射文件和实体类在一起）。</p>
<p>我们要做的，是将SessionFactory的创建来交给Spring进行管理。如果之前有进行过Hibernate的开发会发现，当使用数据库的时候，第一次访问会有点耗时，通过Spring配置管理可以解决这个问题。</p>
<p>1、去掉Hibernate核心配置文件中的数据库连接信息，然后交给Spring，在Spring的配置文件中进行以下配置（主要是配置连接池，一般来说有C3P0，当然也可以使用Spring提供的）。使用IDEA双击Shift就可以搜索到DriverManagerDataSource。然后复制类路径。在DriverManagerDataSource的父类可以看到是存在着name、password、url、driver等的set方法，可以使用Spring的属性注入：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180425113015735.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot; id=&quot;dataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>2、把SessionFactory交给Spring。在这里，可以看到将Hibenate.cfg.xml的三部分中的后两部分都已经在SessionFactory中记性了配置。（三部分分别为：数据库配置部分，Hibenate配置部分，映射文件配置部分），同样的，Spring是已经封装了SessionFactory的，可以通过搜索获取到LocalSessionFactoryBean的全路径。在这个源码里面可以看见，是存在dataSource的set方法的，这样就可以属性注入。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180425112754274.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置SessionFactory--&gt;</span><br><span class="line">   &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;hibernateProperties&quot;&gt;</span><br><span class="line">           &lt;props&gt;</span><br><span class="line">               &lt;prop key=&quot;show_sql&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">               &lt;prop key=&quot;format_sql&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">               &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;</span><br><span class="line">           &lt;/props&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">       &lt;property name=&quot;mappingResources&quot;&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;value&gt;com/dimple/entity/User.hbm.xml&lt;/value&gt;</span><br><span class="line">           &lt;/list&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>3、在Dao层使用HibernateTemplate。Spring是封装了HIbernate的CRUD操作的，通过HibernateTemplate就可以操作数据。<br>在Spring的配置文件中，还需要配置bean。还需要在HibernateTemplate中注入一个SessionFactory。同样也是可以通过查看源码看到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置HibernateTemplate--&gt;</span><br><span class="line">&lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>4、在Spring中进行操作还是需要事务的支持，如果没有事务会报错。所以接下来为Dao层配置事务。在Spring中，配置事务有两种方式，一种是通过XML配置AOP，还有一种是声明式。接下来采用声明式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置事务管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;hibernateTransactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置事务注解--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;hibernateTransactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>到此，SSH框架的整合已经完成。还是贴图说明下：<br><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180425113950454.png" alt=""></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/JavaEE-SSH框架整合（Spring）/20180425114001880.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在写这个Web项目的时候，之前只是听说了有面向接口编程的这样一种说法，并没有实际操作过。Java本身也是一个不断完善的语言，它也在频繁的改动它的系统API来完善，它的API是一个庞大的体系，互相关联，如果不采用接口，而都是用实现类的话，那么API的改动就会给整个体系带来不稳定。</p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Struts2 拦截器]]></title>
      <url>/2018/03/31/2018-3-31-210627/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Struts2 </tag>
            
            <tag> 拦截器 </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb获取表单数据的三种方式（属性封装，表达式封装，模型驱动封装）]]></title>
      <url>/2018/03/31/2018-3-31-194919/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在JavaWeb中，常常会遇到用户注册、提交表单数据等等，这个时候使用Struts2框架怎么获取页面的数据呢？传统的有通过域对象的方法来挨个使用getParameter方法来获取表单数据再进行操作（比如封装到一个JavaBean等等），本文主要使用Struts2框架来获取表单数据。</p>
<p>在首先会通过最传统的方法通过Servlet来获取表单数据，接着会介绍三种获取表单数据的方式，最后会对这几种方式来进行比较。</p>
<p>本文各类环境如下：  </p>
<p>Struts2版本：struts-2.5.16-all<br>IDE：Intellij IDEA 2018.1    </p>
<p>此外关于添加Struts2 jar包不再叙述。</p>
<h1 id="Servlet域对象获取表单数据"><a href="#Servlet域对象获取表单数据" class="headerlink" title="Servlet域对象获取表单数据"></a>Servlet域对象获取表单数据</h1><p>此处使用的是最原始的方式获取表单数据，主要是操作request域来获取数据的。</p>
<h2 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h2><ul>
<li>编写一个JavaBean（User），属性值为username、password。</li>
<li>新建一个JSP页面。</li>
<li>在action中通过ServletActionContext来获取request对象，通过request的getParameter方法来获取数据。 </li>
<li>将属性值封装到JavaBean中。  </li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>1、编写JavaBean  User<br>新建一个包：com.dimple.entity,然后新建一个Class，名为User。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    /**</span><br><span class="line">    * 省略部分get和set方法。</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、新建一个JSP页面，名为login<br>导入标签库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;</span><br></pre></td></tr></table></figure></p>
<p>新建一个form表单，body内容如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;s:form label=&quot;登陆&quot; action=&quot;login&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            账号：</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            密码：</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td colspan=&quot;2&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/s:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>3、新建一个包名为：com.dimple.actin，新建一个LoginAction类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LoginAction extends ActionSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() throws Exception &#123;</span><br><span class="line">        //获取Request对象</span><br><span class="line">        HttpServletRequest request = ServletActionContext.getRequest();</span><br><span class="line">        //获取表单属性</span><br><span class="line">        String password = request.getParameter(&quot;password&quot;);</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        //将表单数据封装到JavaBean中</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        //输出获取到的内容</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        return NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、配置struts.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;struts&gt;</span><br><span class="line">    &lt;package name=&quot;login&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;</span><br><span class="line">        &lt;action name=&quot;login&quot; class=&quot;com.dimple.action.LoginAction&quot;&gt;</span><br><span class="line">            &lt;!--因为设置的返回值为none，所以不需要配置result标签--&gt;</span><br><span class="line">        &lt;/action&gt;</span><br><span class="line">    &lt;/package&gt;</span><br><span class="line">&lt;/struts&gt;</span><br></pre></td></tr></table></figure></p>
<p>PS:别忘了还有web.xml的filter标签哦。 </p>
<p>结果如下：<br>输入账号密码后：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331202250.png" alt="QQ截图20180331202250"></p>
<p>output页面显示：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331202307.png" alt="QQ截图20180331202307">  </p>
<h1 id="属性封装"><a href="#属性封装" class="headerlink" title="属性封装"></a>属性封装</h1><p>属性封装是一种比原始方式好一点的一种做法，但是在实际工作中的使用和原始方式一样，用的不是特别多。是一种直接将表单属性封装到action属性的一种方法。  </p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>在action类中定义属性变量（注意：必须和jsp页面的属性值保持一致）  </li>
<li>生成get和set方法  </li>
</ul>
<h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>PS:直接在上一个示例上修改。  </p>
<p>修改loginAction代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LoginAction extends ActionSupport &#123;</span><br><span class="line">    //定义变量</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    //生成对应的get和set方法</span><br><span class="line">/**</span><br><span class="line">* 省略get和set方法</span><br><span class="line">*/</span><br><span class="line">    @Override</span><br><span class="line">    public String execute() throws Exception &#123;</span><br><span class="line">        //将变量值封装到对象中</span><br><span class="line">        User user=new User();</span><br><span class="line">        user.setUsername(getUsername());</span><br><span class="line">        user.setPassword(getPassword());</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        return NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331203115.png" alt="QQ截图20180331203115">  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331203100.png" alt="QQ截图20180331203100">  </p>
<h2 id="框架实现原理分析"><a href="#框架实现原理分析" class="headerlink" title="框架实现原理分析"></a>框架实现原理分析</h2><p>只能是最简单的白话文的分析：<br>在action类中通过request域对象来获取变量名称和值，然后与action类中的成员变量名称进行比对，如果属性名一样，那么就调用set方法将值写入。  </p>
<h1 id="模型驱动封装"><a href="#模型驱动封装" class="headerlink" title="模型驱动封装"></a>模型驱动封装</h1><p>模型驱动封装是要实现Model Driven接口。  </p>
<h2 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>让action类继承Model Driven接口</li>
<li>实现接口中的方法getModel();</li>
<li>在action中创建JavaBean类对象</li>
</ul>
<h2 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h2><p>action中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LoginAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123;</span><br><span class="line">    //创建实体类对象</span><br><span class="line">    User user=new User();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() throws Exception &#123;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        return NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    //实现接口中的方法，返回user</span><br><span class="line">    @Override</span><br><span class="line">    public User getModel() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现截图"><a href="#实现截图" class="headerlink" title="实现截图"></a>实现截图</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331204004.png" alt="QQ截图20180331204004"><br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331203952.png" alt="QQ截图20180331203952">  </p>
<h1 id="表达式封装"><a href="#表达式封装" class="headerlink" title="表达式封装"></a>表达式封装</h1><p>表达式封装是用的比较多的，具体的原因后面的比较会说到。  </p>
<h2 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>在action类中声明JavaBean【注意只是声明，没有实现】</li>
<li>生成实体类的get和set方法</li>
<li>在JSP页面的form表单中使用表达式形式</li>
</ul>
<h2 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h2><p>action类代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LoginAction extends ActionSupport  &#123;</span><br><span class="line">    //只是声明并不实现</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() throws Exception &#123;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        return NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Jsp页面中的body部分(注意和前面的进行比较)：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:form label=&quot;登陆&quot; action=&quot;login&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            账号：</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;user.username&quot;/&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            密码：</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;user.password&quot;/&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td colspan=&quot;2&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/s:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="实现截图-1"><a href="#实现截图-1" class="headerlink" title="实现截图"></a>实现截图</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331204604.png" alt="QQ截图20180331204604"></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180331204556.png" alt="QQ截图20180331204556"></p>
<h1 id="模型封装和表达式封装比较"><a href="#模型封装和表达式封装比较" class="headerlink" title="模型封装和表达式封装比较"></a>模型封装和表达式封装比较</h1><p>共同点：这两种方式都能够将数据直接封装到实体类中去。  </p>
<p>不同点： </p>
<ul>
<li>使用模型驱动封装的方式，由于在实现接口的时候，就指明了泛型为user，这样就只能够将数据封装到一个实体类中。</li>
<li>使用表达式封装，在JSP页面就已经设置了该数据传入的对象，所以是可以将数据封装到多个实体类中的，只不过是在action方法中再多生成几个get和set方法而已。  </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>获取表单数据，这样就能与用户进行数据交互。同时，表达式封装还可以封装List、Map等等。其实方法都一样，生成对应的额get和set方法，区别主要是在JSP页面中的写法，比如封装到List中，那么JSp页面可能就要这样写了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;list[0].password&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>同理，封装到Map呢？map是键值对的结构，那么肯定是不能按照list（类似于数组）的方式来。通过使用键来获得值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;map[&apos;key&apos;].password&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Struts2 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> 属性封装，表达式封装，模型驱动封装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE Async 异步支持]]></title>
      <url>/2018/03/26/2018-3-26-193844/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p> Async技术是Servlet3.0 之后添加的，用于处理异步请求。在此之前，大多为同步请求，客户端向服务器提交请求，假设请求很耗时，那么按照之前同步的处理办法，servlet在接收到这个请求之后，会调用去处理这个耗时操作，如果这个耗时操作长时间没有返回，那么就造成了服务器的阻塞，服务器资源得不到有效利用，这样的结果显然对于服务器的高并发是非常不利的。<br> 服务器可以异步执行，在等待长时间的过程完成期间，控制容器执行其他任务，当耗时操作完成返回后，再调用资源处理这个返回请求。   </p>
</blockquote>
<h1 id="使用Async的步骤"><a href="#使用Async的步骤" class="headerlink" title="使用Async的步骤"></a>使用Async的步骤</h1><h2 id="启用async"><a href="#启用async" class="headerlink" title="启用async"></a>启用async</h2><p>异步行为需要在Servlet中显式启用 ，其方法有两种：  </p>
<ul>
<li>添加@WebServlet的<strong>asyncSupported</strong>属性实现  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span><br></pre></td></tr></table></figure>
<ul>
<li>在<strong>web.xml</strong>文件中实现  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;AsyncServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.dimple.servlet.AsyncServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;!--设置启用Async--&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<h2 id="在Servlet中开启async"><a href="#在Servlet中开启async" class="headerlink" title="在Servlet中开启async"></a>在Servlet中开启async</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name = &quot;AsyncServlet&quot;, urlPatterns = &quot;/async&quot;,asyncSupported = true)</span><br><span class="line">public class AsyncServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        //输出Servlet开始的时候的系统时间</span><br><span class="line">        out.println(&quot;Servlet is starting：&quot;+new Date());</span><br><span class="line">        //创建AsyncContext，开始异步调用</span><br><span class="line">        AsyncContext asyncContext=request.startAsync();</span><br><span class="line">        //设置超时时长,单位为毫秒</span><br><span class="line">        asyncContext.setTimeout(60*1000);</span><br><span class="line">        //启动异步调用的线程</span><br><span class="line">        asyncContext.start(new MyTask(asyncContext));</span><br><span class="line">        //输出Servlet结束的时间</span><br><span class="line">        out.println(&quot;Servlet is ending ：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyTask内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyTask implements Runnable &#123;</span><br><span class="line">    AsyncContext context;</span><br><span class="line"></span><br><span class="line">    public MyTask(AsyncContext context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 此处单开一个线程进行耗时操作，为了模拟耗时操作，这里先让线程Sleep5秒。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5*1000);</span><br><span class="line">            context.getResponse().getWriter().print(&quot;async is ending : &quot;+new Date());</span><br><span class="line">        &#125; catch (InterruptedException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果如下：</strong></p>
<p><img src="https://img-blog.csdn.net/20180326183601303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDU0NTM3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述">  </p>
<p>注意：这是采用IDEA开发的，可能采用Eclipse的小伙伴的开发的和我这边的url不一样。  </p>
<h1 id="AsyncListener-异步监听器"><a href="#AsyncListener-异步监听器" class="headerlink" title="AsyncListener 异步监听器"></a>AsyncListener 异步监听器</h1><p>为了更加清晰的看到异步操作的各种细节，可以借助异步监听器实现。<br>异步监听器需要实现AsyncListener接口，该接口需要实现如下方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onComplete(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">    //当异步调用完成后被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onTimeout(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">    //超时被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onError(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">    //出现错误的时候被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onStartAsync(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">    //启动Async的时候被调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加监听器的方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncContext.addListener(new MyAsyncListener);</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用Servlet3.0的Async异步支持，步骤总结如下：    </p>
<ul>
<li>首先先声明异步支持（web.xml或者注解@webServlet）  </li>
<li>在相应的Servlet中获取AsyncContext实例。一般采用<code>request.startAsync();</code>该方法发挥一个AsyncContext对象。  </li>
<li>设置超时<code>context.setTimeout();</code>    </li>
<li>启动线程<code>context.start(Runable runable);</code></li>
<li>在相应的实现Runable接口的方法里进行耗时操作。  </li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Async </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE之Session理解]]></title>
      <url>/2018/03/26/2018-3-26-193523/</url>
      <content type="html"><![CDATA[<h1 id="Session应用场景"><a href="#Session应用场景" class="headerlink" title="Session应用场景"></a>Session应用场景</h1><blockquote>
<p>在互联网生活中，通常大家在使用浏览器的时候会接触到session。由于HTTP的无状态性，也就是说，当打开浏览器输入<a href="http://www.bianxiaofeng.com">http://www.bianxiaofeng.com</a> 网址，然后该请求会被服务器处理后，返回所请求的网页的内容，至此，整个Request/Response过程已经完全结束了。当你接下来访问网站的时候，网站服务器端是不认识你的。这就是无状态性。为了解决这个问题（比如在某个需要输入密码的网页登录，不能说每一次打开该网站的新的网页就要输入一次密码。对吧？）。此时session的作用就体现出来了。简单的说。就是让服务器知道你就是你。  </p>
</blockquote>
<h1 id="面对无状态性的解决方案"><a href="#面对无状态性的解决方案" class="headerlink" title="面对无状态性的解决方案"></a>面对无状态性的解决方案</h1><p>Java Servlet 通过引入session机制来跟踪客户端的状态。当用户访问网站的时候，网站会分配给该客户端一个sessionID用于标识该客户端，至此，在接下来的一段时间内，用户可以请求不同的服务器资源。当网页被关闭的时候，服务器会释放掉这个ID。比如在线购物的过程，浏览物品，到添加购物车到付款完成关闭页面这整个过程就是一个session。</p>
<h1 id="Session的使用"><a href="#Session的使用" class="headerlink" title="Session的使用"></a>Session的使用</h1><p>session的使用方式很多，常见的方式是使用jsp和servlet。  </p>
<p>jsp的9大内置对象中就有session，所以在jsp页面可以直接使用。在servlet中，需要构建出session实例，然后才能使用。构建方式有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session=request.getSession();</span><br><span class="line">HttpSession session=request.getSession(Boolean b);</span><br><span class="line">//参数为true：若会话存在就返回该对话，如果不存在就创建一个对话；</span><br><span class="line">//参数为false：若会话存在就返回该对话，如果不存在就返回null</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session.isNew();//返回值为Boolean，判断是不是新创建的session</span><br><span class="line">session.setAttribute(String s,Object o);//在session范围内保存对象</span><br><span class="line">session.getAttribute(String s);//获取在session范围内保存的对象，一般涉及到cast强转</span><br><span class="line">session.removeAttribute(String s);//去除session范围内的键为s的对象</span><br><span class="line">session.getId();//返回sessionID，返回值为String</span><br><span class="line">session.invalidate();//使session立即失效，包括保存在session范围内的对象</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Session将信息保存在服务器端，而cookie保存在客户端，session比cookie安全，但是session更加占用资源。如果客户端禁用了cookie，那么服务器端的session也无法使用。这种问题的解决方案是重写url。</p>
]]></content>
      
        <categories>
            
            <category> JavaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Error:Execution failed for task ':app:transformDexArchiveWithExternalLibsDexMergerForDebug'的解决办法]]></title>
      <url>/2018/03/20/2018-3-20-153425/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Android的开源环境下，也就多出来很多优秀的第三方的项目，但是因为很多第三方的项目和目前你正在开发的APP使用的Lib有些是重复的，这样会导致<strong>transformClassesWithDexForDebug</strong>  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/20180320154257.png" alt="20180320154257">  </p>
<p>本文介绍年两种方法来处理这个问题。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="添加“multiDexEnabled-true”到-defaultConfig"><a href="#添加“multiDexEnabled-true”到-defaultConfig" class="headerlink" title="添加“multiDexEnabled true”到 defaultConfig"></a>添加“multiDexEnabled true”到 defaultConfig</h2><p>在app的build.gradle文件中的 defaultConfig添加：  </p>
<p><code>multiDexEnabled true</code><br>如图所示：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320154214.png" alt="QQ截图20180320154214"></p>
<p>这样的设置只能解决一部分的问题，而更加难受的情况是在项目中引入了很多的第三方库，这个时候鬼知道哪个库出了问题，一个一个试可能能够找出来，但是找出来黄花菜都凉了。  </p>
<p>这个时候请移步解决方法二  </p>
<h2 id="根据Message信息找到重复的包"><a href="#根据Message信息找到重复的包" class="headerlink" title="根据Message信息找到重复的包"></a>根据Message信息找到重复的包</h2><p>在Setting-&gt;Build,Execution,Deployment-&gt;Compiler中的Command-line Opptions中输入<strong>–stacktrace</strong>启用堆栈跟踪  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320155125.png" alt="QQ截图20180320155125"></p>
<p> 接着运行APP，就能够在Message上面输出：  </p>
<p> <img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320155325.png" alt="QQ截图20180320155325">  </p>
<p> 这样我根据上面消息找到了butterknife重复包。  </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt实现串口通信控制51单片机（上下位机）]]></title>
      <url>/2018/03/09/2018-3-9-165439/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Qt是我在大一下学期开始接触的，当时刚学完C++，然后每天对着黑漆漆的console窗口，在偶然的机会接触到Qt这个跨平台的C++应用程序开发框架。又在老师的怂恿下（单片机老师说如果做出上下位机实验成绩就是满分），使用Qt来进行上下位机的开发。当然实现的功能很简单，控制LED灯的明灭，输入数字显示在数码管上，控制继电器和蜂鸣器以及定时器。</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>首先是界面截图 </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917547.png" alt="{mdFileName}-20183917547"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917553.png" alt="{mdFileName}-20183917553"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917556.png" alt="{mdFileName}-20183917556"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917559.png" alt="{mdFileName}-20183917559"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018391762.png" alt="{mdFileName}-2018391762"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018391765.png" alt="{mdFileName}-2018391765"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018391767.png" alt="{mdFileName}-2018391767">  </p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>其实实现的原理很简单，Qt已经是封装好了串口通信的 QSerialPort类，我们只需要设置好串口通信的相关属性（波特率、数据位、奇偶校验位等等），然后调用 QSerialPort的write方法发送命令到下位机就行。当然了，还需要相应的编写下位机的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_openButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    if(ui-&gt;openButton-&gt;text()==tr(&quot;打开串口&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        serial = new QSerialPort;</span><br><span class="line">        //设置串口名</span><br><span class="line">        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());</span><br><span class="line">        //打开串口</span><br><span class="line">        serial-&gt;open(QIODevice::ReadWrite);</span><br><span class="line">        //设置波特率</span><br><span class="line">        serial-&gt;setBaudRate(ui-&gt;BaudBox-&gt;currentText().toInt());</span><br><span class="line">        //设置数据位数</span><br><span class="line">        switch(ui-&gt;BitNumBox-&gt;currentIndex())</span><br><span class="line">        &#123;</span><br><span class="line">         case 8: serial-&gt;setDataBits(QSerialPort::Data8); break;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置奇偶校验</span><br><span class="line">        switch(ui-&gt;ParityBox-&gt;currentIndex())</span><br><span class="line">        &#123;</span><br><span class="line">        case 0: serial-&gt;setParity(QSerialPort::NoParity); break;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置停止位</span><br><span class="line">        switch(ui-&gt;StopBox-&gt;currentIndex())</span><br><span class="line">        &#123;</span><br><span class="line">             case 1: serial-&gt;setStopBits(QSerialPort::OneStop); break;</span><br><span class="line">            case 2: serial-&gt;setStopBits(QSerialPort::TwoStop); break;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置流控制</span><br><span class="line">        serial-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line"></span><br><span class="line">        //关闭设置菜单使能</span><br><span class="line">        ui-&gt;PortBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;BaudBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;BitNumBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;ParityBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;StopBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;openButton-&gt;setText(tr(&quot;关闭串口&quot;));</span><br><span class="line"></span><br><span class="line">        //连接信号槽</span><br><span class="line">        QObject::connect(serial, &amp;QSerialPort::readyRead, this, &amp;MainWindow::Read_Data);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //关闭串口</span><br><span class="line">        serial-&gt;clear();</span><br><span class="line">        serial-&gt;close();</span><br><span class="line">        serial-&gt;deleteLater();</span><br><span class="line"></span><br><span class="line">        //恢复设置使能</span><br><span class="line">        ui-&gt;PortBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;BaudBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;BitNumBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;ParityBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;StopBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;openButton-&gt;setText(tr(&quot;打开串口&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关代码上传至百度云：<br>链接：<a href="https://pan.baidu.com/s/1fCpx_fFD9qsZVWKf89QkXg" target="_blank" rel="noopener">https://pan.baidu.com/s/1fCpx_fFD9qsZVWKf89QkXg</a> 密码：0oqe</p>
]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 串口通信 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见排序算法总结（冒泡排序、快速排序、选择排序、插入排序）——Java语言（一）]]></title>
      <url>/2018/03/09/2018-3-9-135602/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排序算法是最基本的算法之一，为此衍生出很多种的排序算法，而不同的排序算法具有不同的使用环境，为此掌握几种常见的排序算法是作为一个精致的程序员必不可少的技能。本文主要是介绍常见的四种排序算法的思想以及Java实现。 </p>
<p>2018年9月13日11:27:56更新：</p>
<p>更新内容：</p>
<pre><code>* 重置原有算法，按照一种更加容易理解的白话文说明各种算法的特点。
* 增加时间复杂度概念，分析时间复杂度。
</code></pre><p>序列文章：</p>
<ul>
<li><p><a href="http://www.bianxiaofeng.com/2018/03/09/2018-3-9-135602/">常见排序算法总结（冒泡排序、快速排序、选择排序、插入排序）——Java语言（一）</a></p>
</li>
<li><p>常见排序算法总结（归并排序）——Java语言（二）</p>
</li>
</ul>
<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><blockquote>
<p>冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 ——来源<a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a></p>
</blockquote>
<h3 id="冒泡排序算法核心思想"><a href="#冒泡排序算法核心思想" class="headerlink" title="冒泡排序算法核心思想"></a>冒泡排序算法核心思想</h3><p>假如有n个无序的数需要从小到大进行排序，那么使用冒泡排序一定是这样做的：</p>
<ul>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一（即为0和1比较，1和2比较，n-2和n-1比较）。这步做完后，最后的元素会是最大的数。</p>
</li>
<li><p>针对下标为 0-(n-2)重复以上的步骤。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  </p>
</li>
</ul>
<p>图示例：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183914350.gif" alt="{mdFileName}-20183914350">    </p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>比如对于8 4 9 2 5 这组无序序列来说：<br>算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 冒泡函数</span><br><span class="line">     *</span><br><span class="line">     * @param array 目标数组</span><br><span class="line">     */</span><br><span class="line">    public static void bubbleSort(int array[]) &#123;</span><br><span class="line">        //输入合法性校验，如果是空数组或者数组只有一个数，那么不需要排序，直接返回</span><br><span class="line">        if (array == null || array.length &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //外层循环控制需要排序的数列，从0到i</span><br><span class="line">        for (int i = array.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            //内层循环进行比较</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                if (array[j] &gt; array[j + 1]) &#123;</span><br><span class="line">                    swap(array, j, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交换函数</span><br><span class="line">     *</span><br><span class="line">     * @param array 目标数组</span><br><span class="line">     * @param i     交换的数组的下标</span><br><span class="line">     * @param j     交换的数组的下标</span><br><span class="line">     */</span><br><span class="line">    private static void swap(int[] array, int i, int j) &#123;</span><br><span class="line">        int temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此算法的执行思想是：</p>
<p>外层循环控制的是这个数组中需要排序的序列，第一趟之后，需要排序的序列的下标就是从0到n-2。而内层循环通过j和j+1进行比较，如果array[j]&gt;array[j+1]，那么就进行交换，通过array.length次的遍历，每一次都能将最大的排列到数组序列的最后一个，这样就能够完成排序。</p>
<p>当然，此类算法还有许多变形，比如下面：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">	for (int j = arr.length-1; j &gt;i ; j--) &#123;</span><br><span class="line">		if (arr[j]&gt;arr[j-1]) &#123;</span><br><span class="line">			int temp=arr[j];</span><br><span class="line">			arr[j]=arr[j-1];</span><br><span class="line">			arr[j-1]=temp;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法的思想是：从后向前进行比较,外层循环只是控制循环的次数，内层循环控制交换。这样一来，始终能保持在最前面的数是符合排序规则的。  </p>
<p>无论是怎样的变形，都是像吐泡泡一样，将符合条件的吐出来，然后没有吐出来的进行比较，直到找到合适的泡泡然后吐出来。  </p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度这个概念很复杂，是为一个算法流程中的，常数操作数量的指标。对于这样一个O(N)，是通过取极限的方式得到的，总的来说，忽略低阶项，忽略高阶项的系数项。</p>
<p>在常数操作数量的表达式中，只要高阶项，不要低阶项，不要高阶项的系数，剩下的部分即为f(N),那么时间复杂度为O(f(N))。</p>
<p>那么对于冒泡算法来说（ps：该算法基本已经绝迹，因为时间复杂度相对较高，消耗的系统资源较大），时间复杂度的计算方式如下：</p>
<p>对于这样一个算法流程来说，需要遍历的次数为：n+(n-1)+(n-2)+···2+1，这是一个等差数列，对于等差数列进行求和，得到的是：aN^2 +bN+c (a,b,c)为常数项。这里用到了数学的取极限的方法，这里的bN+c可以忽略，对于N很大来说，a对aN^2的影响不是特别大，可以忽略，在这里得到的时间复杂度为O(N^2)，读作（big o N^2)。</p>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。   ————来源<a href="https://zh.wikipedia.org/zh-cn/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a>  </p>
</blockquote>
<h3 id="实例介绍"><a href="#实例介绍" class="headerlink" title="实例介绍"></a>实例介绍</h3><p>图片动画演示   </p>
<p> <img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="图片来源——维基百科"><br>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。<br> 以上动画演示的是数组：a[]={8, 5, 2, 6, 9, 3, 1, 4, 0, 7};接下来会结合动画进行说明：  </p>
<ul>
<li>遍历数组a[0,n] (n为数组的长度)，找到里面最小的数0，放到最前面，数组变为：a[]={0,5,2,6,9,3,1,4,8,7};</li>
<li>遍历数组a[1,n]，找到最小的数1，放到数组下标为1的位置，数组变为a[]={0,1,2,6,9,3,5,4,8,7};</li>
</ul>
<p>重复以上步骤，最终数组变为：a[]={0,1,2,3,4,5,6,7,8,9}。  </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * @param array 目标数组</span><br><span class="line"> */</span><br><span class="line">public static void selectionSort(int[] array) &#123;</span><br><span class="line">    //数组输入参数合法性校验</span><br><span class="line">    if (array == null || array.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        for (int j = i + 1; j &lt; array.length; j++) &#123;</span><br><span class="line">            minIndex = array[j] &lt; array[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, minIndex, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 交换</span><br><span class="line"> * @param array 目标数组</span><br><span class="line"> * @param minIndex 当前找到的最小的数的下标</span><br><span class="line"> * @param i 要交换的数的下标</span><br><span class="line"> */</span><br><span class="line">private static void swap(int[] array, int minIndex, int i) &#123;</span><br><span class="line">    int temp = array[minIndex];</span><br><span class="line">    array[minIndex] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>可以看下上面的图示，可以看到，每次都会去遍历这样一个数组，遍历的次数为（n-1+(n-2)+····2+1。这还是一个等差数列，由于这个算法是写死的，什么意思呢，就是说这样一个算法，如果这是一个完全有序的数组，要进行排序，它还是会对每一个数都遍历一次，找到这个序列中最小的，放到合适的位置上去。与数组是否有序无关。</p>
<p>从上面的分析可以知道，这个时间复杂度还是一个等差数列，和上面的冒泡的分析一样，这里的时间复杂度为O(N^2)</p>
<h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h2><blockquote>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。快速排序采用“分而治之、各个击破”的观念。  ————来源<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a></p>
</blockquote>
<p>步骤为：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
<li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""> </li>
</ul>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>比如对于22， 5 ，85， 65 ，21 ，99 ，66这组无序序列来说。    </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201839164140.png" alt="{mdFileName}-201839164140">  </p>
<p>在本例子中，选取的是数组中的第一个22作为基准，采用分而治之的思想，将数组小于和大于基准的数分为两组，再采用递归的方法再进行排序，直到排序完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static void quick_sort(int[] a, int l, int r) &#123;</span><br><span class="line">	if (l &lt; r) &#123;</span><br><span class="line">		int i = l, j = r, x = a[l];</span><br><span class="line">		while (i &lt; j) &#123;</span><br><span class="line">			while (i &lt; j &amp;&amp; a[j] &gt;= x) &#123;//先从后面往前面找</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			if (i &lt; j) &#123;//如果找到比基准小的数，将这个比基准小的数放到之前的基准所在的位置去 </span><br><span class="line">				a[i] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			while (i &lt; j &amp;&amp; a[i] &lt; x) &#123;//再从前面往后面找</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (i &lt; j) &#123;//如果找到了比基准大的数，那么将这个比基本大的数放到上一个空出来的位置去</span><br><span class="line">				a[j] = a[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = x;</span><br><span class="line">		quick_sort(a, l, i - 1);//递归调用，对基准左边的数进行排序</span><br><span class="line">		quick_sort(a, i + 1, r);//对基本右边的数进行排序</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。  ————来源<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a>    </p>
</blockquote>
<h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><p>将一组数据分为两组，分别为有序组和无序组。每次从无序组中取出最前面的数和有序组的最后一个数进行比较，为这个数在有序组中找到一个合适的位置，这样始终保持着有序组中的数始终是有序的，直到遍历到最后一个。</p>
<p>想象下斗地主，摸牌的之前自己手中的牌是不是有序的，对吧，当你又摸起来了一张牌的时候，是不是要找它的合适位置，是不是就相当于要进行一次遍历，然后把牌插入到指定的位置。这就是插入排序。</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018310111715.gif" alt="{mdFileName}-2018310111715"><br>图片来源于网络</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 插入排序</span><br><span class="line">     *</span><br><span class="line">     * @param array 目标数组</span><br><span class="line">     */</span><br><span class="line">    public static void insertSort(int[] array) &#123;</span><br><span class="line">//        参数合法性校验</span><br><span class="line">        if (array == null || array.length &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //外层循环，控制的需要进行插入的数的位置</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            //内层循环，将当前这个数拿到有序祖列中进行遍历，找到它的合适位置</span><br><span class="line">            for (int j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + 1]; j--) &#123;</span><br><span class="line">                swap(array, j, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交换函数</span><br><span class="line">     *</span><br><span class="line">     * @param array 目标数组</span><br><span class="line">     * @param i     需要交换的下标位置</span><br><span class="line">     * @param j     需要交换的下标位置</span><br><span class="line">     */</span><br><span class="line">    private static void swap(int[] array, int i, int j) &#123;</span><br><span class="line">        int temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>四种最常见的排序算法的相关指标如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201831012532.png" alt="{mdFileName}-201831012532">   不同的算法具有很多种的变形，比如冒泡，可以从序列前面开始，也可以从后面开始，其原理都一样。</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android InterFilter 匹配]]></title>
      <url>/2018/03/08/2018-3-8-084846/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般来说，启动Activity的方法有两种，显式启动和隐式启动。对于显示启动来说，只需要实例化一个Intent对象，指明被启动对象的组件信息，包括包名以及类名。例如  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=new Intent(MainActivity.this,OtherActivity.class);</span><br></pre></td></tr></table></figure>
<p>原则上是单独的使用隐式启动和显式启动，如果两者并存的话，以显式启动为准。<br>隐式调用需要Intent能够匹配目标组件的IntentFilter设置的过滤信息，如果不匹配的话是不能正常的启动Activity。Intent中需要过滤的信息包括：action、category和data。  </p>
<h1 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h1><p>一个过滤列表中的action，category，data可以有多个，所有的action，category，data分别构成不同的类别。只要有一个Intent能够同时匹配action、category、data类别才能匹配成功。一个Activity可以有多个IntentFilter，只要成功的符合一组IntentFilter就可以启动相应的Activity。  </p>
<h2 id="action的匹配规则"><a href="#action的匹配规则" class="headerlink" title="action的匹配规则"></a>action的匹配规则</h2><p>action是一个字符串，系统定义了一些，同时也支持自定义此字符串。action<strong>严格区分大小写</strong>。  </p>
<p>一个过滤规则中可以有多个action，只要有一个action和intent匹配，就可以匹配成功。   </p>
<p><strong>IntentFilter必须存在，否则不能启动Activity。</strong>  </p>
<h2 id="category匹配规则"><a href="#category匹配规则" class="headerlink" title="category匹配规则"></a>category匹配规则</h2><p>category也是字符串，系统也有默认的字符串，和action匹配规则不同的是，在intent中可以不用特别指明category属性。  </p>
<p><strong>IntentFilter中必须要有</strong><code>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</code> 无论intent是否调用addCategory()方法。  </p>
<p>在Manifest文件中也可以像action一样设置多个category标签，只要有一个匹配就可以。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">    intent.setAction(&quot;com.example.dimple.action.activity2&quot;);</span><br><span class="line">    intent.addCategory(&quot;com.example.dimple.category.activity2&quot;);</span><br><span class="line">   //判断是否有Activity能够匹配intent。防止启动报错！</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="data的匹配规则"><a href="#data的匹配规则" class="headerlink" title="data的匹配规则"></a>data的匹配规则</h2><p>data的匹配规则和action类似，如果过滤规则中定义了data，那么在Intent中也需要有可以与之匹配的data。但data可以省略不写。  </p>
<p>语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;data android:scheme=&quot;string&quot; </span><br><span class="line">android:host=&quot;string&quot; </span><br><span class="line">android:port=&quot;number&quot; </span><br><span class="line">android:path=&quot;/string&quot; </span><br><span class="line">android:pathPattern=&quot;string&quot; </span><br><span class="line">android:pathPrefix=&quot;/string&quot; </span><br><span class="line">android:mimeType=&quot;string&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>data 由两部分组成，mimeType和URL（mimeType表示媒体类型，比如image/jpg、audio/mp3等，可以表示图，文本等不同格式），URL的格式如下：  </p>
<p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code> </p>
<ul>
<li>scheme:URL的模式，比如http、file、content，如果URL中没有scheme，那么URL无效。  </li>
<li>host：主机名称，比如www.bianxiaofeng.com，如果没有host，则URL无效。  </li>
<li>port：端口<br>-path、pathPattern、pathPrefix：表示路径信息  </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在通过隐式启动Activity的时候，最好是通过PackageManager的resolveActivity方法或者Intent的resolveActivity方法来判断下是不是有能够负责匹配规则的Activity存在，防止异常出错。 </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> InterFilter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Activity的启动模式]]></title>
      <url>/2018/03/07/2018-3-7-104145/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当用户多次启动同一个Activity的时候，系统默认会一直为这个Activity创建实例，并将实例放入任务栈中，在用户按back键的时候会一一回退，每按一次任务栈的时候，栈顶的任务就会出栈，当任务栈为空的时候系统会回收这个任务栈。这就是在默认的情况下，系统对于Activity的处理方式。而这种默认的方式在某些时候可能不太符合开发者的意图。所以Android出现了多种的启动模式和标志位来更改这一默认的行为。  </p>
<h1 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h1><p>目前有四种LaunchMode，分别是：standard、singleTop、singleTask以及singleInstance。<br>为了方便说明和解释，我这里写了一个Demo，以上传到GitHub，详情请<a href="https://github.com/DimpleFeng/Android-Activity-LaunchMode" target="_blank" rel="noopener">点击</a>。界面如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155052.png" alt="{mdFileName}-201837155052"><br>分别对应4种状态的LaunchMode。</p>
<h2 id="standard-LaunchMode"><a href="#standard-LaunchMode" class="headerlink" title="standard LaunchMode"></a>standard LaunchMode</h2><p>标准模式，这是系统默认的模式，每次启动的Activity的时候会默认创建一个实例，不管这个实例是不是存在。被创建的Activity实例符合典型情况下的生命周期。<br>在这种情况下，谁启动了这个Activity，那么这个Activity就属于启动它的Activity的任务栈中。比如： A启动了B，那么B就属于A的任务栈的成员。  </p>
<p>Demo点击第一项按钮4下结果如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837123217.png" alt="{mdFileName}-201837123217"><br>可以看到：<br>这里依次调用了4次的onCreate，且每次的hashcode都不一样。说明分别创建了4次Activity实例。而且任务栈的ID一直都是88.这也就说明了<strong>谁启动Activity，该Activity就位于哪个任务栈中的说法</strong>。</p>
<h2 id="singleTop-LaunchMode"><a href="#singleTop-LaunchMode" class="headerlink" title="singleTop LaunchMode"></a>singleTop LaunchMode</h2><p>栈顶复用模式。在这种模式下，如果新的Activity已经处于任务栈的栈顶，那么这个Activity将不会被创建。同时，它的onNewIntent方法会被回调，通过此方法就可以取出当前请求的信息。但是如果新的Activity不是位于栈顶，那么这个Activity会被实例化。<br>比如： 一个任务栈中从栈顶到栈底的Activity顺序是：ABCD，如果需要启动任务A，任务A的启动模式为singleTop，那么这个A不会被实例化，而是会调用onNewIntent方法。如果需要启动B，任务B的启动模式为singleTop，那么由于B不在栈顶，那么依然会实例化B，此时任务栈的顺序是：BABCD。  </p>
<p>Demo第二项点击4下Log如图所示：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155237.png" alt="{mdFileName}-201837155237"><br>这里的操作步骤是：点击进入到SingleTop界面，这个时候出现第一次onCreate，随后又点击了一次，这时候由于是singleTop处于栈顶，这个时候只是回调onNewIntent方法。然后又启动其他Activity，出现第二次onCreate，并在其他Activity启动返回到singletop界面，这个时候出现第三次onCreate。<br>可以看到：<br>只第一次点击的时候调用了onCreate方法，之后便是调用的onNewIntent方法。而且hashcode都是一样的。这就说明：<strong>新的Activity如果位于栈顶，那么新的Activity不会被实例化。</strong></p>
<h2 id="singleTask-LaunchMode"><a href="#singleTask-LaunchMode" class="headerlink" title="singleTask LaunchMode"></a>singleTask LaunchMode</h2><p>栈内复用模式。在这种模式下，只要Activity在任务栈中存在，那么就不会重新创建实例，和singleTop一样，系统会自动回调onNewIntent方法。<br>比如：当前任务栈中有ABCD四个Activity，需要启动一个Activity C，这个时候任务栈中有Activity C，那么会直接将Activity C调到栈顶，同时回调onNewIntent方法，<strong>由于singleTask具有cleanTop的效果</strong>，所以此时的任务栈的Activity为CD。如果需要启动Activity F，而Activity F不存在，所以会直接实例化Activity F，并压入栈顶。  </p>
<p>log截图如下：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155659.png" alt="{mdFileName}-201837155659">  </p>
<p>这里的操作步骤是：<br>点击进入到singleTask界面，此时出现第一个onCreate，然后点击进入到其他Activity，出现第二个onCrete。此时应该注意到，任务栈的栈顶是其他Activity，这个时候在其他Activity点击返回到singTask。由于采用的是singleTask模式，singleTask已经在任务栈中，所以是直接调用，回调onNewIntent。  </p>
<p><strong>而且由于cleanTop效果，按返回键的时候，其他Activity是不会再出现的。</strong>这一点的话，在BaseActivity.java中重写生命周期的方法就能看出来。  </p>
<h2 id="singleInstance-LaunchMode"><a href="#singleInstance-LaunchMode" class="headerlink" title="singleInstance LaunchMode"></a>singleInstance LaunchMode</h2><p>单实例模式。这是一种加强的singleTask模式，具有singleTask的所有特性（cleanTop等），还有一点：使用这种模式的Activity只能单独的位于一个单独的任务栈中。<br>比如：Activity A是singleInstance模式，当A启动后，系统会单独为这个A创建一个任务栈，由于栈内复用的原因，不会再创建新的Activity A的实例。<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018371622.png" alt="{mdFileName}-2018371622"><br>由于这个是单实例模式，对于同一个Activity来说，是直接复用。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TaskAffinity，任务相关性，这个参数标识了一个Activity需要的任务栈的名字，在默认情况下，这个任务栈的名字为应用的包名。任务栈分为前台任务栈和后台任务栈。位于后台任务栈的Activity是处于暂停状态。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Activity生命周期]]></title>
      <url>/2018/03/05/2018-3-5-121345/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Android开发的过程中，有一个特别重要的组件：Activity，它是除了Windows、Dialog和Toast之外我们用户可以直接看到的界面。本文主要记录下研究Activity中的一些感悟。<br>首先Activity的生命周期总体来说可以分为两种：  </p>
<ul>
<li>正常情况下的Activity生命周期  </li>
<li>异常情况下的Activity生命周期  </li>
</ul>
<h1 id="正常情况下的生命周期"><a href="#正常情况下的生命周期" class="headerlink" title="正常情况下的生命周期"></a>正常情况下的生命周期</h1><blockquote>
<p>所谓的正常的生命周期是指：在有用户的参与的情况下，Activity经历的生命周期的改变。  </p>
</blockquote>
<p>首先上一张Activity的生命流程切换的图：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201835125748.png" alt="{mdFileName}-201835125748">  </p>
<h2 id="7种状态方法说明"><a href="#7种状态方法说明" class="headerlink" title="7种状态方法说明"></a>7种状态方法说明</h2><p>接着对每个方法进行解释说明：</p>
<ul>
<li><p>onCreate()方法：——【<strong>此时处于Activity在后台不可见</strong>】<br>表示Activity正在被创建，这是在Android开发中接触的最多的方法，比如常见的<strong>setContentView()</strong>加载布局资源，对控件和某些数字进行初始化等等。  </p>
</li>
<li><p>onStart()方法：——【<strong>此时Activity在后台可见</strong>】<br>表示启动，此时的Activity已经是处于可见状态了，但是还没有出现在前台，所以还不能进行交互。  </p>
</li>
<li><p>onResume()方法——【<strong>此时Activity在前台且可见</strong>】<br>表示Activity已经可见了，且出现在前台。和<strong>onStart()和onResume()</strong>方法的都是可见状态，但是<strong>onResume()</strong>方法表示工作在前台。   </p>
</li>
<li><p>onPause()方法——【<strong>此时Activity在前台可见</strong>】<br>表示暂停，当Activity需要跳转到另外一个Activity或者程序即将退出的时候都需要执行这个方法。而且在正常情况下，这个方法仅能持续很小的一段时间，紧接着Android系统会接着调用onStop()方法。此时可以停止动画、存储数据等操作。当新的Activity需要显示出来的时候，必须要当前的Activity的onPause()执行完才行。</p>
</li>
</ul>
<ul>
<li><p>onStop()方法——【<strong>Activity不可见仍内存中</strong>】<br>表示Activity即将终止，此时主要做一些比较耗时的操作，如相关资源回收等。  </p>
</li>
<li><p>onDestroy()方法——【<strong>Activity不可见</strong>】<br>表示Activity即将被销毁，这是Activity的最后一个生命周期，在这里了可以做一些最终资源的回收和资源的释放工作等等。  </p>
</li>
<li><p>onRestart()方法——【<strong>Activity重新可见</strong>】<br>表示Activity正在重新启动，触发条件为从不可见转为可见。比如从当前Activity回到上一个Activity，或者从桌面返回到应用程序中去。  </p>
</li>
</ul>
<h2 id="具体场景分析"><a href="#具体场景分析" class="headerlink" title="具体场景分析"></a>具体场景分析</h2><ul>
<li>Activity启动——Activity可见状态的回调情况：<br><code>onCreate()--onStart()--onResume();</code>  </li>
<li>当打开新的Activity或者从当前Activity返回到桌面：<br><code>onPause()--onStop()</code>   </li>
<li>当再次返回到原Activity(从不可见状态切换到可见状态)：<br><code>onRestart()--onStart()--onResume()</code>  </li>
<li>当按下Back键或者退出应用程序：<br><code>onPause()--onStop()--onDestroy()</code>  </li>
</ul>
<h2 id="疑难问题"><a href="#疑难问题" class="headerlink" title="疑难问题"></a>疑难问题</h2><ul>
<li>Activity生命周期中onStart和onResume、onPause和onStop有什么不同？  </li>
</ul>
<p>onStart()方法是表示已经启动Activity但 处于不可见状态。而当生命周期走到onResume()状态的时候，Activity是处于可见状态的，这时就可以与用户进行交互。而onPause()此时仍然是处于可见的状态，当到了onStop()的时候是完全处于不可见的状态了。在实际使用中没有其他区别。<br>总结来说就是： onStart和onStop是从Activity是否可见的两种状态。而onPause和onResume是Activity是否位于前台。  </p>
<ul>
<li>当用户启动一个新的Activity，那么之前Activity的onPause和当前Activity的onResume谁先执行？  </li>
</ul>
<p>onPause方法先执行，只有当前的Activity的onPause执行完毕之后才会执行新的Activity的onResume方法。  </p>
<h1 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h1><blockquote>
<p>Android 系统出了会受到用户操作导致正常的生命周期异常结束，还有一些异常情况，比如当Android资源配置改变以及系统内存不足的情况下，Activity可能会被杀死。这个时候的生命周期可能会有一些不同。  </p>
</blockquote>
<h2 id="资源相关的系统配置发生改变导致Activity被杀死"><a href="#资源相关的系统配置发生改变导致Activity被杀死" class="headerlink" title="资源相关的系统配置发生改变导致Activity被杀死"></a>资源相关的系统配置发生改变导致Activity被杀死</h2><p>在默认情况下，如果Activity不做特别处理的话，当系统配置发生改变之后，Activity会被销毁并被重新创建。  </p>
<p>当系统配置发生改变的时候，当前Activity会执行完所有的生命周期（包括onPause、onStop、onDestroy），在这个过程中，会调用onSaveIntanceState来保存当前的Activity的状态（比如当前的输入框中的文字，当前的选择内容，当前的页面位置等等），然后会重新加载，即调用onCreate等方法。在这个过程中（onCreate）会检查onSaveIntanceState是否有数据，如果有则证明是异常重新加载。这个时候会在onCreate方法中重新赋值相关内容，而这个过程是调用onRestoreInstanceState。  </p>
<p>而关于保存和恢复View中的内容的系统工作流程如下：<br>首先Activity异常后，会直接调用onSaveInstaenceState保存数据，然后Activity会委托Windows保存数据，接着WWindows会调用上面的顶层容器去保存数据，最后顶层容器再通知每一个子View保存数据。  </p>
<p>只有在Activity异常终止的时候才会onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他的情况是不会触发这个过程的。  </p>
<h2 id="资源内存不足导致低优先级的Activity被杀死"><a href="#资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="资源内存不足导致低优先级的Activity被杀死"></a>资源内存不足导致低优先级的Activity被杀死</h2><p>Activity优先级如下：  </p>
<ul>
<li>前台Activity——正在和用户进行交互的Activity，其优先级最高。</li>
<li>可见但是非前台的Activity——比如Activity中弹出一个对话框，导致Activity可见但是位于前台无法直接和用户进行交互。  </li>
<li>后台Activity——已经被暂停的Activity，比如已经执行了onStop方法，优先级最低。  </li>
</ul>
<p>当系统内存不足的时候，系统会按照优先级的顺序从低到高的杀死目标Activity的进程，然后通过onSaveInstanceState和onRestoreInstance来存储和恢复数据。<br>一些后台工作不适合脱离四大组件运行，这样的话进程很快被系统杀死。所以一般的做法是将后台工作放在Services中来保证进程具有一定的优先级，这样进程才不会被轻易的杀死。  </p>
<p>当系统的配置发生改变之后，Activity会被重新创建。采用以下方式可以不让Activity重新创建。<br>可以在AndroidManifest中给Activity指定configChanges属性。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在onPause和onStop中都尽量不需要执行太多的耗时操作。尤其是onPause，只有在onPause执行完毕之后，新的Activity才能显示在前台。所以一般来说耗时的数据存储等工作应该放在onStop中完成。此外，在Activity被异常杀死的时候，会完整的经历onPause，onStop，onDestroy过程。并不是直接就被杀死了。从时序上，onRestoreInstanceState的调用时机是在onStart之后。  </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android BroadcastReceiver 的静态动态注册及区别]]></title>
      <url>/2018/03/04/2018-3-4-135539/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了方便Android系统各个应用程序及程序内部进行通信，Android系统引入了一套广播机制。各个应用程序可以对感兴趣的广播进行注册，当系统或者其他程序发出这条广播的时候，对发出的广播进行注册的程序便能够收到这条广播。为此，Android系统中有一套完整的API，允许程序只有的发送和接受广播。<br>本文会分别介绍静态注册广播和动态注册广播的方法并比较这两种的区别。   </p>
<p><strong>在此会先说明发送广播的两种方法</strong></p>
<h1 id="广播两种基本类型"><a href="#广播两种基本类型" class="headerlink" title="广播两种基本类型"></a>广播两种基本类型</h1><p>在一个程序中，可以发送广播供当前程序的广播接收器收到。首先我们来看下两种方式的发送广播。<br>在Android系统中，主要有两种基本的广播类型：  </p>
<ul>
<li>标准广播（Normal Broadcasts）  </li>
<li>有序广播（Ordered Broadcasts）  <h2 id="标准广播"><a href="#标准广播" class="headerlink" title="标准广播"></a>标准广播</h2></li>
</ul>
<p>是一种完全异步执行的广播，在广播发出之后，所有的广播接收器会在同一时间接收到这条广播，广播无法被截断。   </p>
<p>发送广播的方式十分简单，只需要实例化一个<strong>Intent</strong>对象，然后调用<strong>context</strong>的<strong> sendBroadcast() </strong>方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//intent中的参数为action</span><br><span class="line">Intent intent=new Intent(&quot;com.example.dimple.BROADCAST_TEST&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>
<p>这样就完成了广播的发送，至于接收呢，需要用到广播接收器，这个下面会写到。  </p>
<h2 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h2><p>是一种同步执行的广播，在广播发出之后，优先级高的广播接收器可以优先接收到这条广播，并可以在优先级较低的广播接收器之前截断停止发送这条广播。    </p>
<p>至于有序广播：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//intent中的参数为action</span><br><span class="line">Intent intent=new Intent(&quot;com.example.dimple.BROADCAST_TEST&quot;);</span><br><span class="line">sendOrderBroadcast(intent，null);//第二个参数是与权限相关的字符串。</span><br></pre></td></tr></table></figure></p>
<p>到此时，如果你的程序中只有一个广播接收器的话，是体现不出有序广播的特点的，<br>右击包名——New——Other——BroadcastReceiver多创建几个广播接收器。 </p>
<p>此时你还是会发现，所有的广播接收器是同时接收到广播消息的。注意上面介绍的时候说到优先级，这个时候我们需要设置优先级，在AndroidManifest文件中的Receiver标签中设置广播接收器的优先级。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.MyReceiver&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;!--注意此时有一个Priority属性--&gt;</span><br><span class="line">    &lt;intent-filter android:priority=&quot;100&quot;&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BROADCAST_TEST&quot;&gt;&lt;/action&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>优先级越高的广播接收器可以先收到广播，也可以在收到广播的时候调用<strong>abortBroadcast()</strong>方法截断广播。优先级低的广播接收器就无法接收到广播了。</p>
<h1 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h1><h2 id="自定义BroadcastReceiver"><a href="#自定义BroadcastReceiver" class="headerlink" title="自定义BroadcastReceiver"></a>自定义BroadcastReceiver</h2><p>在Android的广播接收机制中，如果需要接收广播，就需要创建广播接收器。而创建广播接收器的方法就是<strong>新建一个类（可以是单独新建类，也可以是内部类（public））</strong> 继承自<strong>BroadcastReceiver</strong>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class myBroadcastReceiver extends BroadcastReceiver&#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">         //接收到广播的处理，注意不能有耗时操作，当此方法长时间未结束，会报错。</span><br><span class="line">         //同时，广播接收器中不能开线程。</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="两种注册方法"><a href="#两种注册方法" class="headerlink" title="两种注册方法"></a>两种注册方法</h2><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>所谓动态注册是指在代码中注册。步骤如下 ：  </p>
<ul>
<li>实例化自定义的广播接收器。</li>
<li>创建<strong>IntentFilter</strong>实例。  </li>
<li>调用<strong>IntentFilter</strong>实例的<strong>addAction()</strong>方法添加监听的广播类型。 </li>
<li>最后调用<strong>Context</strong>的<strong>registerReceiver(BroadcastReceiver,IntentFilter)</strong>动态的注册广播。  </li>
</ul>
<p>此时，已经为我们自定义的广播接收器绑定了广播，当收到和绑定的广播一直的广播的时候，就会调用广播接收器中的<strong>onReceiver</strong>方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyBroadcastReceiver myBroadcastReceiver=new MyBroadcastReceiver();</span><br><span class="line">IntentFilter intentFilter=new IntentFilter();</span><br><span class="line">intentFilter.addAction(&quot;com.example.dimple.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(myBroadcastReceiver,intentFilter);</span><br></pre></td></tr></table></figure>
<p>PS:这里提醒一点，如果需要接收系统的广播（比如电量变化，网络变化等等），别忘记在AndroidManifest配置文件中加上权限。  </p>
<p>另外，动态注册的广播在活动结束的时候需要取消注册：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    unregisterReceiver(myBroadcastReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>这里我们使用静态注册来接收开机广播。<br>使用Android Studio 中的快捷方法来创建广播接收器。  </p>
<p>右击包名——New——Other——BroadcastReceiver。  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183414490.png" alt="{mdFileName}-20183414490">  </p>
<p>PS：静态注册的广播接收器需要在AndroidManifest文件中注册，由于使用的AS的快捷方式，所以已经创建好了。<br>如图所示：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201834145034.png" alt="{mdFileName}-201834145034">  </p>
<p>在创建好的广播接收器中添加一个Toast提示。代码如下：    </p>
<figure class="highlight plain"><figcaption><span>class MyReceiver extends BroadcastReceiver &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        Toast.makeText(context,&quot;开机启动！&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在AndroidManifest文件中添加：  </p>
<ul>
<li><p>权限<br><code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;&lt;/uses-permission&gt;</code>    </p>
</li>
<li><p>Intent-filter  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.MyReceiver&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;!--添加以下3行--&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;&lt;/action&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>此时重启Android系统就可以收到开机提示了。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态注册和静态注册的区别：  </p>
<ul>
<li><p>动态注册的广播接收器可以自由的控制注册和取消，有很大的灵活性。但是只能在程序启动之后才能收到广播，此外，不知道你注意到了没，广播接收器的注销是在onDestroy()方法中的。所以广播接收器的生命周期是和当前活动的生命周期一样。  </p>
</li>
<li><p>静态注册的广播不受程序是否启动的约束，当应用程序关闭之后，还是可以接收到广播。</p>
</li>
</ul>
<p>标准广播和有序广播的接收和发送都是全局性的，这样会使得其他程序有可能接收到广播，会造成一定的安全隐患。为了解决这个问题，Android系统中有一套本地广播的机制。这个机制是让所有的广播事件（接收与发送）都在程序内部完成。主要是采用的一个<strong>localBroadcastReceiver</strong>对广播进行管理。  </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android学习之路笔记]]></title>
      <url>/2018/01/29/2018-1-29-220254/</url>
      <content type="html"><![CDATA[<p>最近是看了下大二上学期的时候学习Android的一些笔记资料，觉得以前是写的还有需要改进的地方，所以准备再重新整理整理发出来。学习Android的时候，是采用的视频+文档结合的方式。书呢看的是：郭大神的《第一行代码》。所以本篇笔记还是按照郭大神的目录来进行记录的。  </p>
<h1 id="第一章：了解全貌——Android王国简介"><a href="#第一章：了解全貌——Android王国简介" class="headerlink" title="第一章：了解全貌——Android王国简介"></a>第一章：了解全貌——Android王国简介</h1><p> 1、Android的四层架构：Linux内核层、系统运行库层、应用框架层和应用层<br> 2、Android的四大组件：活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）<br> 3 、使用res目录下的资源的两种方式     </p>
<pre><code>例如：
    使用Res/values/string.xml文件，内容如下   
&lt;resources&gt;
    &lt;string name=&quot;app_name&gt;HrlloWorld&lt;/string&gt;
&lt;/resources&gt;
在代码中采用R.string.app_name获得HelloWorld的引用
在XML中通过@string/app_name获得引用
</code></pre><p> 4、app下的build.grade文件分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;   应用的插件，有两种值可以选，com.android.application 表示这是一个应用程序模块，com.android.library表示这是一个库模块。</span><br><span class="line">                                         应用程序模块和库模块的最大区别是应用程序模块是可以直接运行的，而库模块只能作为代码库依赖于其他应用程序模块来运行。</span><br><span class="line">android</span><br><span class="line">   compileSdkVersion 25   项目编译的版本</span><br><span class="line">   buildToolsVersion &quot;25.0.2&quot;   项目构建工具的版本</span><br><span class="line">   defaultConfig &#123;  对项目的更多细节进行配置</span><br><span class="line">       applicationId &quot;com.example.dimple.alertdialog&quot;   指定项目的包名</span><br><span class="line">       minSdkVersion 25    指定项目最低兼容的安卓版本</span><br><span class="line">       targetSdkVersion 25    表示Android25上已经做了充分的测试，</span><br><span class="line">       versionCode 1      指定项目的版本号</span><br><span class="line">       versionName &quot;1.0&quot;    指定项目的版本名</span><br><span class="line">       testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   buildTypes &#123; 用于指定安装文件的相关配置</span><br><span class="line">       release &#123;</span><br><span class="line">           minifyEnabled false   表示是否对项目进行代码混淆</span><br><span class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;  指定混淆的时候使用的规则文件</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">dependencies &#123;  指定当前项目的依赖关系，Android中一共有三种依赖方式：本地依赖、库依赖、远程依赖。</span><br><span class="line">                本地依赖可以对本地的jar包或者目录添加依赖关系，库依赖可以对项目中的库模块进行添加依赖关系。</span><br><span class="line">                远程依赖可以对jcenter库上的开源项目添加依赖关系。</span><br><span class="line">   compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])   本地依赖声明，表示将lib目录下的所有的jar文件添加到项目的构建路径中</span><br><span class="line">   androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123;</span><br><span class="line">       exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;</span><br><span class="line">   &#125;)</span><br><span class="line">   compile &apos;com.android.support:appcompat-v7:25.3.0&apos;   标准的远程依赖库格式，其中“com.android.support”是域名部分，用于和其他公司的库作区分。</span><br><span class="line">                                                        “appcompat-v7”是组名称，用于和同一个公司的不同的库作区分。“25.3.0”是版本号，用于和同一个库的不同版本作区分。</span><br><span class="line">   compile &apos;com.android.support.constraint:constraint-layout:1.0.1&apos;</span><br><span class="line">   testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第二章-先从看得到的入手——探究活动"><a href="#第二章-先从看得到的入手——探究活动" class="headerlink" title="第二章 先从看得到的入手——探究活动"></a>第二章 先从看得到的入手——探究活动</h1><h2 id="1、Genenate-Layout-File-是表示自动为Activity创建一个布局，Launcher-Activity表示将当前活动设置为主活动。"><a href="#1、Genenate-Layout-File-是表示自动为Activity创建一个布局，Launcher-Activity表示将当前活动设置为主活动。" class="headerlink" title="1、Genenate Layout File 是表示自动为Activity创建一个布局，Launcher Activity表示将当前活动设置为主活动。"></a>1、Genenate Layout File 是表示自动为Activity创建一个布局，Launcher Activity表示将当前活动设置为主活动。</h2><h2 id="2、配置主活动的方法：在Manifest中的Activity标签中添加标签，并在这个标签中添加"><a href="#2、配置主活动的方法：在Manifest中的Activity标签中添加标签，并在这个标签中添加" class="headerlink" title="2、配置主活动的方法：在Manifest中的Activity标签中添加标签，并在这个标签中添加"></a>2、配置主活动的方法：在Manifest中的Activity标签中添加<intent-filter>标签，并在这个标签中添加</intent-filter></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">&lt;category android:name-&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3、在活动中使用Menu"><a href="#3、在活动中使用Menu" class="headerlink" title="3、在活动中使用Menu"></a>3、在活动中使用Menu</h2><p>在res中新建Menu文件夹，创建XML文件，然后在相应的Java代码中重写onCreateOptionMenu()和onOptionItemSelect()方法。  </p>
<p>在onCreateOptionMenu()方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean onCreateOptionMenu()</span><br><span class="line">&#123;</span><br><span class="line">   getMenuInflater().inflater(R.menu.main,menu);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onOptionItemSelect()用于响应用户的事件。在此函数中，可以通过:<strong>item.getItemId</strong>判断点击的是哪一个菜单项。  </p>
<h2 id="4、销毁一个活动使用finish-函数，效果和按下back键是一样的"><a href="#4、销毁一个活动使用finish-函数，效果和按下back键是一样的" class="headerlink" title="4、销毁一个活动使用finish()函数，效果和按下back键是一样的"></a>4、销毁一个活动使用finish()函数，效果和按下back键是一样的</h2><h2 id="5、使用Intent"><a href="#5、使用Intent" class="headerlink" title="5、使用Intent"></a>5、使用Intent</h2><blockquote>
<p>Intent是Android程序中各组件之间进行交互的主要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同的组件之间进行数据的传递。Intent一般可以用于启动活动，启动服务，以及发送广播等场景。  </p>
</blockquote>
<p>Intent有多个构造函数：<strong>Intent(Context packageContext,Class&lt;?&gt;cls)</strong>；第一个参数Context要求提供一个启动活动的上下文，第二个参数class用于指定想要启动的目标。  </p>
<p>使用<strong>StartActivity(Intent intent)</strong>；启动活动。  </p>
<p>使用隐式的Intent启动方法  </p>
<p>在需要启动的活动的Manifest文件中配置Intent-filter 中的action和category<br>然后使用Intent的构造函数，传进去action和category，如果category是默认的话就可以不用传入进去。  </p>
<p>如果不是默认的，需要使用<strong>intent.addcategory();</strong>  </p>
<p>Intent的其他用法：<br>打开网页、拨号、<br>Intent向下一个活动传递数据  </p>
<p>使用<strong>intent.putExtra(String name,boolean/String value)</strong>函数，此方法就可以将想要存放的数据暂存在Intent中。第一个参数是键，第二个参数是要传入的数据。  </p>
<p><strong>getStringExtra(String name)</strong>和<strong>getIntExtra(String name)</strong>等系列方法可以获得数据。  </p>
<h2 id="6、Intent向上一个活动传递数据。"><a href="#6、Intent向上一个活动传递数据。" class="headerlink" title="6、Intent向上一个活动传递数据。"></a>6、Intent向上一个活动传递数据。</h2><p>使用<strong>startActivityForResult(Intent intent,int requestCode)</strong>方法在A中来启动Activity B；第一个参数是Intent，第二个参数是请求码，用于在回调之后来判断数据的来源。  </p>
<p>在B中Intent中<strong>putExtra(String name,value)</strong>来返回要传递的数据。  </p>
<p>同时调用ApplicationContext的<strong>setResult(int requestCode,intent data)</strong>方法，第一个参数是要上一个活动A传递的处理结果，一般只使用<strong>RESULT_OK</strong>或<strong>RESULT_CANCELED</strong>两个值，第二个参数将带有数据的Intent返回。  </p>
<p>在A中重写<strong>onActivityResult(int requestCode,int resultCode,Intent intent)</strong>方法，此方法有三个参数，第一个参数requestCode是我们在A中使用<strong>startActivityForResult()</strong>方法传入的，第二个参数是resultCode是在B中返回数据的时候传入的setResult方法中的结果码。第三个参数是传入的数据的Intent对象。  </p>
<p>一般是重写back键按下之后回调的方法：<strong>onBackPressed()</strong>;</p>
<h2 id="7、活动的生命周期"><a href="#7、活动的生命周期" class="headerlink" title="7、活动的生命周期"></a>7、活动的生命周期</h2><ul>
<li>当活动被首次创建的时候：<br>会依次调用：    onCreate()方法、onStart()方法、onResume方法。  </li>
<li>当从当前的活动跳转到另一个界面的时候（当前活动不可见）<br>会依次调用：      onPause()方法、onStop()方法  </li>
<li>当从其他活动再跳转回来的时候<br>会依次调用：     onRestart()方法、onStart()方法、onResume()方法  </li>
<li>当从当前活动跳转自另一个活动的时候（当前活动可见）<br>会依次调用：    onPause()方法   </li>
<li>当从这个活动跳转会主活动的时候<br>会依次调用：    onResume()方法  </li>
<li>结束当前活动的时候<br>会依次调用：     onDestory()方法  <h1 id="第三章-常用控件的使用方法"><a href="#第三章-常用控件的使用方法" class="headerlink" title="第三章 常用控件的使用方法"></a>第三章 常用控件的使用方法</h1><h2 id="ListView的使用"><a href="#ListView的使用" class="headerlink" title="ListView的使用"></a>ListView的使用</h2><h3 id="listView-的简单用法"><a href="#listView-的简单用法" class="headerlink" title="listView 的简单用法"></a>listView 的简单用法</h3><pre><code>首先，需要在布局中加入ListView控件，然后需要定义适配器（一般是ArrayAdapter）
</code></pre>ArrayAdapter<string>adapter=new ArrayAdapter<string>(<br>  context,resourse,data);<br>listView.setAdapter(adapter);<h3 id="ListView之自定义适配器"><a href="#ListView之自定义适配器" class="headerlink" title="ListView之自定义适配器"></a>ListView之自定义适配器</h3>  首先先创建一个类，这个类中包含了需要进行自定义适配器需要用到的相关资源文件，此类为JAVABean。<br>此外，还需要一个适配器，适配器继承自ArrayAdapter&lt;&gt;并泛型为定义的类。在此适配器中，重写getView()方法。   </string></string></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/***  </span><br><span class="line">* 自定义适配器,继承自ArrayAdapter,并将泛型指定为Fruit类  </span><br><span class="line">*/  </span><br><span class="line">class MyAdapter extends ArrayAdapter&lt;Fruit&gt;&#123;  </span><br><span class="line">   /**  </span><br><span class="line">    *  </span><br><span class="line">    * @param context  </span><br><span class="line">    * @param resource  </span><br><span class="line">    * @param objects  </span><br><span class="line">    */  </span><br><span class="line">   private  int Resource;  </span><br><span class="line">   public MyAdapter(@NonNull Context context, @LayoutRes int resource, @NonNull List&lt;Fruit&gt; objects) &#123;  </span><br><span class="line">       super(context, resource, objects);  </span><br><span class="line">       Resource=resource;  </span><br><span class="line">   &#125;  </span><br><span class="line">​  </span><br><span class="line">   @NonNull  </span><br><span class="line">   @Override  </span><br><span class="line">   public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;  </span><br><span class="line">       View view;  </span><br><span class="line">       ViewHolder viewHolder;  </span><br><span class="line">       Fruit fruit=getItem(position);    </span><br><span class="line">       if (convertView==null)&#123;  </span><br><span class="line">           view= LayoutInflater.from(getContext()).inflate(Resource,parent,false);  </span><br><span class="line">           viewHolder-new ViewHolder();  </span><br><span class="line">           viewHolder.ImageView imageView=view.findViewById(R.id.imageView);  </span><br><span class="line">           viewHolder.TextView textView=view.findViewById(R.id.textView);  </span><br><span class="line">           view.setTag(viewHolder);//将ViewHolder存储在View中</span><br><span class="line">       &#125;else&#123;  </span><br><span class="line">           view=convertView;  </span><br><span class="line">           viewHolder=(ViewHolder)getTag();//重新获取ViewHolder  </span><br><span class="line">       &#125;  </span><br><span class="line">       imageView.setImageResource(fruit.getFruitImage());  </span><br><span class="line">       textView.setText(fruit.getFruitName());  </span><br><span class="line">       return view;  </span><br><span class="line">   &#125;  </span><br><span class="line">   class ViewHolder()&#123;  </span><br><span class="line">       ImageView fruitImage;  </span><br><span class="line">       TextView fruitName;  </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中<strong>getItem()</strong>方法是每个子项滚动到屏幕类的时候被调用。   convertView将之前的项目进行缓存。<br>新建一个内部类ViewHolder，用于对实例对象进行缓存，把控件的实例都存放在viewHolder中，然后调用View的setTag()方法，将ViewHolder对象保存在View中，当convertView不为null的时候，调用View中的getTag()方法，将ViewHolder取出。这样系统每次就不用通过findViewById()来获取控件实例。<br>    点击事件需要设置监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       @Override</span><br><span class="line">       public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;</span><br><span class="line">          Fruit fruit=fruitList.get(i);</span><br><span class="line">           Toast.makeText(getApplicationContext(),&quot;position&quot;+i+fruit.getFruitName(),Toast.LENGTH_LONG).show();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RecyclerView使用"><a href="#RecyclerView使用" class="headerlink" title="RecyclerView使用"></a>RecyclerView使用</h2><p>由于是新增的部件，所以需要添加依赖包  </p>
<p><code>compile &#39;com.android.support:recyclerview-v7:26.+&#39;  //此处需要注意的是V7:后的，是appcompat后面的版本号</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">      initData();//初始化集合List中的数据</span><br><span class="line">       RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerview);</span><br><span class="line">       FruitAdapter adapter = new FruitAdapter(fruitList);</span><br><span class="line">       /**</span><br><span class="line">        * 这里用于指定RecyclerView的布局方式</span><br><span class="line">        */</span><br><span class="line">       LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext());</span><br><span class="line">       recyclerView.setLayoutManager(linearLayoutManager);</span><br><span class="line">       recyclerView.setAdapter(adapter);</span><br><span class="line">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123;</span><br><span class="line">   private List&lt;Fruit&gt;mFruitList;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 构造函数用于将要展示的数据传入，并赋值给一个全局变量mFruitList。</span><br><span class="line">        * @param mFruitList</span><br><span class="line">        */</span><br><span class="line">       public FruitAdapter(List&lt;Fruit&gt; mFruitList) &#123;</span><br><span class="line">           this.mFruitList = mFruitList;</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * 首先定义了一个内部类ViewHolder，ViewHolder要继承自RecyclerView.ViewHolder，然后ViewHolder的构造函数要传入一个view参数</span><br><span class="line">        * 这个参数通常就是RecyclerView子项最外层的布局。</span><br><span class="line">        */</span><br><span class="line">       static class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class="line">           ImageView fruitImage;</span><br><span class="line">           private View fruitView;//设置view点击事件  添加此变量来保存子项最外层的布局的实例</span><br><span class="line">           TextView fruitName;</span><br><span class="line">           public ViewHolder(View view) &#123;</span><br><span class="line">               super(view);</span><br><span class="line">               fruitView=view;//获取View</span><br><span class="line">               fruitImage=view.findViewById(R.id.imageView);</span><br><span class="line">               fruitName=view.findViewById(R.id.textView);</span><br><span class="line">    ​</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * onCreateViewHolder()是用于创建ViewHolder实例的，在这个方法中，将布局加载到ViewHolder的实例中，然后将ViewHolder实例返回</span><br><span class="line">        * @param parent</span><br><span class="line">        * @param viewType</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public FruitAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">           View view= LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false);</span><br><span class="line">    ​</span><br><span class="line">           final ViewHolder holder=new ViewHolder(view);</span><br><span class="line">           /**</span><br><span class="line">            * ViewHolder设置点击事件</span><br><span class="line">            */</span><br><span class="line">           holder.fruitView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onClick(View view) &#123;</span><br><span class="line">                   /*</span><br><span class="line">                   通过ViewHolder的getAdapterPosition获得position</span><br><span class="line">                   然后可以通过该位置在List中获取实例</span><br><span class="line">                    */</span><br><span class="line">                   int position =holder.getAdapterPosition();</span><br><span class="line">                   Fruit fruit=mFruitList.get(position);</span><br><span class="line">                   Toast.makeText(view.getContext(),&quot;this is &quot;+ fruit.getFruitName(),Toast.LENGTH_LONG).show();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           return holder;</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * 用于对RecyclerView子项的数据进行赋值，当每个子项被滚动到屏幕内的时候被调用</span><br><span class="line">        * @param holder</span><br><span class="line">        * @param position</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public void onBindViewHolder(FruitAdapter.ViewHolder holder, int position) &#123;</span><br><span class="line">           Fruit fruit=mFruitList.get(position);</span><br><span class="line">           holder.fruitImage.setImageResource(fruit.getFruitImage());</span><br><span class="line">           holder.fruitName.setText(fruit.getFruitName());</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * 返回当前要加载的数据源的长度</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public int getItemCount() &#123;</span><br><span class="line">           return mFruitList.size();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>瀑布流使用： StaggeredGridLayoutManager  设置瀑布流的布局方式  </p>
<p>如果需要设置为横向滑动的话就需要在MainActivity中的LinearLayoutManager设置方向</p>
<p>  linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);</p>
<p>使用步骤：</p>
<p>获取RecyclerView实例——设置layoutManager布局对象——绑定适配器<br>创建JavaBean类<br>创建适配器——继承自《RecyclerView.Adapter<javabean.viewholder>》（ViewHolder为内部类）——创建ViewHolder内部类继承自RecyclerView.ViewHolder并完成控件的初始化——创建构造器进行相关数据的传入——重写onCreaterViewHolder()、onBindViewHolder()、getItemCount()方法。<br>重写onCreateViewHolder()方法——获取View对象，创建ViewHolder实例，返回ViewHolder实例（同时可以设置点击事件）<br>重写onBindViewHolder()方法（对子项的数据进行赋值操作，通过Position获取实例）——将数据设置到ViewHolder中的控件实例中。  </javabean.viewholder></p>
<h1 id="第四章-碎片"><a href="#第四章-碎片" class="headerlink" title="第四章 碎片"></a>第四章 碎片</h1><h2 id="碎片的静态加载"><a href="#碎片的静态加载" class="headerlink" title="碎片的静态加载"></a>碎片的静态加载</h2><p>在MainActivity的布局文件中添加<fragment>的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;fragment  </span><br><span class="line">       android:id=&quot;@+id/id_fragment_title&quot;  </span><br><span class="line">       android:name=&quot;com.zhy.zhy_fragments.TitleFragment&quot;  </span><br><span class="line">       android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">       android:layout_height=&quot;45dp&quot; /&gt;</span><br></pre></td></tr></table></figure></fragment></p>
<p>在TitleFragment的布局文件和JAVA文件中进行操作<br>在java文件中重写onCreateView方法，注意要继承只V4包的Fragment。  </p>
<h2 id="碎片的动态加载"><a href="#碎片的动态加载" class="headerlink" title="碎片的动态加载"></a>碎片的动态加载</h2><p>在MainActivity的布局文件中声明一个区域作为碎片出现的位置 。<br>找MainActivity的JAVA文件中首先设置默认的显示的Fragment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prvate void setDefaultFragment()&#123;</span><br><span class="line">   FragmentManager fm =getFragmentManager();</span><br><span class="line">   FragmentTransaction transaction = fm.beginTransaction();</span><br><span class="line">   FragmentOne one=new FragmentOne();</span><br><span class="line">   transaction.replace(R.id.mainactivity_fragment,one);</span><br><span class="line">   transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Fragment常用的API："><a href="#Fragment常用的API：" class="headerlink" title="Fragment常用的API："></a>Fragment常用的API：</h3><p>Fragment常用的三个类</p>
<p>要用于定义Fragment。</p>
<ul>
<li>android.app.FragmentManager主要用于在Activity中操作Fragment。</li>
<li>android.app.FragmentTransaction保证一系列Fragment操作的原子性。</li>
</ul>
<p>获取FragmentManager的方式  </p>
<ul>
<li>getFragmentManager()  //在V4包中，getSupportFragmentManager()</li>
</ul>
<p>主要的操作中都是FragmentTransaction的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    FragmentManager fm =getSupportFragmentManager();  </span><br><span class="line">    FragmentTransaction transaction = fm.beginTransaction();//开启一个事务  </span><br><span class="line">    transaction.add(); //向Activity中添加一个Fragment  </span><br><span class="line">    transaction.remove();//从Activity中移除一个Fragment  </span><br><span class="line">    transaction.replace();//使用另一个Fragment替换掉当前的Fragment，实际上是remove()和add()的合体  </span><br><span class="line">    transaction.show();//显示之前隐藏的Fragment  </span><br><span class="line">    transaction.hide();//隐藏当前的Fragment，仅仅设置为隐藏，并不会销毁  </span><br><span class="line">    transaction.commit();//提交一个事务 </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">注：如果希望保留用户在当前fragment的数据，就使用hide()和show()组合，这样不会销毁当前的Fragment  </span><br><span class="line">        如果不希望保留用户当前在Fragment的数据，就使用remove()和add()组合或者直接使用replace()，这样就会销毁当前的Fragment，再进去的时候就会重新加载  </span><br><span class="line">        如果使用replace的话，当程序已经不在当前的界面的时候，在其他界面按Back键的时候，将不会返回到这个界面，直接退出  </span><br><span class="line">        想要保留这个fragment的话，就需要将它添加到回退栈中：   ** transaction.addToBackStack();**  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[参考博客](http://blog.csdn.net/lmj623565791/article/details/37970961/)</span><br><span class="line"></span><br><span class="line"># 第五章 广播</span><br><span class="line"></span><br><span class="line">## 1、广播的两种类型</span><br><span class="line"></span><br><span class="line">- 标准广播  广播发出后，所有的广播接收器会在同一时间接收到这条广播。效率较高，无法截断。</span><br><span class="line">- 有序广播  广播发出后，同一时刻只有一个广播接收器能够接收到这条广播，并且优先级高的可以先接收到这条广播，并且前面的广播接收器可以截断广播。</span><br><span class="line"></span><br><span class="line">## 2、注册广播的两种方式</span><br><span class="line"></span><br><span class="line">    在代码中注册——动态注册——在程序关闭之后就不能再接收到广播  </span><br><span class="line">    在AndroidManifest中注册——静态注册——与程序是否关闭无关(开机状态就能被唤醒)  </span><br><span class="line"></span><br><span class="line">## 3、创建广播接收器的方法</span><br><span class="line">新建一个类，继承自BroadcastReceiver，并重写父类的onReceive()方法。  </span><br><span class="line">这样，当有广播到来的时候，onReceive()方法就会得到调用。  </span><br><span class="line">## 4、动态注册广播的方法</span><br><span class="line">创建IntentInfilter的实例，添加一个action</span><br></pre></td></tr></table></figure></p>
<pre><code>IntentInfilter intentInfliter =new IntentInfliter();//创建IntentFilter实例  
intentInfilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);//为这个IntentFilter添加action  
registerReceiver(networkChageReceiver,interFilter);//动态注册广播，这样networkChangeReceiver就会接收到所有值为android.net.conn.CONNECTIVITY_CHANGE的广播
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**动态注册的广播需要取消注册，在onDestory中调用unRegisterReceiver()方法来实现的。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5、静态注册广播的方法</span><br><span class="line"></span><br><span class="line">使用android Studio的快捷键创建一个广播接收器，点击包名——New——Other——Broadcast Receiver，Exported表示是否允许广播接收器接收本程序以外的广播，Enable表示是否启用这个广播。  </span><br><span class="line"></span><br><span class="line">（静态注册的广播接收器必须要在AndroidManifest中注册才能使用，使用Android Studio创建的广播接收器已经在AndroidManifest中注册了）</span><br><span class="line">注册方式信息如下：</span><br></pre></td></tr></table></figure>
<pre><code>    &lt;receiver
        android:name=&quot;.MyReceiver&quot;
        android:enabled=&quot;true&quot;//是否启用该广播接收器
        android:exported=&quot;true&quot;&gt;//是否允许接受本程序之外的广播
        &lt;intent-filter  android:priority=&quot;100&quot;&gt;//priority是设置广播的优先级，优先级越高系统响应越快
            &lt;action android:name=&quot;android.intent.action.BATTERY_LOW&quot;/&gt;//当系统低电量的时候就会发出这个广播
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在&lt;intent-filter&gt;标签中添加相应的Action标签</span><br><span class="line"></span><br><span class="line">**注意某些操作需要用到权限，需要在Manifest中添加权限。**</span><br><span class="line"></span><br><span class="line">此外，在onReceive中不能添加太多的逻辑以及耗时操作，在广播接收器中是不允许多开线程的，当此方法运行了太长时间而没有结束，程序会报错。</span><br><span class="line"></span><br><span class="line">发送动态广播的方法：</span><br></pre></td></tr></table></figure>
<pre><code>Intent intent=new Intent(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);
sendBroadcast(intent);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 6、自定义广播</span><br><span class="line"></span><br><span class="line">创建一个自定义的广播接收器继承自BroadcastReceicer，并重写onReceive()方法。</span><br><span class="line">然后使用Intent发送广播。</span><br><span class="line"></span><br><span class="line">- 有序广播  </span><br><span class="line">在Manifest中的Broadcast标签的Intent-filter中设置优先级属性priority  </span><br><span class="line">发送广播的时候与标准广播不同  </span><br><span class="line">**sendOrderBroadcast(intent,null)**//第一个是Intent实例，第二个是与权限相关的字符串，这里传入null  </span><br><span class="line">- 截断广播  </span><br><span class="line">**abortBroadcast()**;//在广播接收器中调用这个方法就可以截断广播</span><br><span class="line"></span><br><span class="line">## 7、本地广播  </span><br><span class="line">    本地广播的出现是为了解决广播在整个系统中运行中的安全性的问题，全局广播会被其他程序所截获，造成信息泄露。  </span><br><span class="line">    本地广播的用法  </span><br><span class="line">主要是使用一个LocalBroadcastManager来对广播进行管理，并提供了发送广播和和注册广播的方法。</span><br></pre></td></tr></table></figure>
<pre><code>localBroadcastManager=LocalBroadcastManager.getInstance(getApplicationContext());
      Button button= (Button) findViewById(R.id.button);
      button.setOnClickListener(new View.OnClickListener() {
          @Override
          public void onClick(View v) {
              Intent intent=new Intent(&quot;com.example.dimple.mytest.MYMY&quot;);
              localBroadcastManager.sendBroadcast(intent);
          }
      });
      IntentFilter intentFilter=new IntentFilter();
      intentFilter.addAction(&quot;com.example.dimple.mytest.MYMY&quot;);
      localBroadcastManager.registerReceiver(new MyReceiver(),intentFilter);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">**本地广播只能通过动态注册。**</span><br><span class="line"></span><br><span class="line">**获取步骤**  </span><br><span class="line">- 通过LocalBroadcastMaager的**getInstance()**方法得到实例。  </span><br><span class="line">- 然后注册广播的时候就调用LocalBroadcastManager的**registerRecriver()**方法.  </span><br><span class="line">- 在发送广播的时候就调用LocalBroadcastManager的**sendBroadcastManager()**方法。</span><br><span class="line"></span><br><span class="line"># 第六章 存储</span><br><span class="line">## 1、使用SharedPreferences</span><br><span class="line">SharedPreferences是采用键值对的方式来存储数据的。  </span><br><span class="line">要使用SharedPreferences需要首先获得SharedPreferences对象。获取该对象的方式有：  </span><br><span class="line">- Context类中的**getSharedPreferences(String name,int mode)**方法，接收两个参数，第一个参数是文件的名称，第二个参数指定操作模式MODE，目前只能选择MODE_PRIVATE。  </span><br><span class="line">- Activity类中的**getPreferences(int mode)**方法，和**getSharePreferences(String name,int mode)**差不多，区别是使用**getPreferences(int mode)**会使用当前的类名作为文件名。  </span><br><span class="line">- PreferencesManager类中的**getDefaultSharedPreferences(Context context)**方法 ，这是一个静态方法，接收一个context参数，会自动将当前的应用程序的包名作为前缀来命名SharePreferences文件 </span><br><span class="line"></span><br><span class="line">**使用步骤**  </span><br><span class="line">调用sharedPreferences对象的editor()方法来获得一个 sharedPerferences.Editor()对象  </span><br><span class="line">向sharedPerferences.Editor()对象添加数据。调用editor的putString()等些列方法  </span><br><span class="line">调用editor的apply()方法提交数据。</span><br></pre></td></tr></table></figure>
<pre><code>SharedPreferences.Editor editor=getSharedPreferences(&quot;test&quot;,MODE_PRIVATE).edit();
editor.putString(&quot;name&quot;,&quot;Tom&quot;);
editor.apply();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**读取SharedPreferences的方法**  </span><br><span class="line"></span><br><span class="line">获取SharedPreferences对象，通过getString()系列方法得到数据。注意这里有两个参数，第一个是要读取的数据的键，第二个参数是没有找到这个数据返回的值。</span><br></pre></td></tr></table></figure>
<pre><code>SharedPreferences sharedPreferences=getSharedPreferences(&quot;test&quot;,MODE_PRIVATE);
sharedPreferences.getString(&quot;name&quot;,&quot;没有找到name属性的值&quot;);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 2、使用SQLite数据库进行存储  </span><br><span class="line"></span><br><span class="line">android中为了更好的管理数据库，提供了一个SQLiteOpenHelper的帮助类（抽象类），需要实现SQLiteOpenHelper抽象方法中的抽象方法**onCreate()**（在数据库被创建的时候会调用），**onUpgrade()**（在数据库版本被升级的时候被调用）  </span><br><span class="line"></span><br><span class="line">获取实例的方法：(都可以打开或者创建数据库)  </span><br><span class="line">getReadableDatebase()只能是通过只读的方式来打开数据库。  </span><br><span class="line">getWritableDatebase()使用读写的方式打开数据库。  </span><br><span class="line"></span><br><span class="line">**使用方法：**  </span><br><span class="line">新建一个JAVA类继承自SQLiteOpenHelper，实现两个抽象方法**onCreate()**和**onUpgrade()**，创建构造器（使用参数较少的那一个构造器），其参数有  </span><br><span class="line"></span><br><span class="line">    Context context, String name, SQLiteDatabase.CursorFactory factory, int version</span><br><span class="line">/*</span><br><span class="line">第一个参数是context上下文</span><br><span class="line">第二个参数是数据库名</span><br><span class="line">第三个参数允许在查询的时候返回一个自定义的Cursor，一般为null</span><br><span class="line">第四个参数是当前数据库的版本号，可用于对数据库的更新操作</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构建出SQLiteOpenHelper实例（new）以后，调用**getReadableDatebase()**或者**getWritableDatebase()**就可以创建数据库了。</span><br><span class="line">创建的数据库的名字一般放在 /data/data/&lt;package name&gt;/datebase目录下。</span><br><span class="line"></span><br><span class="line">配置adb 在安卓SDK的目录下有一个platform-tools文件夹，将这个文件夹配置到系统的环境变量中，使用adb shell进入控制台终端</span><br><span class="line"></span><br><span class="line">使用sqlite3 +数据库名称 打开数据库  </span><br><span class="line">使用.table 查看数据库中的表、  </span><br><span class="line">使用 .schema 查看建表语句  </span><br><span class="line"></span><br><span class="line">3、向SQLite数据库中添加数据</span><br><span class="line">调用SQLiteOpenHelper的getReadableDatebase()或者getWritableDatebase()创建数据库后会返回一个SQLiteDatabase对象，借助这个对象就可以对数据库进行CRUD操作  </span><br><span class="line">**添加数据**  </span><br><span class="line">    SQLiteDatabase提供一个insert()方法用于添加数据。这个方法有三个参数。第一个参数是数据库表名称，第二个是用于指定在未添加数据的情况下给某些数据项自动赋值为null，第三个参数是ContentValues对象，它提供一系列的put()方法重载，用于向contentValues添加数据。使用此方法的时候需要创建ContentValues对象。  </span><br><span class="line"></span><br><span class="line">    sqLiteDatabase.insert(&quot;Book&quot;,null,contentValues);//插入信息到Book</span><br><span class="line"></span><br><span class="line">**更新数据**  </span><br><span class="line">    SQLiteDatabase提供一个update()的方法，第一个参数是表名，第二个参数是ContentValues对象，第三四个参数用于约定更新某一行或者某几行的数据。  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        sqLiteDatabase.update(&quot;Book&quot;,contentValues,&quot;id=?&quot;,new String[]&#123;&quot;1&quot;&#125;);//更新id为1的书的信息</span><br><span class="line">        第三个参数对应的是SQL的where语句，第四个提供约束的具体信息。</span><br><span class="line"></span><br><span class="line">**删除数据**</span><br><span class="line"></span><br><span class="line">    SQLiteDatabase提供一个delete()的方法，第一个参数是表名，第二三个参数用于约定删除某一行或者某几行的数据。   </span><br><span class="line"></span><br><span class="line">     sqLiteDatabase.delete(&quot;Book&quot;,&quot;pages&gt;?&quot;,new String[]&#123;&quot;500&quot;&#125;);//删除页数超过500页的书的信息  </span><br><span class="line"></span><br><span class="line">**查询数据**  </span><br><span class="line"></span><br><span class="line">    query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit)方法各参数的含义：</span><br><span class="line"> </span><br><span class="line">- table：表名。相当于select语句from关键字后面的部分。如果是多表联合查询，可以用逗号将两个表名分开。</span><br><span class="line"> </span><br><span class="line">- columns：要查询出来的列名。相当于select语句select关键字后面的部分。</span><br><span class="line"> </span><br><span class="line">- selection：查询条件子句，相当于select语句where关键字后面的部分，在条件子句允许使用占位符“?”</span><br><span class="line"> </span><br><span class="line">- selectionArgs：对应于selection语句中占位符的值，值在数组中的位置与占位符在语句中的位置必须一致，否则就会有异常。</span><br><span class="line"> </span><br><span class="line">- groupBy：相当于select语句group by关键字后面的部分</span><br><span class="line"> </span><br><span class="line">- having：相当于select语句having关键字后面的部分</span><br><span class="line"> </span><br><span class="line">- orderBy：相当于select语句order by关键字后面的部分，如：personid desc, age asc;</span><br><span class="line"> </span><br><span class="line">- limit：指定偏移量和获取的记录数，相当于select语句limit关键字后面的部分。</span><br></pre></td></tr></table></figure>
<pre><code>               sqLiteDatabase=mySqlite.getWritableDatabase();
               Cursor cursor=sqLiteDatabase.query(&quot;Book&quot;,null,null,null,null,null,null);//查询完毕后得到一个游标Cursor对象，通过这个对象去访问数据
               if (cursor.moveToFirst()){//将游标移动到第一行的位置
                   do{//接下来是循环
                       //在这个循环中可以通过Cursor的getColumnIndex()方法获取到某一行的索引。将这个索引传入相应的取值方法中就可以得到相应的数据了。
​
                       String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;));
                       String author =cursor.getString(cursor.getColumnIndex(&quot;author&quot;));
                       int pages=cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));
                       double price=cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));
                       builder.append(&quot;name\n&quot;).append(name).append(&quot;author\n&quot;).append(author).append(&quot;pages\n&quot;).append(pages).append(&quot;price\n&quot;).append(price);
                   }while (cursor.moveToNext());
                   textView.setText(builder);
               }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 4、使用LitePal操作数据库</span><br><span class="line">**配置过程**  </span><br><span class="line"></span><br><span class="line">    编辑app/build.gradle文件，在dependencies闭包中加入</span><br></pre></td></tr></table></figure>
<p>compile ‘org.litepal.android:core:1.3.2’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后在app/src/main目录新建一个assets目录，在此目录下创建一个litepal.xml文件</span><br></pre></td></tr></table></figure></p>
<pre><code>&lt;litepal&gt;  
    &lt;!--dbname标签用于指定数据库名，version标签用于指定数据库版本号，list标签用于指定所有的映射模型--&gt;  
    &lt;dbname value=&quot;BookStore&quot;&gt;&lt;/dbname&gt;
    &lt;version value =&quot;2&quot;&gt;&lt;/version&gt;
    &lt;list&gt;
        &lt;mapping class=&quot;com.example.dimple.sharedpreferencestest.Book&quot;&gt;&lt;/mapping&gt;
        &lt;mapping class=&quot;com.example.dimple.sharedpreferencestest.Category&quot;&gt;&lt;/mapping&gt;
    &lt;/list&gt;
&lt;/litepal&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后需要在AndroidManifest中将项目的application配置为</span><br></pre></td></tr></table></figure>
<pre><code>&lt;application
    android:name=&quot;org.litepal.LitePalApplication&quot;
    android:allowBackup=&quot;true&quot;
    android:icon=&quot;@mipmap/ic_launcher&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**创建数据库：**  </span><br><span class="line"></span><br><span class="line">    使用面向对象的思想，定义一个Book类JavaBean类。  </span><br><span class="line">    将关系模型添加到映射模型列表中</span><br></pre></td></tr></table></figure>
<p><mapping class="com.example.dimple.sharedpreferencestest.Book"></mapping><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">注：不管需要多少关系模型，注意要使用完整的类名，不管需要多少模型类映射，都需要用同样的方式在&lt;list&gt;标签下配置。  </span><br><span class="line"></span><br><span class="line">在代码中使用**Connector.getDatabase()；**创建数据库。  </span><br><span class="line"></span><br><span class="line">升级版本号，就可以直接修改litepal.xml中的version即可。此升级不会删除数据库。  </span><br><span class="line"></span><br><span class="line">**添加数据**  </span><br><span class="line"></span><br><span class="line">    需要将JavaBean类继承自DataSupport类。  </span><br><span class="line">    在java代码中，直接new一个JavaBean类的对象出来，然后调用set系列方法，最后调用DataSupport父类传下来的save()方法即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**更新数据**  </span><br><span class="line"></span><br><span class="line">直接new一个JavaBean对象出来，调用要修该的数据项的set函数，然后**updataAll()**;  此方法可以设置约束条件</span><br></pre></td></tr></table></figure></p>
<pre><code>book.updateAll(&quot;name=?&quot;,&quot;the da vinvi code &quot;);//修改所有name=the da vinvi code的数据项。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**删除数据**</span><br></pre></td></tr></table></figure>
<pre><code> DataSupport.deleteAll(Book.class,&quot;price&gt;?&quot;,&quot;17&quot;);
第一个参数是指定表，后面的参数是指定参数的数据项的属性。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**查询数据**  </span><br><span class="line"></span><br><span class="line">注：     </span><br><span class="line"> for (Book book:bookList)的意思是循环bookList集合，每次取得的实例就给Book book；</span><br><span class="line"></span><br><span class="line">List&lt;Book&gt; bookList=DataSupport.findAll(Book.class);    </span><br><span class="line"></span><br><span class="line">findAll()返回的是一个List集合。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**常用的查询API**</span><br><span class="line"></span><br><span class="line">- 查询第一条数据  </span><br><span class="line"></span><br><span class="line">      Book book =DataSupport.findFirst(Book.class);  </span><br><span class="line"></span><br><span class="line">- 查询最后一条数据  </span><br><span class="line"></span><br><span class="line">        Book book =DataSupport.findLast(Book.class);  </span><br><span class="line"></span><br><span class="line">- select()方法可以指定查询那几列的数据。  </span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookList =DataSupport.select(&quot;name&quot;,&quot;pages&quot;).find(Book.class);</span><br><span class="line"></span><br><span class="line">- where()方法可以指定查询的约束条件   </span><br><span class="line"></span><br><span class="line">         List&lt;Book&gt; bookList =DataSupport.where(&quot;name=?&quot;,&quot;bianxiaofeng&quot;).find(Book.class);  </span><br><span class="line"></span><br><span class="line">- order()方法可以指定结果的排序方式  </span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookList =DataSupport.order(&quot;pages desc&quot;).find(Book.class);</span><br><span class="line"></span><br><span class="line">- limit()方法可以指定结果的数量  </span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookList =DataSupport.limit(3).find(Book.class);</span><br><span class="line"></span><br><span class="line">还可以对所有的方法进行连缀组合操作。  </span><br><span class="line"></span><br><span class="line"># 第七章 内容提供器</span><br><span class="line"></span><br><span class="line">## 1、内容提供器主要在不同的应用程序之间实现数据共享的功能。使用内容提供器是Android跨程序共享数据的标准方式。  </span><br><span class="line">## 2、运行时权限  </span><br><span class="line">    权限分为普通权限和危险权限。危险权限分为9组24个。每一个危险权限都属于一个权限组，一旦用户同意了某个权限组的一个权限，则对应的权限组都可以被获得权限。  </span><br><span class="line">    </span><br><span class="line">**步骤：**  </span><br><span class="line"></span><br><span class="line">- 第一步需要判断用户是不是已经授权了。借助的是**ContextCompat.setSelfPermission(Context context,String permission)**方法。此方法接收两个参数：第一个是Context上下文，第二个是具体的权限名。   </span><br><span class="line"> Manifest.permission.···。使用方法的返回值和**PackageManager.PERMISSION_GRANTED**作比较，相等就表示已经授权。不相等就表示没有授权(相当于：**PackageManager.PERMISSION_DENIED**)。</span><br><span class="line"></span><br><span class="line">如果授权的话就执行具体的逻辑。如果不等的话就说明还没有得到用户的权限的同意，这个时候需要申请用户的权限。</span><br><span class="line"></span><br><span class="line">调用**ActivityCompat.requestPermission(Activity activity,String[] permissions,int requestCode)**方法来向用户申请权限。requrestPermission接受三个参数，第一个参数是要求的Activity实例，第二个参数是String数组，这里需要把要申请的权限名写在里面，第三个是请求码，需要唯一。在这个方法中判断是否得到授权。</span><br></pre></td></tr></table></figure>
<pre><code>//申请权限
if (ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission
                       .CALL_PHONE)!=PackageManager.PERMISSION_GRANTED){
                   ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest
                           .permission.CALL_PHONE},1);
               }else {
                  //do something else
               }
@Override
   public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
                                          @NonNull int[] grantResults) {
           switch (requestCode){
               case 1:ssss
                   if (grantResults[0]==PackageManager.PERMISSION_GRANTED){
                       //do something else.
                   }else{
                       Toast.makeText(MainActivity.this,&quot;failed!&quot;,Toast.LENGTH_LONG).show();
                   }
           }
   }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3、contentResolver的基本用法</span><br><span class="line">对于一个应用程序来说，如果访问内容提供器中的共享的数据，就一定要借助ContentResolver类。可以通过getContentReslover来获取该类的实例。  </span><br><span class="line"></span><br><span class="line">使用inset()用于添加数据。update()用于更新数据。delete()用户删除数据。queny()用于查询数据。ContentReslover的增删查改需要接受Uri对象作为参数。  </span><br><span class="line"></span><br><span class="line">和数据库的操作一样是使用ContentValues作为中转传数据。调用CRUD函数进行操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## contentProvider内容提供者</span><br><span class="line">&gt; Android 的ContentProvider的底层是Binder机制。</span><br><span class="line"></span><br><span class="line">### 统一资源标识符（URI）</span><br><span class="line"></span><br><span class="line">URL：Uniform Resource Identifier  </span><br><span class="line">作用：  </span><br><span class="line">唯一标识ContentProvider中的数据。其他进程通过URI找到对应的ContentProvider其中的数据，再进行数据操作。  </span><br><span class="line"></span><br><span class="line">自定义</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">URI=content：//com.dimple.provider/user/1</span><br><span class="line">    -------    ------------------  ---  --</span><br><span class="line">    主题名          授权信息        表名 记录</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">- 主题名（Schema）：ContentProvider的URL前缀</span><br><span class="line">- 授权信息（Authority）：ContentProvider的唯一标识符,用于区分不同的ContentProvider。  </span><br><span class="line">- 表名（Path）：ContentProvider指向数据库中的某个表名用于区分ContentProvider的不同的数据表。  </span><br><span class="line">- 记录（ID）：表中的某个记录，用于区分表中的不同数据。  </span><br><span class="line"></span><br><span class="line">### 主要方法：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 第八章 运用手机多媒体</span><br><span class="line">## 1、使用通知Notification  </span><br><span class="line">使用通知的步骤  </span><br><span class="line">首先需要一个NotificationManager来对通过通知进行管理，可以调用Context的**getSystemService(String name)**方法来获取到。  </span><br><span class="line">**getSystemService(String name)**方法接受一个字符串参数用于确定获取系统的哪一个服务。这里传入**Context.NOTIFICATION_SERVICE**即可</span><br></pre></td></tr></table></figure>
<pre><code>NotificationManger manager=(NotificationManager)Context.getSystemSerice(Context.NOTIFICATION_SERVICE);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来需要一个Builder构造器来创建Notification对象（为了实现兼容，使用v4包的NotificationCompat类)</span><br></pre></td></tr></table></figure>
<pre><code>Notification notification=new NotificationCompat.Builder(this)
        .setContentTitle(&quot;Titile&quot;)
        .setContentText(&quot;content&quot;)
        .build();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">然后调用一系列的set方法对这个实体类进行设置。最后调用manager的**notify(int id,Notification notification)**方法，该方法接收两个参数，第一个参数是Notification的id，第二个参数是Notification的类。</span><br><span class="line">以上功能实现后就可以发送通知了，不过通知不可点击。如果需要点击需要PendingIntent</span><br><span class="line"></span><br><span class="line">注：PendingIntent和Intent的异同点：</span><br><span class="line"></span><br><span class="line">- 都可以指明一个意图，都可以用于启动活动，服务，以及发送广播。</span><br><span class="line"></span><br><span class="line">- Intent倾向于立即去执行某个动作，PendingIntent更加倾向在合适的时机去执行某个动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**pendingIntent的使用方法：**  </span><br><span class="line">使用静态方法获得PendingIntent的实例，**getActivity()**、**getBroadcast()**、**getService()**。  </span><br><span class="line"></span><br><span class="line">四个参数：content，0，Intent对象、0</span><br></pre></td></tr></table></figure>
<pre><code>Intent intent=new Intent(MainActivity.this,nextActivity.class);
PendingIntent pi=PendingIntent.getActivity(MainActivity.this,0,intent,0);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**不能这个通知写在OnClickListener的匿名内部类**</span><br><span class="line"></span><br><span class="line">## 2、调用摄像头</span><br></pre></td></tr></table></figure>
<pre><code>private void camera() {
       /**
        * 首先创建了一个File对象，用于存放摄像头拍下的图片，这里将图像命名为outputImage.jpg，并将它存放在手机的关联目录下、
        * 接着进行一个判断，如果设备系统的版本低于7.0 的话就，就调用Uri的fromFile()方法将File转化为Uri对象，这个Uri对象标识着outputImage这张图片的真实路径，否则
        * 就调用FileProvider的geUriForFile()将File转化成一个封装过的Uri对象。
        */
       File outputImage=new File(Environment.getExternalStorageDirectory(),&quot;output_image.jpg&quot;);
       try{
           if (outputImage.exists()) {
               outputImage.delete();
           }
           outputImage.createNewFile();
       } catch (IOException e) {
           e.printStackTrace();
       }
       if (Build.VERSION.SDK_INT&gt;=24){
           imageUri= FileProvider.getUriForFile(MainActivity.this,&quot;com.example.dimple.test619.fileProvider&quot;,outputImage);
       }else{
           imageUri=Uri.fromFile(outputImage);
       }
       Intent intent=new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);
       intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);//填入指定的文件输出地址
       startActivityForResult(intent,TAKE_PHOTO);
   }
@Override
   protected void onActivityResult(int requestCode, int resultCode, Intent data) {
       switch (requestCode) {
           case TAKE_PHOTO: {
               if (resultCode == RESULT_OK) {
                   try{
                       Bitmap bitmap= BitmapFactory.decodeStream(getContentResolver()//将图片解析为bitmap对象
                               .openInputStream(imageUri));
                       picture.setImageBitmap(bitmap);
                   } catch (FileNotFoundException e) {
                       e.printStackTrace();
                   }
​
               }
           }
           break;
           default:
               break;
       }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为用到了ContentProvider，所以需要在Manifest中注册</span><br></pre></td></tr></table></figure>
<pre><code>&lt;provider
            android:authorities=&quot;com.example.dimple.test619.fileProvider&quot;
            android:name=&quot;android.support.v4.content.FileProvider&quot;
           android:exported=&quot;false&quot;
           android:grantUriPermissions=&quot;true&quot;&gt;
           &lt;meta-data   //指定Uri的共享路径
               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
               android:resource=&quot;@xml/file_paths&quot;/&gt;
        &lt;/provider&gt;
    &lt;/application&gt;
​
&lt;/manifest&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新建XML文件</span><br></pre></td></tr></table></figure>
<pre><code>&lt;?xml version =&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
    &lt;path xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;external-path name=&quot;my_images&quot; path=&quot;&quot;/&gt;
&lt;/path&gt;  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3、播放音频</span><br><span class="line">在Android中播放音频文件一般都是使用MediaPayer来实现的，它对多种格式的音频文件提供了非常全面的控制方法，使得音频播放比较简单。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    方法名        	功能描述    	  备注    </span><br><span class="line">    setDataSource()    	设置要播放的文件的地址    	</span><br><span class="line">    prepare()    	在开始播放之前调用这个方法完成准备工作    	</span><br><span class="line">    start()    	开始播放视频    	</span><br><span class="line">    pause()    	暂停播放音频    	</span><br><span class="line">    reset()    	将Mediaplayer对象重置为刚开始创建的状态    	</span><br><span class="line">    seekTo()    	从指定的位置开始播放音频    	</span><br><span class="line">    stop()    	停止播放音频    	</span><br><span class="line">    release()    	释放掉与MediaPlyer相关的资源    	</span><br><span class="line">    isPlaying()    	判断当前MediaPlayer是否在播放    	</span><br><span class="line">    getDuration()    获取之路的音频文件的时长	</span><br><span class="line"></span><br><span class="line">## 4、播放视频</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    方法名	           功能描述    	  备注    </span><br><span class="line">    setVideoPat()   设置要播放的视频文件的地址        	</span><br><span class="line">    start()    	开始或继续播放视频    	</span><br><span class="line">    pause()    	暂停播放视频    	</span><br><span class="line">    resume()    	将视频从头播放    	</span><br><span class="line">    isPlaying()    	是否正在播放    	</span><br><span class="line">    getDuration()    	获取时长	</span><br><span class="line">    seekTo()    	从指定的位置开始播放	</span><br><span class="line">    XML中包含VideoView。</span><br><span class="line">    通过VideoView来进行操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第九章 使用网络技术</span><br><span class="line">## 1、WebView 的用法</span><br><span class="line"></span><br><span class="line">获取WebView的实例，通过getSetting()方法对浏览的相关属性进行设置。调用setJavaScriptEnabled()方法来让WebView支持JavaScript脚本。调用wenViewClient()方法。是希望网页依然在本程序中，不然就会跳转出去。</span><br><span class="line"></span><br><span class="line">## 2、使用HTTP协议访问网络</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先开启一个子线程，在子线程中进行网络数据请求操作，获取HttpRULConnection实例。</span><br></pre></td></tr></table></figure>
<pre><code>URL url=new URL(&quot;https://www.baidu.com&quot;);
HttpURLConnection connection==(HttpURLConnection)url.openConnection();
connection.setConnectionTimeOut(8000);//设置链接超时
connection.setReadTimeOut(8000);//设置读取超时
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后再调用getInputStream()方法获取到服务器返回的流，然后进行流读取。</span><br></pre></td></tr></table></figure>
<pre><code>ImputStream in=connection.getInputStream();
//下面进行流读取
BufferedReader reader=new BufferedReader(new InputStreamReader(in));
String line;
StringBuilder builder=new StringBuilder();
while((line=reader.readerLine())!=null){
  builder.append(line);
}

最后关闭链接
connection.disconnect();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3、使用OkHttp  </span><br><span class="line"></span><br><span class="line">在app/build.grade中dependencies中添加如下内容：</span><br></pre></td></tr></table></figure>
<pre><code>compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具体使用步骤：  </span><br><span class="line">创建一个OkHttpClient实例</span><br></pre></td></tr></table></figure>
<pre><code>OkHttpClient client=new OkHttpClient();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来如果需要发起一条Http请求，需要创建一个Request对象</span><br></pre></td></tr></table></figure>
<pre><code>Request request=new Request.Builder().build();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上代码创建了一个空的Request对象，没有什么实际作用，在build()方法之前加入很多连缀来丰富这个request对象，可以使用uri()方法来设置目标网络地址。  </span><br><span class="line"></span><br><span class="line">之后调用OkHttpClient的newCall()方法来创建一个Call对象，并调用它的execute()方法来发送请求并获得服务器的数据.</span><br></pre></td></tr></table></figure>
<pre><code>Response response=client.newCall(request).execute();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中Resopnse就是服务器返回的数据了，以下方法可以得到具体的内容</span><br></pre></td></tr></table></figure>
<pre><code>String responseData=response.body().string();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送数据：  </span><br><span class="line"></span><br><span class="line">首先需要构建出一个RequestBody对象来存放待提交的数据。</span><br></pre></td></tr></table></figure>
<pre><code>ResquestBody requestBody=new FormBody.Builder().add(&quot;username&quot;,&quot;admin&quot;).add(&quot;password&quot;,&quot;123456&quot;).build();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">接下来就和Get请求一样了，调用execute()方法来获得服务器返回的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4、解析JOSN数据</span><br><span class="line"></span><br><span class="line">http://mobileapi.72g.com/index.php?tp=andv4/quan&amp;op=qinfo</span><br><span class="line"></span><br><span class="line">## 5、解析Json数据</span><br><span class="line"></span><br><span class="line">首先配置服务器：电脑端访问网址为127.0.0.1 模拟器访问端网址：10.0.2.2</span><br><span class="line"> </span><br><span class="line">**使用JsonObject：**  </span><br><span class="line">首先将从服务器中的数据放在JSONArray中，然后循环遍历这个Json数组，从中取出的每一个元素都是JSONObject对象，调用getString()方法就可以取出数据。</span><br></pre></td></tr></table></figure>
<pre><code>JSONArray jsonArray=new JSONArray(response);
    for (int i=0;i&lt;jsonArray.length();i++){
        JSONObject jsonObject=jsonArray.getJSONObject(i);
        Log.d(&quot;TAG&quot;, &quot;Data :&quot;+jsonObject.getString(&quot;name&quot;)+jsonObject.getString(&quot;id&quot;)+jsonObject.getString(&quot;version&quot;));
 }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**使用Gson**  </span><br><span class="line">首先需要添加依赖</span><br></pre></td></tr></table></figure>
<pre><code>compile &apos;com.google.code.gson:gson:2.8.1&apos;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gson可以将一段Json格式的字符串自动映射成为一个对象，从而不需要我们编写代码进行解析。</span><br><span class="line"></span><br><span class="line">比如：一段json格式的数据如下  </span><br><span class="line">&#123;&quot;name&quot;：&quot;Tom&quot;，&quot;age&quot;:&quot;20&quot;&#125;  </span><br><span class="line">我们可以定义 一个Person类，并加入name和age两个字段。只需要简单的调用如下代码就可以将JSON数据自动解析成一个Person对象了。</span><br></pre></td></tr></table></figure>
<pre><code>Gson gson=new Gson();
Person person=gson.fromJson(jsonData,Person.class)  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果解析的是一段json数组就需要借助TypeToken将期望解析成的数据类型传入到fromJson中。</span><br></pre></td></tr></table></figure>
<pre><code>Gson gson=new Gson();
 List&lt;App&gt;appList=gson.fromJson(response,new TypeToken&lt;List&lt;App&gt;&gt;(){}.getType());
for (App app:appList){
  Log.d(&quot;TAG&quot;, &quot;run: &quot;+app.getId()+&quot;\n&quot;+app.getName()+&quot;\n&quot;+app.getVersion());
 }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义Okhttp工具类</span><br></pre></td></tr></table></figure>
<pre><code>public class HttpUtility {
   public static void senOkHttpRequest(String address,okhttp3.Callback callback){
       OkHttpClient client=new OkHttpClient();
       Request request=new Request.Builder().url(address).build();
       client.newCall(request).enqueue(callback);
   }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在调用工具类的时候就这样写：</span><br></pre></td></tr></table></figure>
<pre><code>HttpUtility.senOkHttpRequest(&quot;http://10.0.2.2/me.json&quot;, new okhttp3.Callback() {
           @Override
           public void onFailure(Call call, IOException e) {
//                T网络请求失败&quot;相关逻辑
           }
​
           @Override
           public void onResponse(Call call, Response response) throws IOException {
//                网络请求成功相关逻辑
               String responseData=response.body().string();
               showResponse(responseData);
           }
       });
</code></pre><p>```</p>
<h1 id="第12章-Material-Design"><a href="#第12章-Material-Design" class="headerlink" title="第12章 Material Design"></a>第12章 Material Design</h1><h2 id="1、ToolBar代替ActionBar"><a href="#1、ToolBar代替ActionBar" class="headerlink" title="1、ToolBar代替ActionBar"></a>1、ToolBar代替ActionBar</h2><p> 需要在Manifest中设置主题为NoActionBar  </p>
<pre><code>&lt;android.support.v7.widget.Toolbar
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;?attr/actionBarSize&quot;
       android:id=&quot;@+id/toolBar&quot;
       android:background=&quot;@color/colorPrimary&quot; /&gt;
Toolbar toolbar = (Toolbar) findViewById(R.id.toolBar);
       setSupportActionBar(toolbar);
</code></pre><p>扩展：在ToolBar中添加其他控件<br>新建menu文件夹，在其中添加Menu resourse file，创建一个xml文件。  </p>
<pre><code>&lt;item  
       android:id=&quot;@+id/delete&quot;
       android:icon=&quot;@drawable/wujiaoxing&quot;//指定按钮的图标
       android:title=&quot;@string/delete&quot;//指定按钮的文字
       app:showAsAction=&quot;always&quot; /&gt;//指定按钮的显示位置。always表示永远显示再ToolBar中，如果屏幕不够就不显示
                                   nerver表示永远显示再菜单项中，ifRoom表示屏幕空间足够的情况下就显示在ToolBar中，如果不够的话就显示在菜单项中。
​
</code></pre><p>在MainActivity中重写onCreateOptionMenu方法显示出menu，使用onOptionsItemSelected()方法来响应点击事件。</p>
<h2 id="2、滑动菜单——DrawerLayout"><a href="#2、滑动菜单——DrawerLayout" class="headerlink" title="2、滑动菜单——DrawerLayout"></a>2、滑动菜单——DrawerLayout</h2><p>首先它是一个布局，在布局中只允许放入 两个直接控件，第一个子控件是主屏幕显示的内容，第二个子控件是滑动菜单栏显示的内容。</p>
<p>使用  </p>
<pre><code>&lt;android.support.v4.widget.DrawerLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre><p>注意：</p>
<p>第二个子控件需要设置android:layout_gravity=””，需要告诉DrawerLayout菜单是再屏幕的右边还是左边  </p>
<pre><code>android:layout_gravity=&quot;start&quot;  
</code></pre><p>使用ToolBar的最左边加入导航按钮。  </p>
<pre><code>ActionBar actionBar=getSupportActionBar();//获取ActionBar的实例，这个实例的具体提现是由ToolBar来实现的。


       if (actionBar!=null){
           actionBar.setDisplayHomeAsUpEnabled(true);//显示导航键
           actionBar.setHomeAsUpIndicator(R.drawable.meiyuan);//设置导航键的图标。这个图标叫做HOMEAsUp
       }
</code></pre><p>在onOptionsItemSelected()方法来对HomeAsUp按钮的点击事件，HomeAsUp的id是<br>android.R.id.home  </p>
<p>然后调用DrawerLayout的openDrawert()方法将滑动菜单显示出来。  </p>
<h2 id="3、NavigationView"><a href="#3、NavigationView" class="headerlink" title="3、NavigationView"></a>3、NavigationView</h2><p>NavigationView是DesignSupport库中提供的一个控件。</p>
<p>使用的时候需要添加闭包关系  </p>
<pre><code>compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;
compile &apos;com.android.support:design:26.0.0-alpha1&apos;
</code></pre><p>在使用Navigation之前，需要准备两个东西，menu和headLayout </p>
<p>menu是在navigationView中显示菜单项的，headLayout是在NavigationView中显示头部布局的。</p>
<p>头部布局中使用circleImage来设置圆形头像。</p>
<p>设置完毕后在MainActivity中添加  </p>
<pre><code>&lt;android.support.design.widget.NavigationView
       android:id=&quot;@+id/nav_view&quot;
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;match_parent&quot;
       android:layout_gravity=&quot;start&quot;
       app:headerLayout=&quot;@layout/nav_header&quot;
       app:menu=&quot;@menu/nav_menu&quot; /&gt;
</code></pre><p>同时可以设置监听  </p>
<pre><code>public boolean onNavigationItemSelected(@NonNull MenuItem item)
</code></pre><h2 id="4、悬浮按钮和可交互提示"><a href="#4、悬浮按钮和可交互提示" class="headerlink" title="4、悬浮按钮和可交互提示"></a>4、悬浮按钮和可交互提示</h2><p><strong>悬浮按钮</strong>  </p>
<p>添加FloatActionButton布局  </p>
<pre><code>&lt;android.support.design.widget.FloatingActionButton
    android:id=&quot;@+id/floatButton&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;bottom|end&quot;
    app:elevation=&quot;8dp&quot;设置悬浮高度
    android:layout_margin=&quot;10dp&quot;
    android:src=&quot;@drawable/meiyuan&quot; /&gt;
</code></pre><p>setOnClickListener可以设置点击事件</p>
<p><strong>可交互提示：SnakeBar</strong>  </p>
<pre><code>Snackbar.make(view,&quot;Date Deleted&quot;,Snackbar.LENGTH_LONG)   //make方法创建了一个Snake对象，第一个 参数需要传入一个人View，只要是当前界面的任意一个View都可以，第二个参数是SnakeBar中显示的内容，第三个是显示的时长
                    .setAction(&quot;Un Do&quot;, new View.OnClickListener() {//调用setAction来设置一个动作，从而让SnakeBar不仅仅是一个提示，而是可以和用户进行交互的//第一个是按钮的名字，第二个是点击事件。
                        @Override
                        public void onClick(View view) {
                            Toast.makeText(MainActivity.this, &quot;Un Do Successed!&quot;, Toast.LENGTH_SHORT).show();
                        }
                    }).show();
</code></pre><p>调用setAction来设置一个动作，从而让SnakeBar不仅仅是一个提示，而是可以和用户进行交互的//第一个是按钮的名字，第二个是点击事件。  </p>
<p>出现界面重叠，需要使用CoordinatorLayout来替换掉FrameLayout，它可以监听所有子控件的所有事件，从而自动做出合理的响应。  </p>
<h2 id="5、卡片式布局"><a href="#5、卡片式布局" class="headerlink" title="5、卡片式布局"></a>5、卡片式布局</h2><p>添加依赖：  </p>
<pre><code>compile &apos;com.android.support:recyclerview-v7:26.0.0-alpha1&apos;
compile &apos;com.android.support:cardview-v7:26.0.0-alpha1&apos;
compile &apos;com.github.bumptech.glide:glide:4.0.0-RC1&apos;
</code></pre><p>Glide是一个强大的图片加载库，它不仅可以加载本地图片，还可以加载网络图片，GIF图片，甚至是本地视频。  </p>
<p>具体操作见recyclerView，只是将recyclerView 的子项布局的外层布局改为CardView</p>
<p>这种会将ToolBar遮盖，使用AppBarLayout<br>使用AppBarLayout包裹ToolBar，同时指定RecyclerView的布局行为  </p>
<pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
</code></pre><p>同时还可以设置滑动隐藏<br>在toolBar中加入  </p>
<pre><code>app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;
</code></pre><p>scroll表示RecyclerView向上滑动的时候，ToolBar会一起向上隐藏，enterAlways表示向下滚动的时候，ToolBar会同步显示。snap表示还没有完全隐藏的时候，会自动向上向下偏移。</p>
<h2 id="6、下拉刷新"><a href="#6、下拉刷新" class="headerlink" title="6、下拉刷新"></a>6、下拉刷新</h2><p>SwipeRefreshLayout就是用于下拉刷新的核心类。使用《swipeRefreshLayout》包裹需要下拉刷新的部件。  </p>
<pre><code>wipeRefresh.setColorSchemeResources(R.color.colorPrimary);
       swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
           @Override
           public void onRefresh() {
               refreshFuite();
           }
       });  
</code></pre><h2 id="7、可折叠标题栏ColapsingToolbarLayout"><a href="#7、可折叠标题栏ColapsingToolbarLayout" class="headerlink" title="7、可折叠标题栏ColapsingToolbarLayout"></a>7、可折叠标题栏ColapsingToolbarLayout</h2><p>colapsing不能独立存在，在设计的时候就只能用作AppBarLayout的直接子布局。而AppBarLayout又必须是CoordinatorLayout的子布局</p>
<p>DrawerLayout ——滑动菜单栏——只能拥有两个字节子布局（第一个是主屏幕的内容、第二个是滑动屏的内容）   </p>
<p>NavigationView——滑动菜单栏滑动屏布局（需要headLayout、和menu布局 （showAsAction））——需要Design Support库  </p>
<p>FloatActionButton——悬浮按钮  </p>
<p>SnakeBar——提示工具  </p>
<p>CoordinatorLayout——加强版的FrameLayout——监听子控件各种事件、自动做出合理的响应。防止控件重叠。  </p>
<p>CardView_FrameLayout——提供圆角和阴影效果（cardCornerRadius指定卡片的弧度，elevation指定卡片的高度）   </p>
<p>Glide——图片加载库  </p>
<p>AppBarLayout——解决FrameLayout中的默认位置为左上角造成的遮挡ToolBar——将ToolBar嵌套到AppBarLayout（    app:layout_scrollFlags=”scroll|snap|enterAlways”），然后给重叠的部件指定布局行为behaver  </p>
<p>SwipeRefreshLayout——下拉刷新——包裹需刷新的部件  </p>
<p>CollapsingToolbarLayout——可折叠标题栏——不能独立存在只能作为AppBarLayout的直接子布局、AppBarLayout必须是coordinatorLayout的子布局  </p>
<p>NestedScrollView——ScrollView——内部只能存在一个直接子布局  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是我的Android学习过程中整理的一些东西，重新再整理了一遍，也算是重新学习了一次，在重新学习的过程中，还是发现有很多不足不周到的地方。温故而知新，自己还记录了很多笔记，趁现在还时间充裕，还会再好好温习一下。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境]]></title>
      <url>/2018/01/19/2018-1-19%20153336/</url>
      <content type="html"><![CDATA[<h1 id="使用VSCode-七牛云图床插件-自定义快捷键配置Hexo博文编写环境"><a href="#使用VSCode-七牛云图床插件-自定义快捷键配置Hexo博文编写环境" class="headerlink" title="使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境"></a>使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我的电脑上安装了MarkdownPad++还有VSCode（主要是用来写前端的），VSCode也是可以写md文章的。之所以之前我是安装了MarkdownPad++，是因为它有一个可以上传图片的功能，再加上它还有一些VSCode没有的快捷键，所以一直是两个软件并存，直到今天重新捣鼓了一下，终于可以去掉MarkdownPad++了。不得不说VSCode确实很强大，更加难得的是支持中文，这使我对这个软件的好感度哧溜的加加加。 </p>
<p>特写下这个教程，方便同样是我这种情况的朋友。   </p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li>首先你得要有VSCode对吧，没有的话我也是附上链接：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Go</a>  </li>
</ul>
<ul>
<li>其次是在VSCode中安装一个预览MD文件的插件<code>Markdown Preview Enhanced</code>，这样写文章的时候能够做到实时预览了。  </li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155259.png" alt="{mdFileName}-2018119155259"></p>
<ul>
<li>为了能够最大程度的获得一些markdown的通用快捷键，这里可以下载一个<code>Markdown Shortcuts</code>插件，比如Ctrl+l插入链接、Ctrl+B加粗之类的。  </li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155358.png" alt="{mdFileName}-2018119155358">  </p>
<ul>
<li><p>最核心的一步——安装七牛云图床插件。</p>
<ul>
<li><p>安装插件<code>qiniu-upload-image</code>。<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155541.png" alt="{mdFileName}-2018119155541"></p>
</li>
<li><p>注册<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>（注册后需要认证，我的认证时间是半天。）<br>接着在<img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916325.png" alt="{mdFileName}-201811916325">新建对象存储。这里会有一个默认的【测试域名】，如果你的网站还没有备案的话，就用这个默认的吧。备案了的可以自定义域名。</p>
</li>
<li><p>配置VSCode过程 </p>
<ul>
<li>依次打开【文件】-【首选项】-【设置】</li>
<li>在【搜索设置】中搜索<code>qiniu</code>关键字</li>
<li>将【qiniu configuration】中的6个子设置从【默认设置】拷贝到【用户设置】<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155911.png" alt="{mdFileName}-2018119155911">  </li>
<li>其中的【AccessKey 签名授权】【SecretKey 签名授权】在<a href="https://portal.qiniu.com/user/key" target="_blank" rel="noopener">密钥管理</a></li>
<li>七牛图片上传空间是你的存储空间的名字，七牛图床域名为测试域名。</li>
</ul>
</li>
</ul>
</li>
<li><p>接着还想在VSCode里面直接完成部署功能。<br>有两种方法：</p>
<ul>
<li>1 安装<code>vscode-Hexo</code>插件 然后直接在命令面板中输入以下命令：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916939.png" alt="{mdFileName}-201811916939">  </li>
<li>2 按住Ctrl+` 在VSCode中弹出终端，也可以在这里面直接输入命令操作。<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119161338.png" alt="{mdFileName}-2018119161338"></li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>卸载掉MarkdownPad ，电脑又轻松了几百M。如果需要帮助的盆友请留言。</p>
<p>2018年5月29日12:32:48更新</p>
<p>最近收到读者给我发的邮件说会出现如下情况：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180529123226.png" alt="QQ截图20180529123226"></p>
<p>经过研究，这里出现的原因是因为快捷键冲突，因为七牛云的插件的默认设置是：</p>
<p><em>粘贴图片路径上传：SHIFT + P<br>直接选择图片上传：SHIFT + O</em></p>
<p>所以，在设置里面更改快捷键，比如我相关<strong>Ctrl+G</strong>表示上传图片。</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 七牛云图床，VSCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大学期间的视频文档]]></title>
      <url>/2018/01/17/2018-1-17%20162928/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>考完试恍恍惚惚，简直不敢相信大三已经又过去了一半了，时间是真的快。经历了前两天去西岭雪山玩的时候手机丢了的不愉快，决定好好整理了下大学做过的一些东西，做一个备份。  </p>
<h2 id="视频篇"><a href="#视频篇" class="headerlink" title="视频篇"></a>视频篇</h2><h3 id="成都大学信息科学与工程学院-2016年迎新晚会暖场视频"><a href="#成都大学信息科学与工程学院-2016年迎新晚会暖场视频" class="headerlink" title="成都大学信息科学与工程学院 2016年迎新晚会暖场视频"></a>成都大学信息科学与工程学院 2016年迎新晚会暖场视频</h3><p>这是我担任学生会科文部部长的时候带领小干事们做的一些东西。权当留个纪念吧，我相信这套视频，对于16级的小同学们来说有着特别的意义。 </p>
<embed src="http://player.video.qiyi.com/428f02012a8d2b16fd49c579b2cd0d6d/0/0/w_19rwhy0npt.swf-albumId=11158755709-tvId=11158755709-isPurchase=0-cnId=7" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">  




<h3 id="成都大学信息科学与工程学院学生会招新视频"><a href="#成都大学信息科学与工程学院学生会招新视频" class="headerlink" title="成都大学信息科学与工程学院学生会招新视频"></a>成都大学信息科学与工程学院学生会招新视频</h3><embed src="http://player.youku.com/player.php/sid/XMTY5NjQ5NTM4NA==/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">

<p>###《基于无线传感器网的物联网智慧农业系统》展示视频</p>
<p>这一套系统呢是由我担任硬件开发兼项目负责人，我的学长余悦担任软件开发，当时大一小朋友蒋蕊担任项目答辩。最好的成绩呢是获得了全国物联网大赛一等奖。</p>
<embed src="http://player.video.qiyi.com/9e817fa08135f87b24712d990d0e12de/0/0/w_19rwhxeq81.swf-albumId=11159832109-tvId=11159832109-isPurchase=0-cnId=30" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">  


<h3 id="来影——一款基于AR与3D的旅游软件项目展示"><a href="#来影——一款基于AR与3D的旅游软件项目展示" class="headerlink" title="来影——一款基于AR与3D的旅游软件项目展示"></a>来影——一款基于AR与3D的旅游软件项目展示</h3><p>这个是我担任Android开发以及项目负责人做的视频，获得了中星杯计算机作品大赛二等奖，计算机设计大赛，互联网+大赛的一些奖。</p>
<embed src="http://player.video.qiyi.com/d2e4f573be6687e53a8ffe0cb29ea7df/0/0/w_19rwhwxmw1.swf-albumId=11159064909-tvId=11159064909-isPurchase=0-cnId=7" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">





<p>还有很多给老师做的一些视频就不放上来了。  </p>
<h2 id="文档篇"><a href="#文档篇" class="headerlink" title="文档篇"></a>文档篇</h2><h3 id="OFFICE使用手册"><a href="#OFFICE使用手册" class="headerlink" title="OFFICE使用手册"></a>OFFICE使用手册</h3><h4 id="PPT使用手册"><a href="#PPT使用手册" class="headerlink" title="PPT使用手册"></a>PPT使用手册</h4><p><a href="https://pan.baidu.com/s/1c3T7Nf6" target="_blank" rel="noopener">PPT 使用手册</a>  </p>
<p><img src="https://i.imgur.com/UBnUHGw.png" alt=""></p>
<h4 id="Word使用手册"><a href="#Word使用手册" class="headerlink" title="Word使用手册"></a>Word使用手册</h4><p><a href="https://pan.baidu.com/s/1sneCBmt" target="_blank" rel="noopener">Word 使用手册</a>  </p>
<p><img src="https://i.imgur.com/2c4Zq8E.png" alt=""></p>
<h4 id="Excel使用手册"><a href="#Excel使用手册" class="headerlink" title="Excel使用手册"></a>Excel使用手册</h4><p><a href="https://pan.baidu.com/s/1pNaCVvt" target="_blank" rel="noopener">Excel 使用手册</a>  </p>
<p><img src="https://i.imgur.com/FycYtNl.png" alt="">  </p>
<p>洋洋洒洒的几十页，在成都大学信工学院的学生群里面传播，也希望能够实实在在的帮助到他们。 如果有需要的话可以直接下载了。   </p>
<h3 id="IT来袭策划书"><a href="#IT来袭策划书" class="headerlink" title="IT来袭策划书"></a>IT来袭策划书</h3><p>当然了，作为部长的我是经历了成都大学第八届、第九届、第十届的IT来袭的，覆盖全校的校级大型活动，作为负责人还是很辛苦的，也很感谢我身边的人，不管是我的老部长还有小干事们，还有帮助我们活动的各位老大们。  </p>
<p><img src="https://i.imgur.com/mAhepJa.png" alt="">    </p>
<p>链接：<a href="https://pan.baidu.com/s/1mkd0ScS" target="_blank" rel="noopener">https://pan.baidu.com/s/1mkd0ScS</a> 密码：0hdb  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是有一些感触的，很多视频做的时候就完全不知道怎么做，逼出来的，现在看看还是很不错的。权当留个纪念吧，自己的电脑是一日不如一日，不知道什么时候就彻底歇逼了。对于IT来袭活动，印象应该是最深的了吧。我全程陪伴，全程关注。分配了任务，我会一点一点的督促落实，也得到了各位老师同学的肯定，参与人数达历史新高，近2000人。<br>科文部确实是一个很好的部门，带给人的影响积极而无声。</p>
]]></content>
      
        <categories>
            
            <category> 大学资料 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 成都大学信工学院迎新晚会视频 </tag>
            
            <tag> 成都大学 </tag>
            
            <tag> 基于无线传感器网的物联网智慧农业系统 </tag>
            
            <tag> 来影——一款基于AR与3D的旅游软件项目展示 </tag>
            
            <tag> OFFICE使用手册 </tag>
            
            <tag> IT来袭策划书 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo-NexT主题添加评论功能（来必力、Hypercomments、畅言、友言）]]></title>
      <url>/2018/01/17/2018-01-17%20102253/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近捣鼓着博客的评论功能，看到很多形形色色的评论插件，比如来必力，畅言等等之类的。功能是各不一样，网上教程是关于某一类的评论插件的介绍，不是很全面，所以本文主要是弄一个全面的评论插件集成，然后分别说一下各自的优点以及不足，千挑万选之后总有一个适合你。<br>我使用的是NexT主题，NexT主题是集成了评论功能的。所以这里就直接是以NexT主题为例了。  </p>
</blockquote>
<h1 id="多说"><a href="#多说" class="headerlink" title="多说"></a>多说</h1><p>多说的功能还是很强大的，加上很早之前就有了各种社交途径的分享，很受大家喜爱。虽然多说在2017年6月1日正式停止，但是还是纪念下多说吧。虽然我没有用过，但是我在一些技术交流群中还是听到很多人在说多说。<br><img src="https://i.imgur.com/IcR5S7r.png" alt="">  </p>
<h1 id="Hypercomments"><a href="#Hypercomments" class="headerlink" title="Hypercomments"></a>Hypercomments</h1><blockquote>
<p>Communication is Empathy.<br>Tailored comment system for your site.    </p>
</blockquote>
<p><img src="https://i.imgur.com/BgAR237.png" alt=""></p>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>这是一个国外的评论系统，总的来说，界面设计等等还是很不错的。在NexT主题中操作也还算简单，事实上所有的评论在NexT上的操作都还是很简单的。  </p>
<p>但是这个界面是繁体中文的，目前我还没有找到改为简体中文的方法，看着是有一点难受。这个呢，可以<strong>匿名评论</strong>，说到匿名评论其实做的还是不错的，匿名评论可以添加能够联系到你的邮箱地址，这样当有人回答你的时候有邮件提醒。不得不说这点还是不错的。  </p>
<h2 id="添加Hypercomments评论"><a href="#添加Hypercomments评论" class="headerlink" title="添加Hypercomments评论"></a>添加Hypercomments评论</h2><ol>
<li>在<a href="https://www.hypercomments.com/" target="_blank" rel="noopener">Hypercomments</a>官网登录，目前只支持谷歌账号登录，国内有万里长城阻隔，翻墙注意安全！</li>
<li>选择Lite版本，点击Install。<img src="https://i.imgur.com/gsT39R9.png" alt=""></li>
<li>在设置中（齿轮图标的那个），点击Widget，然后在代码框中找到<code>Widget_id</code>，记录下来。</li>
<li>在NexT主题的配置文件<code>—config</code>中搜索hypercomments_id，然后去掉前面的#号，冒号后面加一个空格填入上面记录的Id。</li>
<li>部署就能看到效果。</li>
</ol>
<h2 id="参考界面"><a href="#参考界面" class="headerlink" title="参考界面"></a>参考界面</h2><ol>
<li>评论效果：  <img src="https://i.imgur.com/448OmUd.png" alt=""></li>
<li>匿名评论界面：<img src="https://i.imgur.com/zdUopLe.png" alt=""></li>
<li>Lite Demo ：<a href="https://www.hypercomments.com/en/demo?type=blogs" target="_blank" rel="noopener">Demo</a></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>繁体中文看的我是很难受。虽然只有几行而已。优点呢是评论可以匿名，可以评论上传图片、影片等。功能还是比较强大，设置界面是英文，且没有中文支持！</p>
<h1 id="畅言"><a href="#畅言" class="headerlink" title="畅言"></a>畅言</h1><p><img src="https://i.imgur.com/TxLKDXM.png" alt=""></p>
<blockquote>
<p>畅言是业内领先的社会化评论系统，支持PC和移动端两种接入方式，为网站提供了一种全新的评论方式。畅言拥有多种常用账号登录、三重过滤机制、实时的数据统计、快捷数据导出、全面支持移动端等领先功能。充分满足了当前各大网站对于用户登录、评论、分享 、审核等方面的需求。<br>畅言在业内率先实现三重过滤机制。当评论数据产生后，首先经过搜狐垃圾过滤系统，防灌水、防垃圾、防广告；然后经过官方提供违禁词库和站长自定义的敏感词过滤；最后是网站的自主审核，所有畅言合作网站都有专属的管理后台，管理所有本网评论。网站对本站评论拥有完全的管理，可以设置先发后审与先审后发等多种审核形式。  </p>
</blockquote>
<h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><ol>
<li>注册畅言  <a href="https://changyan.kuaizhan.com/" target="_blank" rel="noopener">Go</a></li>
<li>将畅言密钥复制到NexT主题的配置文件<code>—config</code>中，搜索changyan，填写下面的代码，注意替换成你的代码。</li>
</ol>
<pre><code># changyan
changyan:
  enable: true
  appid: yourid
  appkey: yourkey
</code></pre><h2 id="参考界面-1"><a href="#参考界面-1" class="headerlink" title="参考界面"></a>参考界面</h2><p> 1.畅言后台 <img src="https://i.imgur.com/Kpb83UA.png" alt=""><br> 2.评论登录后需要手机号码验证：<img src="https://i.imgur.com/TsA80yh.png" alt=""><br> 3.评论界面：<img src="https://i.imgur.com/C9JCqzJ.png" alt="">  </p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p> 关于畅言，大家可能印象最深的是灌水功能了，这个功能目前已经是出于失灵与半失灵的状态，官方估计也没怎么维护了。最难受的是，需要手机号验证，这也就阻挡了大部分的评论者。如果能够添加一个像Hypercomments的匿名功能的话，可能会好很多。最最重要的是，畅言是需要你的备案号的，就是说，你一个没有备案的网站是没法长时间使用畅言的。</p>
<h1 id="友言"><a href="#友言" class="headerlink" title="友言"></a>友言</h1><p> <img src="https://i.imgur.com/F9aMLio.png" alt=""></p>
<blockquote>
<p>友言是一个简单而强大的社会化评论及聚合平台。用户可以使用社交账号一键评论同步至社交网络，将内容和自己的评论分享给好友。增加第三方网站用户活跃度，调动好友参与评论，帮助网站实现社会化网络优化SMO，有效提升网站社会化流量！  </p>
<h2 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h2><p>友言的添加方法也极其简单：</p>
</blockquote>
<ol>
<li>在<a href="http://www.uyan.cc" target="_blank" rel="noopener">友言官网</a>注册账号，得到用户ID</li>
<li>将友言ID复制到NexT主题的配置文件<code>—config</code>中，搜索youyan，将youyan_uid前面的#号去掉，将id填写到youyan_uid：后面。</li>
<li>部署到你的网站。</li>
</ol>
<p>PS：部署成功后可能不会立即显示你的网站，这个时候你去你的网站评论一下就行了。</p>
<h2 id="参考界面-2"><a href="#参考界面-2" class="headerlink" title="参考界面"></a>参考界面</h2><ol>
<li>留言评论界面<img src="https://i.imgur.com/LK7ij0Z.png" alt=""></li>
<li>后台管理界面：<img src="https://i.imgur.com/rWfmRzF.png" alt=""><img src="https://i.imgur.com/hsEwGrE.png" alt=""><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2>对于友言，我觉得确实是我比较喜欢的类型了，支持匿名评论功能（默认是关闭的，需要手动开启），但是匿名只是匿名，没有留联系方式的地方，这点我觉得还是有点不好。</li>
</ol>
<h1 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h1><p><img src="https://i.imgur.com/UEsZmFf.png" alt=""></p>
<blockquote>
<p>使用社交网站账户登录，免去注册过程。<br>提高用户的参与和沟通意愿。<br>管理/删除我的评论内容。<br>提供管理页面，管理网站文章及评论内容。</p>
</blockquote>
<h2 id="添加方法-2"><a href="#添加方法-2" class="headerlink" title="添加方法"></a>添加方法</h2><ol>
<li>在<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a>的官网上注册账号。</li>
<li>在<a href="https://livere.com/insight/myCode" target="_blank" rel="noopener">此处</a>获取data-uid。</li>
<li>打开NexT主题的配置文件<code>—config</code>中，搜索livere_uid，将livere_uid前面的#号去掉，将id填写到livere_uid：后面。</li>
</ol>
<h2 id="参考界面-3"><a href="#参考界面-3" class="headerlink" title="参考界面"></a>参考界面</h2><ol>
<li>设置界面<img src="https://i.imgur.com/dvonjM1.png" alt=""></li>
<li>数据分析界面<img src="https://i.imgur.com/NLFltb6.png" alt=""></li>
<li>体验Demo：<a href="https://livere.com/city-demo" target="_blank" rel="noopener">Demo</a></li>
</ol>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>如果大家仔细观察应该能发现这是韩国人的东西，但也正是因为这是外国人的东西，收到国内的各种条条框框的限制比较少。对于来必力，这个产品比较不错，首先界面美化上就比之前的几种类型要好很多。但是没有匿名评论，支持邮箱账号注册评论。</p>
<h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><p>考试之前就像写一篇博文来介绍这几类评论工具了，但是平时的时候没有特别认真听，导致那个时候一点时间都不敢耽搁。哎~。评论工具还有很多很多，如果需要的话，还是需要自己修改一些代码才行。就我个人感觉而言，我觉得Hypercomments、来必力还有友言都还不错，畅言需要备案。就看各位老铁们喜欢什么了。</p>
<p>顺便说一句，寒假快乐！</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next优化 </tag>
            
            <tag> Comment </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018React-Native环境安装及运行第一个demo]]></title>
      <url>/2018/01/07/2018-01-07%20121946/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android放下很久了，前段时间一直扎根于前端三大件（HTML、CSS、JavaScript）的学习，目的呢是想为之后的学习React Native学习做好准备。趁着离考试还有一段时间，也是重新走上Android开发的道路。<br>现在确实是移动设备占优，现在智能手机能够完成网页端很多的工作。大有一统江山的趋势。移动开发在未来的很长时间里面都是热门。<br>工欲善其事必先利其器，本文主要是结合自己的相关经验搭建开发环境，来开始关于React Native的第一篇博文。纵观网上的各种教程，还有官方的一些教程吧，写的是比较简略的，所以本文的定位是写一点比较详细的环境安装教程。  </p>
<h1 id="关于react-native"><a href="#关于react-native" class="headerlink" title="关于react native"></a>关于react native</h1><p>还是老规矩，介绍下这个东东吧。  </p>
<blockquote>
<p>React Native 是一个 JavaScript 的框架，用来撰写实时的、可原生呈现 iOS 和 Android 的应用。其是基于 React的，而 React 是 Facebook 的用于构建用户界面的 JavaScript 库，但是这里不是给浏览器解释的，而是为移动平台。换句话说：如果你是一名 web 开发者，你可以使用熟悉的框架和单一的 JavaScript 代码库，即 React Native来撰写清晰的、高效的移动应用。</p>
<p>相比较于 iOS 和 Android 原生的开发，React Native 提供更好的开发者体验。因为你的程序大多数都是 JavaScript，你可以从 web 开发中汲取大量的经验，比如能够立即“刷新”你的应用来查看你代码的修改。相比于在传统的应用开发中花很长的时间去等待构建的过程，会让人感觉这简直是天赐之物。</p>
<p>另外，React Native 还为开发者提供了智能的错误报告和标准的 JavaSript 调试工具，这些让移动开发更加的顺手。  </p>
</blockquote>
<p>确实现在的开发，RN在后面的很长时间是主流。毕竟原生开发存在着诸多问题，最大的问题是在用户体验上。废话不多说，进入正题。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装过程可以参考<a href="https://reactnative.cn/docs/0.51/getting-started.html" target="_blank" rel="noopener">React Native中文网</a><br>那你以为这样就完了吗？没有。</p>
<p>官方文档上面说了，必须安装的东西，其实有些东西是没有必要的，比如Chocolatey这个包管理器，下载速度及其慢，完了还不支持断点续传，网络一有波动就GG。</p>
<p>所以遇到按照官方的步骤配置的遇到错误的，到我这里来就对了。  </p>
<h2 id="Node-js以及Python安装"><a href="#Node-js以及Python安装" class="headerlink" title="Node.js以及Python安装"></a>Node.js以及Python安装</h2><p>这里需要用到的两个软件分别是Python2和Node.js（其中Python必须安装2.x.x版本，Node.js随便安装都无所谓）。</p>
<p>我们采用安装包的方式安装这两个软件，下载地址为：  </p>
<ul>
<li>Python：<a href="https://www.python.org/downloads/release/python-2714/" target="_blank" rel="noopener">Python2.7.14</a>  </li>
<li>Node.js:<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 8.9.4LTS</a></li>
</ul>
<p>安装过程一路默认就行，但是要注意，需要把Python的根目录添加到环境变量。C:\Python27  </p>
<p>其次，Node.js也是需要将其根目录配置到环境变量的。  </p>
<p>具体流程就不详细介绍了，如果有问题请询度娘。</p>
<h2 id="Yarn、React-Native安装"><a href="#Yarn、React-Native安装" class="headerlink" title="Yarn、React Native安装"></a>Yarn、React Native安装</h2><p>Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p>
<pre><code>npm install -g yarn react-native-cli
</code></pre><p>安装完yarn设置镜像源：</p>
<pre><code>yarn config set registry https://registry.npm.taobao.org --global
yarn config set disturl https://npm.taobao.org/dist --global    
</code></pre><p>PS：这里不设置也是可以的，亲测没有什么差别。  </p>
<h2 id="Android-Studio安装"><a href="#Android-Studio安装" class="headerlink" title="Android Studio安装"></a>Android Studio安装</h2><p>React Native是支持3.x版本的。所以博主是用的3.1的版本，这个版本的Android虚拟机做了些优化，无论是启动速度还是性能各个方面都很优秀。另外3.x出来快大半年了，还停留在2.3版本的朋友可以考虑给手中的AS升级了。   </p>
<p>关于Android Studio的安装我就不详细介绍了，官方教程写的还是很详细的，另外官方教程的安装步骤2.3和3.1的没有差别。</p>
<p>PS：这里再说一下，Java JDK不支持9.0版本的，我之前用的就是9.0版本，发现不兼容，果断换回了8.0.  </p>
<p>这里直接简述下安装过程，相信AS这种级别的软件安装不是很难吧。</p>
<p>下载地址：<a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio中文社区</a>  </p>
<ul>
<li>安装软件的步骤是一路Next就行，没有坑  </li>
<li>安装完成后打开AS，然后这里会下载一些组件，请保持网络连接。  </li>
<li>确保 Android SDK和Android Device Emulator选中  </li>
<li>打开软件后选择custom选项，接下来会叫你选择主题什么的，你开心就好  </li>
<li>这里SDK Components Setup 里面的东西全部选中，当然你要更改SDK的路径也是可以的  </li>
<li>安装完成后，在Android Studio的欢迎界面中选择Configure | SDK Manager。</li>
<li>在SDK Platforms窗口中，选择Show Package Details，然后在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。 </li>
<li>在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须包含有这个版本。当然如果其他插件需要其他版本，你可以同时安装其他多个版本）。然后还要勾选最底部的Android Support Repository.</li>
<li>将SDK的目录加到环境变量，单独配置Android SDK的tools和platform-tools目录添加到PATH变量中。 </li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>这个安不安装在现阶段是无所谓的，但是作为一个程序员，不用Git感觉就像村里没通电一样。  </p>
<h2 id="配置Android-Device-Emulator"><a href="#配置Android-Device-Emulator" class="headerlink" title="配置Android Device Emulator"></a>配置Android Device Emulator</h2><p>用过AS的可以跨过这一步。  </p>
<p>打开Android virture Devices Manager，然后新建就行了。</p>
<p><img src="https://i.imgur.com/7qNNXPo.png" alt=""><br><img src="https://i.imgur.com/NIRq9qi.png" alt=""><br><img src="https://i.imgur.com/5mIuNq2.png" alt=""></p>
<p>OK，到现在基本上环境是安装好了。接下来弄一个小小的demo测试下。  </p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在你合适的位置新建一个文件夹用来放置RN的文件。 在此处发开PowerShell（Shift+鼠标右键，选择PowerShell）。输入命令：  </p>
<pre><code>react-native init 你的项目名  
</code></pre><p><img src="https://i.imgur.com/LYH1nxn.png" alt=""></p>
<p>PS：这个下载过程有点长，我用的最短时间是0.25分钟，最长5分钟。  </p>
<p>接下来在cd进入你的项目，输入以下命令：（在此之前，需要打开模拟器）</p>
<pre><code>react-native run-android 
</code></pre><p>此时会弹出Node的命令行界面：</p>
<p><img src="https://i.imgur.com/IhR1EFS.png" alt="">  </p>
<p>稍等一会就会出现以下界面：   </p>
<p><img src="https://i.imgur.com/mcqwAJ6.png" alt="">  </p>
<p>代表安装成功。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是简单的简述了下我的配置RN的过程，路漫漫其修远兮。后面我会继续学习RN，同时还需要准备下算法学习备战蓝桥杯个人赛。记录下我的安装步骤，在安装的过程中也是需要耐心的，官方教程也不是万能宝典，还是要辩证的来看吧，使用包管理器确实下载很不方便，而且出了问题也不知道出在哪里，还是安装包直接点。如果在安装过程中有不懂的地方，欢迎留言评论。</p>
]]></content>
      
        <categories>
            
            <category> react-native学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react-native </tag>
            
            <tag> Android混合开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo内嵌html或者Js代码遇到的问题]]></title>
      <url>/2018/01/05/2018-01-05%20201655/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://i.imgur.com/3Ewq7e1.gif" alt=""><br>在没有遇到这个坑之前我是完全不知道原来markdown里面是可以嵌入html或者js代码运行的。好吧是我孤陋寡闻了。在了解了原来还有这种操作的时候，整个人是惊呆了。<img src="https://i.imgur.com/DxDVkwv.gif" alt="">，但想想也是，不然一个博客里面随随便便冒出一个<code>button</code>还能点击是怎么做出来的。  </p>
<h1 id="进坑过程"><a href="#进坑过程" class="headerlink" title="进坑过程"></a>进坑过程</h1><p><code>&lt;script type=&quot;text/javascript&quot;  alert(&quot;hello world！&quot;);&gt;</code></p>
<p>比如上面一段代码，写出来了，在<code>markdownpad</code>上面还是可以看到的，但是在<code>hexo</code>中就看不到了。此时脸上笑嘻嘻，心里<em>*</em>。（以上代码我是直接用``括起来的，如果没有扩起来的话，博文后面的内容是完全看不到的。）也是很奇怪这个东西，好像是因为hexo把MD文档全部按照它自己的语法编译了一次，这样就导致编译看起来效果不错，发布出去到处是坑。</p>
<p>昨晚上我写了一篇博文，<code>hexo g</code>的时候就宝一大堆错，我尝试在其报错的位置进行解决，但是左看右看确实没错。原来是因为hexo文档中的有js代码，引起了连锁反应。毕竟hexo到现在虽然很不错了，但是还有些问题。  </p>
<h1 id="脱坑过程"><a href="#脱坑过程" class="headerlink" title="脱坑过程"></a>脱坑过程</h1><p>遇事不决用谷歌，带着问题翻墙出去。结果发现没有人遇到和我一样的问题。难受。各个大佬群咨询，大佬们给出的建议都尝试了，还是没有办法。</p>
<p>卸载重装，我就差换电脑了，哈哈哈。 </p>
<p>好了，说下脱坑方法，在你的JS或者HTML代码前面加上4个空格，编译完美通过。</p>
<p>记录下我的经历，方便以后遇到同样问题的兄弟。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到问题不要慌。能够解决问题的程序员才是好程序员。不断的写bug，不断解决bug才是开发的乐趣。hexo是可以内嵌前端代码的，注意不要被这个坑了，好了，现在弄得差不多了，后面准备回归我的老本行了，写Android了。  </p>
<p>最近新发现了一个markdown编辑器，还不错，如果不是因为不支持上传图片的话，我就转过去了。我也和开发的人聊了下，准备接入图床或者七牛云的接口。据说是hexo定制的，现在hexo的github主页就挂的这个编译器。有需要的可以去试试。  </p>
<p>附上链接地址：<a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HEXOEditor </a>  </p>
<p>好了就到这里，踩了很多坑，不一一列出来了，大家有问题的话可以留言评论！</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo疑难杂症 </tag>
            
            <tag> hexo问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018最新版hexo+Github搭建个人博客教程（2018-09-10 更新）]]></title>
      <url>/2018/01/04/2018-01-04%20212731/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>现在是大三了，身边的甚多朋友技术都还不错，动不动就搭建自己的网站什么的。本着向大佬学习（zhuangbi）的心情，我也开始在阿里云上面买了一个云服务器（学生套餐9.9），使用phpstudy软件一键部署了一个web服务器。但是想想其实没什么用，我只是想找一个属于自己的个人博客而已。所以将目光转向了hexo。 经过很多的摸索，终于是做好了我的博客：<a href="http://bianxiaofeng.com" target="_blank" rel="noopener">http://bianxiaofeng.com</a>, 就像每个语言入门必写<code>hello world</code>一样，我也想把自己使用hexo的相关经历写下来，方便自己以后查阅也希望能够帮助到更多的朋友。  </p>
</blockquote>
<p>博主使用是Windows10操作系统，其他系统自测。</p>
<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>搭建的过程分为以下几步：  </p>
<ol>
<li>安装Node.js  </li>
</ol>
<ol>
<li>安装Git软件  </li>
</ol>
<ol>
<li>安装hexo博客框架  </li>
</ol>
<ol>
<li>测试本地运行（线下访问个人博客）  </li>
</ol>
<ol>
<li><p>部署到Coding以及GitHub上（线上访问个人博客）  </p>
</li>
<li><p>设置域名解析  </p>
</li>
<li><p>其他（写一篇新的博文，设置categories,tags）</p>
</li>
</ol>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Node.js下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>    </p>
<p>安装过程一路默认安装即可。   </p>
<p>详细安装文档参看：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-install-setup.html</a>  </p>
<h2 id="安装Git软件"><a href="#安装Git软件" class="headerlink" title="安装Git软件"></a>安装Git软件</h2><p>Git软件下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a>  </p>
<p>安装过程一路默认安装即可。 </p>
<p>关于更多的Git讲解参看：  </p>
<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a>  </p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 </p>
<p>Hexo官方网站：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装命令：  </p>
<pre><code>npm install -g hexo-cli  #-g表示全局安装
</code></pre><p><em>这里提一下：关于hexo的终端操作最好是在管理员模式下，读者可以采用<code>按住Shift然后再点击鼠标右键</code>选择弹出菜单的<code>在此处打开Powershell窗口</code>保证运行在管理员状态下。</em>  </p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>在电脑合适的位置新建一个文件夹存放博客。本文中取名为<code>Blog</code>文件夹。  </p>
<p>控制台命令行使用cd命令进入到Blog文件夹，输入以下命令进行初始化：  </p>
<pre><code>hexo init  # 初始化 
</code></pre><p>初始化完成之后，因为会出现有些依赖包未安装成功的情况，所以请再输入以下命令安装依赖包:  </p>
<pre><code>hexo install   # 安装依赖包  
</code></pre><h2 id="测试本地运行"><a href="#测试本地运行" class="headerlink" title="测试本地运行"></a>测试本地运行</h2><p>完成以上安装步骤后，便可以在本地预览博客效果了。  </p>
<p>输入以下命令：  </p>
<pre><code>hexo g   # 等同于hexo generate，生成静态文件
hexo s   # 等同于hexo server，在本地服务器运行
</code></pre><p>然后打开浏览器地址栏输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>便可以预览生成的博客框架雏形了。  </p>
<h2 id="部署到GitHub以及Coding上"><a href="#部署到GitHub以及Coding上" class="headerlink" title="部署到GitHub以及Coding上"></a>部署到GitHub以及Coding上</h2><blockquote>
<p>建立博客网站肯定是要让大家看到的，由于Github是歪果仁的网站，且禁止百度爬虫访问，所以会导致百度搜不到你的网站。所以我们要做好两手准备：国内采用Coding托管，国外采用GitHub托管。  </p>
</blockquote>
<p>分别注册GitHub以及Coding的账号。  </p>
<ul>
<li><p>GitHub网址如下：<a href="http://www.github.com" target="_blank" rel="noopener">http://www.github.com</a>  </p>
</li>
<li><p>Coding网址如下：<a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a>  </p>
</li>
</ul>
<h3 id="GitHub注册"><a href="#GitHub注册" class="headerlink" title="GitHub注册"></a>GitHub注册</h3><p>1、在GitHub首页点击<code>Start Project</code>  </p>
<p>2、创建Repository </p>
<p><img src="https://i.imgur.com/HKup5ys.png" alt="">  </p>
<p>PS：创建时，填写<code>Repository name</code>的时候，Repository name的格式必须为{user_name}.github.io，其中{user_name}必须与你的用户名一样，这是GitHub Pages的特殊命名规范（亲测不区分大小写）。</p>
<h3 id="Coding注册"><a href="#Coding注册" class="headerlink" title="Coding注册"></a>Coding注册</h3><blockquote>
<p>CODING 是国内专业的一站式云端软件服务平台，成立于 2014 年 2 月，总部位于深圳，并于北京、上海、成都、西雅图设立分部，已获得了 IDG 和光速的两轮投资共计 1500 万美元。旗下自主研发运营 Coding.net 云端开发协作平台，累积 25 万开发者，37 万个项目。在云计算时代，把代码托管、产品演示、WebIDE 等开发工具集成到浏览器中，免除繁杂的开发环境部署，节省成本，帮助软件开发者提高生产效率，并实现 “Coding Anytime Anywhere” 的愿景。2015 年 10 月，基于 Coding.net 的工具平台，CODING 推出云端软件众包服务平台 “码市”，旨在通过云端协作以及众包的方式提高软件交付的效率，帮助软件开发行业实现高效的资源匹配。</p>
<p>Coding.net 为开发者提供了免费的基础服务，包括但不限于 Git 代码托管，项目管理，Pages 服务，代码质量管理。您可以在 Coding.net 一站完成代码及代码质量，项目及项目人员的管理，Coding.net 让开发变得前所未有的敏捷和简单。</p>
</blockquote>
<p>Coding的仓库容量只有256M，但是用来发布博文是够了的。  </p>
<p>注册步骤没啥好说的。  </p>
<p>主要说一下创建仓库的时候（顺便说一句：Coding毕竟还是国内的，各方面比较适合国人的习惯，操作起来是比GitHub顺手点。 ）  </p>
<p>点击下面的“加号”创建一个仓库：  </p>
<p><img src="https://i.imgur.com/vanCb7s.png" alt="">  </p>
<p>然后输入项目名称以及项目描述：  </p>
<p><img src="https://i.imgur.com/0ze8avx.png" alt=""><br><em>此处的项目名称不像GitHub那样有着严格的命名规范，你可以按照你能想象到的方式输入。建议不要输入中文，不然后面会走的很安详。这里我是输入的自己的用户名作为项目名称。</em>  </p>
<p>开启Pages服务（步骤如下图）  </p>
<p><img src="https://i.imgur.com/F4nGZCc.png" alt=""><br>选择部署来源为<code>master分支</code>，然后点击<a href="http://username.coding.me/yourRepoName" target="_blank" rel="noopener"> http://username.coding.me/yourRepoName</a>就可以查看你的博客了，不过你点进去是404，因为你仓库里面啥都没有。  </p>
<p>到此，注册和创建仓库一步骤已经全部完成了。  </p>
<h3 id="部署到线上（GitHub和Coding）"><a href="#部署到线上（GitHub和Coding）" class="headerlink" title="部署到线上（GitHub和Coding）"></a>部署到线上（GitHub和Coding）</h3><blockquote>
<p>我看到很多博客上面说到配置文件的时候，没有区分站点配置文件和主题配置文件，这里我先说清楚。站点配置文件和主题配置文件名称都是一样的<code>_config.yml</code>，站点配置文件在网站根目录，主题配置文件在根目录下的theme文件的具体theme下的<code>_config.yml</code>。  </p>
</blockquote>
<h4 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h4><p>打开<code>_config.yml</code>到最后<code>deploy</code>选项：<br>配置如下：  </p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repo:
    github: https://github.com/DimpleFeng/dimplefeng.github.io.git,master
    coding: https://git.coding.net/DimpleFeng/test.git,master
</code></pre><p>注意：每个冒号后面都是有一个空格的，这是node的语法。  </p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>部署之前需要安装<code>git</code>部署插件，否则会提示<code>Deployer not found</code>错误。  </p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>安装完毕后控制台输入：  </p>
<pre><code>hexo g -d   
</code></pre><p>随后访问你的以下网址（注意替换）：</p>
<p><a href="yourName.github.io">yourName.github.io </a><br><a href="yourName.coding.me">yourName.coding.me </a>  </p>
<h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><blockquote>
<p>作为一个有梦想的程序员，总是希望拥有自己别具一格的域名，这怎么办呢，你可以选择购买域名，然后指向你的静态pages。具体怎么做呢，请看下面。  </p>
</blockquote>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>你可以在<a href="https://dnspod.cloud.tencent.com/?from=qcloudHpProductDns" target="_blank" rel="noopener">腾讯云</a>以及<a href="https://wanwang.aliyun.com/?utm_content=se_1101812" target="_blank" rel="noopener">阿里云</a>上购买你的域名。</p>
<p>我是分别在阿里云上和腾讯云上购买过域名。分别是<code>www.bianxiaofeng.top</code>和<code>www.bianxiaofeng.com</code>。<code>.top域名已经没有使用了（2元一年是相当的便宜）</code>，这里想说的是，这两个代理商的操作模式有些不同。  </p>
<h3 id="设置域名解析-1"><a href="#设置域名解析-1" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>这里我分别以阿里云和腾讯云的举例：</p>
<h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><p>进入<a href="https://console.cloud.tencent.com/domain/mydomain" target="_blank" rel="noopener">腾讯云DNS解析网站</a>，然后是点击解析。<img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122142027.png" alt="{mdFileName}-2018122142027">  </p>
<p>添加如图所示的几条解析指令。  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122142345.png" alt="{mdFileName}-2018122142345">  </p>
<p>注意：此处的记录名是github填写你的仓库名，Coding按照我上面的填写。  </p>
<h4 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h4><p>进入<a href="https://dc.console.aliyun.com/dns/" target="_blank" rel="noopener">阿里云DNS解析网站</a>点击解析设置：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122143222.png" alt="{mdFileName}-2018122143222">  </p>
<p> 添加以下几条解析命令：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122143452.png" alt="{mdFileName}-2018122143452"></p>
<h2 id="设置Coding和GitHub"><a href="#设置Coding和GitHub" class="headerlink" title="设置Coding和GitHub"></a>设置Coding和GitHub</h2><p>按照上面的步骤添加完毕之后，分别设置Coding和GitHub的指向。  </p>
<h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>打开Coding，然后点击你的网站仓库，按照下面的步骤，添加你的域名  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122143916.png" alt="{mdFileName}-2018122143916"></p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>在你的博客的文件夹中找到Source文件夹，在里面加添一个CNMAE的文件，文件内容为你的域名，比如我的就是：<code>bianxiaofeng.com</code>  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122144052.png" alt="{mdFileName}-2018122144052"></p>
<p>OK ,大功告成，你可以通过你的域名访问你的网站了。<a href="http://www.bianxiaofeng.com">Dimple</a></p>
<p>###</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="写一篇新的博文"><a href="#写一篇新的博文" class="headerlink" title="写一篇新的博文"></a>写一篇新的博文</h2><p>两种方法：  </p>
<ul>
<li>在博文根目录的Source文件夹的post文件夹下直接新建一个md文件</li>
<li>在博文根目录打来PowerShell，然后输入<code>hexo new &#39;你的标题&#39;</code>回车在你的post文件夹下就新建了一个博文，打开编辑即可。然后使用<code>hexo g -d</code>部署到线上。  </li>
</ul>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>接下来呢，我还会针对Next主题、相关的网站配置以及域名和百度谷歌收录进行说明，欢迎关注我的系列文章。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>洋洋洒洒的写了4000+字，确实每一步都是在仔仔细细的做，记录。这篇博文参考了hexo的官方文档，以及百度谷歌的各种教程，重复杂乱居多，网上各种文章都是复制粘贴重复很多且不是最新的，我只想用最平凡的文字记录最清晰的道路。我是一个被代码耽误的诗人，这是我朋友给我的评价哈哈哈。</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客从零搭建 </tag>
            
            <tag> 最新 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[站点被百度谷歌收录]]></title>
      <url>/2018/01/02/2018-01-02%20120748/</url>
      <content type="html"><![CDATA[<p>精心写一篇博文但是没人看怎么办呢？百度搜不到，谷歌搜不到？别慌，还需要将你的网站提交到百度和谷歌。</p>
<p>在开始之前，你可以按照以下格式在百度和谷歌搜索下你的网站：<br><img src="https://i.imgur.com/5hnjkNo.png" alt=""></p>
<p><img src="https://i.imgur.com/yQ3UAjT.png" alt=""><br>注意：提交到谷歌需要科学上网。</p>
<h1 id="提交百度搜索引擎"><a href="#提交百度搜索引擎" class="headerlink" title="提交百度搜索引擎"></a>提交百度搜索引擎</h1><p>登录<a href="http://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">http://ziyuan.baidu.com/site/index</a></p>
<p>ps：可能需要个人信息认证，按照提示认证即可！  </p>
<p><img src="https://i.imgur.com/YpUnA4O.png" alt=""></p>
<h2 id="点击添加站点"><a href="#点击添加站点" class="headerlink" title="点击添加站点"></a>点击添加站点</h2><p>会看到如下界面：<br><img src="https://i.imgur.com/zWlFN8G.png" alt="">  </p>
<h2 id="在图中文本框添加你的个人网站域名"><a href="#在图中文本框添加你的个人网站域名" class="headerlink" title="在图中文本框添加你的个人网站域名"></a>在图中文本框添加你的个人网站域名</h2><p>最好是带上<code>www</code></p>
<h2 id="设置站点领域"><a href="#设置站点领域" class="headerlink" title="设置站点领域"></a>设置站点领域</h2><p>这里我选择<code>信息技术</code>，点击下一步。 </p>
<h2 id="选择验证方式"><a href="#选择验证方式" class="headerlink" title="选择验证方式"></a>选择验证方式</h2><h3 id="验证方式一：文件验证"><a href="#验证方式一：文件验证" class="headerlink" title="验证方式一：文件验证"></a>验证方式一：文件验证</h3><p><img src="https://i.imgur.com/lj9qSFz.png" alt=""><br>  这里我选择的是文件验证，建议大家也使用文件验证方式，这样比较简单。 </p>
<blockquote>
<ol>
<li>请点击 下载验证文件 获取验证文件（当前最新：baidu_verify_Rkofa3ZBzc.html）</li>
</ol>
<ol>
<li>将验证文件放置于您所配置域名(www.bianxiaofeng.com)的根目录下</li>
</ol>
<ol>
<li>点击这里确认验证文件可以正常访问</li>
</ol>
<ol>
<li>请点击“完成验证”按钮</li>
</ol>
<p>为保持验证通过的状态,成功验证后请不要删除HTML文件   </p>
</blockquote>
<p>网站的根目录在那里呢？  </p>
<p>在你的博客的本地根目录的<code>Source</code>文件夹内。  </p>
<p><img src="https://i.imgur.com/NbWMPCi.png" alt=""><br> 然后控制台输入：<code>hexo g -d</code>，部署到网站上。</p>
<p>验证方式：<br>点击3步骤的验证。如果能点击进去证明成功。   </p>
<h2 id="随后点完成验证。"><a href="#随后点完成验证。" class="headerlink" title="随后点完成验证。"></a>随后点完成验证。</h2><h3 id="HTML标签验证"><a href="#HTML标签验证" class="headerlink" title="HTML标签验证"></a>HTML标签验证</h3><p>本文使用的是Next主题。在<code>themes/next/layout/_partials/head.swig</code>内：修改meta标签为站长网站上给出的标签即可：</p>
<p><img src="https://i.imgur.com/5BsCvZk.png" alt="">  </p>
<p>同时，在themes/next/_config.yml中将google-site-verification和baidu_site_verification的值设置为true即可。</p>
<p> 然后控制台输入：<code>hexo g -d</code>，部署到网站上。</p>
<h2 id="CNAME验证"><a href="#CNAME验证" class="headerlink" title="CNAME验证"></a>CNAME验证</h2><p><img src="https://i.imgur.com/IfCkGvN.png" alt="">  </p>
<p>配置方式如图：</p>
<p><img src="https://i.imgur.com/UeHI8VE.png" alt="">  </p>
<h1 id="谷歌验证"><a href="#谷歌验证" class="headerlink" title="谷歌验证"></a>谷歌验证</h1><p>登录<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">https://www.google.com/webmasters/tools/home?hl=zh-CN</a><br>如图：<br><img src="https://i.imgur.com/g9YE3s8.png" alt="">   </p>
<h2 id="在上图输入你的网站地址"><a href="#在上图输入你的网站地址" class="headerlink" title="在上图输入你的网站地址"></a>在上图输入你的网站地址</h2><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="https://i.imgur.com/XqmMJLv.png" alt=""></p>
<p>按照下图进行选择：</p>
<p><img src="https://i.imgur.com/BkGlDW2.png" alt="">  </p>
<p>在阿里云的解析当中添加下面的解析：<br><img src="https://i.imgur.com/LlISN8f.png" alt="">  </p>
<p>点击验证即可。  </p>
<p><img src="https://i.imgur.com/fLZQwgj.png" alt="">  </p>
<h1 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h1><blockquote>
<p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 </p>
</blockquote>
<h2 id="安装百度谷歌的站点地图文件"><a href="#安装百度谷歌的站点地图文件" class="headerlink" title="安装百度谷歌的站点地图文件"></a>安装百度谷歌的站点地图文件</h2><pre><code>npm install hexo-generator-sitemap --save

npm install hexo-generator-baidu-sitemap --save  
</code></pre><h2 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h2><p>打开站点配置文件：<br><img src="https://i.imgur.com/AcrthZy.png" alt="">  </p>
<p>主要是将url设置为你的站点名称。</p>
<p>然后执行：<code>hexo clean</code>和<code>hexo g</code>  </p>
<p>这样在你的网站根目录的<code>public</code>文件夹下生成sitemap.xml文件和baidusitemap.xml文件：  </p>
<p><img src="https://i.imgur.com/jqyyXOX.png" alt="">  </p>
<p>其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。  </p>
<h2 id="向谷歌提交链接"><a href="#向谷歌提交链接" class="headerlink" title="向谷歌提交链接"></a>向谷歌提交链接</h2><p>google站点平台：<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">https://www.google.com/webmasters/tools/home?hl=zh-CN</a>，然后就是注册账号、验证站点、提交sitemap，</p>
<p><img src="https://i.imgur.com/A5rvI8A.png" alt="">    </p>
<p><img src="https://i.imgur.com/UOvfbDi.png" alt="">  </p>
<p>提交你的site就行了</p>
<h2 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h2><p>百度收录很麻烦，效率比谷歌差远了。</p>
<h3 id="设置自动推送"><a href="#设置自动推送" class="headerlink" title="设置自动推送"></a>设置自动推送</h3><p>在主题配置文件下设置,将baidu_push设置为true：</p>
<pre><code># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO
baidu_push: true 
</code></pre><h3 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h3><p>将生成的baidusitemap.xml提交到百度<a href="http://ziyuan.baidu.com/linksubmit/index" target="_blank" rel="noopener">http://ziyuan.baidu.com/linksubmit/index</a></p>
<p>点击链接提交 ：</p>
<p><img src="https://i.imgur.com/sCONlMv.png" alt="">  </p>
<p>输入文件地址提交  </p>
<p><img src="https://i.imgur.com/M8JJBIe.png" alt=""></p>
<p>稍后你刷新页面，就可以看到状态了。</p>
<p>本文参考：<br><a href="http://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">http://blog.csdn.net/sunshine940326/article/details/70936988</a></p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> google </tag>
            
            <tag> baidu </tag>
            
            <tag> 收录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博文置顶（自定义排序）]]></title>
      <url>/2018/01/01/2018-01-01%20212957/</url>
      <content type="html"><![CDATA[<blockquote>
<p>HEXO默认是按照时间顺序排一条线，然后按照时间顺序来决定显示的顺序的。按照网上的教程整理了一份方法。</p>
</blockquote>
<h1 id="Hexo博文置顶（自定义排序）"><a href="#Hexo博文置顶（自定义排序）" class="headerlink" title="Hexo博文置顶（自定义排序）"></a>Hexo博文置顶（自定义排序）</h1><p>使用的是<code>top</code>属性，<code>top</code>值越高，排序越在前，不设置<code>top</code>值得博文按照时间顺序排序。<br>修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js  </p>
<p>打开在最后添加如下<code>javascript</code>代码  </p>
<pre><code>posts.data = posts.data.sort(function(a, b) {
if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义
    if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排
    else return b.top - a.top; // 否则按照top值降序排
}
else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）
    return -1;
}
else if(!a.top &amp;&amp; b.top) {
    return 1;
}
else return b.date - a.date; // 都没定义按照文章日期降序排
</code></pre><p>}); </p>
<p>在写文章的时候添加top属性就行了。 </p>
<p>文章有多种属性，一个一个添加是不是很麻烦呢？  </p>
<p>这个时候可以修改：HEXO博客的<code>scaffolds\post.md</code>  </p>
<p>附上个人的<code>post</code>设置   </p>
<p><img src="https://i.imgur.com/QS4D72n.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博文置顶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyEclipse2017 CI7 集成开发环境的破解与使用]]></title>
      <url>/2017/12/30/2017-12-30%20180202/</url>
      <content type="html"><![CDATA[<h1 id="MyEclipse2017-CI7-集成开发环境的破解与使用"><a href="#MyEclipse2017-CI7-集成开发环境的破解与使用" class="headerlink" title="MyEclipse2017 CI7  集成开发环境的破解与使用"></a>MyEclipse2017 CI7  集成开发环境的破解与使用</h1><blockquote>
<p>MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。<br>MyEclipse企业级工作平台（MyEclipseEnterprise Workbench ，简称MyEclipse）是对EclipseIDE的扩展，利用它我们可以在数据库和JavaEE的开发、发布以及应用程序服务器的整合方面极大的提高工作效率。它是功能丰富的JavaEE集成开发环境，包括了完备的编码、调试、测试和发布功能，完整支持HTML，Struts，JSP，CSS，Javascript，Spring，SQL，Hibernate  。<br>MyEclipse 是一个十分优秀的用于开发Java, J2EE的 Eclipse 插件集合，MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持十分不错。MyEclipse可以支持Java Servlet，AJAX，JSP，JSF，Struts，Spring，Hibernate，EJB3，JDBC数据库链接工具等多项功能。可以说MyEclipse是几乎囊括了目前所有主流开源产品的专属eclipse开发工具。—— <a href="https://baike.baidu.com/item/MyEclipse/783967?fr=aladdin" target="_blank"> [百度百科 ]</a></p>
</blockquote>
<p><em>本文主要通过本人自己的经验对网上的一些各类大神的教程进行总结与更新（大神们的教程已经发布很久了，不能适用现在的最新版本）。</em><br>备注：本教程默认读者是配置好了JAVA的相关环境的，请读者自行配置相关环境。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>下载地址建议还是去官方的网站吧，为了安全。嘻嘻</p>
<pre><code>附上下载地址：http://www.myeclipsecn.com/download/
</code></pre><p>注：下载需要微信扫码获取密码。<br><img src="http://img.blog.csdn.net/20170907122010684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="注意我使用的版本为MyEclipse 2017 CI 7（2017-7-12更新），以后更新的版本有可能破解方法不能适用"><br>    注意我使用的版本为MyEclipse 2017 CI 7（2017-7-12更新）</p>
<p>下载默认安装即可。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong><em>安装完毕之后，一定要记住，不要选择那个默认的打开MyEclipse ！！！</em></strong></p>
<p><img src="http://img.blog.csdn.net/20170907162256989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>然后使用我们的破解工具：<br>        破解工具下载地址：<a href="http://download.csdn.net/download/qq_32454537/9968200" target="_blank" rel="noopener">http://download.csdn.net/download/qq_32454537/9968200</a></p>
<h3 id="1、解压文件后打开文件夹："><a href="#1、解压文件后打开文件夹：" class="headerlink" title="1、解压文件后打开文件夹："></a>1、解压文件后打开文件夹：</h3><p><img src="http://img.blog.csdn.net/20170907122456966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h3 id="2、复制这里面的所有内容："><a href="#2、复制这里面的所有内容：" class="headerlink" title="2、复制这里面的所有内容："></a>2、复制这里面的所有内容：</h3><p><img src="http://img.blog.csdn.net/20170907122549774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="3、到MyEclipse的安装目录下："><a href="#3、到MyEclipse的安装目录下：" class="headerlink" title="3、到MyEclipse的安装目录下："></a>3、到MyEclipse的安装目录下：</h3><p><img src="http://img.blog.csdn.net/20170907122656782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="4、复制到这个plugins文件夹内，覆盖就可。"><a href="#4、复制到这个plugins文件夹内，覆盖就可。" class="headerlink" title="4、复制到这个plugins文件夹内，覆盖就可。"></a>4、复制到这个plugins文件夹内，覆盖就可。</h3><p>ps：一共是64个文件。</p>
<h3 id="5、打开myeclipse2017-keygen这个文件夹"><a href="#5、打开myeclipse2017-keygen这个文件夹" class="headerlink" title="5、打开myeclipse2017_keygen这个文件夹"></a>5、打开myeclipse2017_keygen这个文件夹</h3><p><img src="http://img.blog.csdn.net/20170907122900501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="6、打开之后双击打开红框部分"><a href="#6、打开之后双击打开红框部分" class="headerlink" title="6、打开之后双击打开红框部分"></a>6、打开之后双击打开红框部分</h3><p><img src="http://img.blog.csdn.net/20170907122934081?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="7、打开后如图"><a href="#7、打开后如图" class="headerlink" title="7、打开后如图"></a>7、打开后如图</h3><p>填写UserCode为任意英文或者数字，这里填写为admin、<br>下面一个下拉选择框选择BLUE<br>按SystemId按钮，可能需要按两下，知道SystemId输入框出现一连串的“莫名其妙”的符号。<br>这个时候再按Active按钮，此时最下面的TextView就会出现这么一坨东西，代表基本成功<br><img src="http://img.blog.csdn.net/20170907162902448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这个时候，还需要点击Tools，选择tools里的save propertity<br><img src="http://img.blog.csdn.net/20170907163006825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>PS：附上操作顺序图<br><img src="http://img.blog.csdn.net/20170907123217745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>然后打开MyEclipse敬请享用吧。</p>
<p>如果有问题欢迎回复。我在线都会答。</p>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><h3 id="2017年9月8日更新："><a href="#2017年9月8日更新：" class="headerlink" title="2017年9月8日更新："></a>2017年9月8日更新：</h3><p>如果出现了破解失败，即进去显示还有5天就到期。<br>请按照以下步骤执行：<br>1、首先卸载MyEclipse ，卸载完毕后请删除MyEclipse中的所有的文件。<br>2、按住Windows键+R，输入regedit，进去注册表编辑页面，按住Ctrl+F，出来搜索框，请输入：MyEclipse，然后回车，进行搜索，搜索出来了按del键进行删除。然后再按住F3继续搜索，直到搜索完毕。<br>3、重新按照如上步骤，重新破解安装。</p>
<h3 id="2017年12月30日更新："><a href="#2017年12月30日更新：" class="headerlink" title="2017年12月30日更新："></a>2017年12月30日更新：</h3><p>也没更新啥，就换了下排版嘻嘻嘻！</p>
<p>本文链接：<a href="http://blog.csdn.net/qq_32454537/article/details/77880294" target="_blank" rel="noopener">http://blog.csdn.net/qq_32454537/article/details/77880294</a></p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Eclipse破解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 优化]]></title>
      <url>/2017/12/04/2017-12-04%20212731/</url>
      <content type="html"><![CDATA[<blockquote>
<p><em>安装好Android Studio之后需要根据自己的习惯进行一些设置，下载些插件、设置下软件的相关属性等等。刚好重装了下系统，针对这个Android Studio进行了相关的设置，在这里将经历说一下，避免自己以后晚了相关设置也方便一些需要帮助的朋友</em>  </p>
</blockquote>
<p>更新记录：2017年12月24日22:32:37更新</p>
<p>本文主要分为设置篇和插件篇： </p>
<h1 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h1><p>##快速查找以及快捷键搜索<br>在AS的面板上双击<code>shift</code>键，即可调出全局搜索。</p>
<p> <img src="http://img.blog.csdn.net/20171224213924058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>AS有很多的快捷键，对于这些快捷键你不一定随时都能记得，这个时候可以使用<code>Win+Shift+A</code>键输入你想用的功能。后面会提示相关的快捷键的。<br><img src="http://img.blog.csdn.net/20171224214158337?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<h2 id="恢复默认布局"><a href="#恢复默认布局" class="headerlink" title="恢复默认布局"></a>恢复默认布局</h2><p>当你各种乱动默认的面板布局的时候，有的面板你想找的时候却发现找不到了，这个时候按住 <code>Shift+F12</code>就可以重置默认面板。<br><img src="http://img.blog.csdn.net/20171224214521926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="Tip-of-the-day"><a href="#Tip-of-the-day" class="headerlink" title="Tip of the day"></a>Tip of the day</h2><p>打开软件的时候随机显示关于Android Studio的相关使用提示。（很有用的，别关）</p>
<p><img src="http://img.blog.csdn.net/20171224215949578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Android-Studio相关网站"><a href="#Android-Studio相关网站" class="headerlink" title="Android Studio相关网站"></a>Android Studio相关网站</h2><ul>
<li><a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio 中文社区</a> </li>
<li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">优质的问答社区（英文的）</a> </li>
</ul>
<h1 id="设置篇"><a href="#设置篇" class="headerlink" title="设置篇"></a>设置篇</h1><blockquote>
<p>Android Studio到底是外国人开发的，这个东西拿到手感觉和我们日常使用的IDE有点···· </p>
</blockquote>
<h2 id="鼠标滚轮滑动调整字体大小"><a href="#鼠标滚轮滑动调整字体大小" class="headerlink" title="鼠标滚轮滑动调整字体大小"></a>鼠标滚轮滑动调整字体大小</h2><p>打开<code>File</code>里的<code>Setting</code> 勾选<code>Change font size(Zoom)with Ctrl——Mouse Wheel</code><br><img src="http://img.blog.csdn.net/20171224214754310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="查看参数定义"><a href="#查看参数定义" class="headerlink" title="查看参数定义"></a>查看参数定义</h2><p>使用快捷键<code>Ctrl+P</code>可以查看当前鼠标所在位置的方法的参数定义。<br><img src="http://img.blog.csdn.net/20171224222531022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<h2 id="鼠标移动显示API文档"><a href="#鼠标移动显示API文档" class="headerlink" title="鼠标移动显示API文档"></a>鼠标移动显示API文档</h2><p>设置当鼠标移动到方法上的时候显示API文档。<code>Editor-&gt;General-&gt;show quick document on mouse move</code>  后面那个Delay Time 是设置延时的，单位为毫秒。但是建议电脑性能差一点的不要开，会很卡。<br><img src="http://img.blog.csdn.net/20171224222926874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="设置默认的字体大小"><a href="#设置默认的字体大小" class="headerlink" title="设置默认的字体大小"></a>设置默认的字体大小</h2><p>打开AS的时候发现蚊子一样大小的代码，密密麻麻的密集恐惧症受不了。<code>Editor-&gt;Colors&amp;Fonts-&gt;Font</code><br>一般设置到18就行了<br><img src="http://img.blog.csdn.net/20171224215037079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h2><p>设置<code>Keymap</code>，快捷键太多，可以使用搜索框搜索 </p>
<p><img src="http://img.blog.csdn.net/20171224220232053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="设置代码提示"><a href="#设置代码提示" class="headerlink" title="设置代码提示"></a>设置代码提示</h2><p>Android Studio的代码提示是对大小写敏感的，选择None就可以匹配到很多方法或者关键字，这个在你忘了这个方法怎么写的时候非常有用。<br>此外<strong>Ctrl+Q</strong>快捷键也可以设置代码提示。<br><img src="http://img.blog.csdn.net/20171224220954002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="去掉代码编辑区的竖线"><a href="#去掉代码编辑区的竖线" class="headerlink" title="去掉代码编辑区的竖线"></a>去掉代码编辑区的竖线</h2><p> 编辑区域总是有一条竖线，这条竖线的作用是用来警示程序员代码不要写的过长的。<br> <img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320143743.png" alt="QQ截图20180320143743">  </p>
<h2 id="设置方法之间横线隔开"><a href="#设置方法之间横线隔开" class="headerlink" title="设置方法之间横线隔开"></a>设置方法之间横线隔开</h2><p>操作方法如图：勾选 <strong>Show method separators</strong></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320143838.png" alt="QQ截图20180320143838"> </p>
<h2 id="炫酷的Log"><a href="#炫酷的Log" class="headerlink" title="炫酷的Log"></a>炫酷的Log</h2><p>设置地址：Preferences → Editor → Colors &amp; Fonts → Android Logcat<br>将各种类型的log设置颜色：<br>参考别人的配色如下：附上<a href="https://meedamian.com/post/deuglifying-android-studio/" target="_blank" rel="noopener">链接</a></p>
<p> <pre>Type        Color<br>verbose:    #BBB<br>debug:      #33B5E5<br>info:       #9C0<br>assert:     #A6C<br>error:      #F44<br>warning:    #FB3<br>  </pre><br>效果如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320150409.png" alt="QQ截图20180320150409"></p>
<h1 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h1><h2 id="AndroidAccessors"><a href="#AndroidAccessors" class="headerlink" title="AndroidAccessors"></a>AndroidAccessors</h2><p>快速生成<code>get</code>和<code>set</code>系列方法。这个在你定义<code>JavaBean</code>的时候非常有用。<br><img src="http://img.blog.csdn.net/20171224221252982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="ButterKnifeZelezny-插件"><a href="#ButterKnifeZelezny-插件" class="headerlink" title="ButterKnifeZelezny 插件"></a>ButterKnifeZelezny 插件</h2><p>如果你厌倦了findViewById这样的写法，那么这个插件是你的选择。这个配合ButterKnife使用的。</p>
<h2 id="ReciteWords"><a href="#ReciteWords" class="headerlink" title="ReciteWords"></a>ReciteWords</h2><p>是一个IntelliJ IDEA、Android Studio 记单词翻译插件,可以将英文翻译为中文并记录到生词本提供查阅。，项目地址为：<a href="https://github.com/BolexLiu/ReciteWords" target="_blank" rel="noopener">ReciteWords</a></p>
<p>功能： </p>
<ul>
<li>划词翻译 整句翻译 拆分驼峰命名翻译等</li>
<li>生词本保存翻译过后的历史记录  </li>
</ul>
<p>使用方法：  </p>
<ul>
<li><p>Clone项目，获取根目录下的ReciteWords.jar。</p>
</li>
<li><p>打开Android Studio， Preferences -&gt; Plugins -&gt; Install plugin from disk -&gt; 获取ReciteWords.jar安装并重启Android Studio。</p>
</li>
<li><p>选中代码，按下 Alt+Q(也可以自己设定)。即可翻译。效果如下:<br><img src="https://github.com/BolexLiu/ReciteWords/raw/master/img/1.png" alt=""></p>
</li>
<li><p>设置快捷键<br>使用键盘快捷键触发，Preferences -&gt; Keymap -&gt; 获取ReciteWords - &gt; 右键 add Keyboard Shortcut. 输入你想要的快捷键即可。</p>
</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>这里我推荐一个<code>MaterialDesign AS UI Theme</code> 这个主题比较好用，尤其是配合黑色的AS主题的时候。</p>
<p>顺便推荐一个<a href="http://color-themes.com/" target="_blank" rel="noopener">http://color-themes.com/</a> 这个网站下载你喜欢的主题，然后导入主题即可。<br><img src="http://img.blog.csdn.net/20171224222110962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>插件及常用的快捷键请看我之前的博客：<a href="http://blog.csdn.net/qq_32454537/article/details/77870200" target="_blank" rel="noopener">http://blog.csdn.net/qq_32454537/article/details/77870200</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
