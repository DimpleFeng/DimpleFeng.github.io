<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Error:Execution failed for task ':app:transformDexArchiveWithExternalLibsDexMergerForDebug'的解决办法]]></title>
      <url>/2018/03/20/2018-3-20-153425/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Android的开源环境下，也就多出来很多优秀的第三方的项目，但是因为很多第三方的项目和目前你正在开发的APP使用的Lib有些是重复的，这样会导致<strong>transformClassesWithDexForDebug</strong>  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/20180320154257.png" alt="20180320154257">  </p>
<p>本文介绍年两种方法来处理这个问题。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="添加“multiDexEnabled-true”到-defaultConfig"><a href="#添加“multiDexEnabled-true”到-defaultConfig" class="headerlink" title="添加“multiDexEnabled true”到 defaultConfig"></a>添加“multiDexEnabled true”到 defaultConfig</h2><p>在app的build.gradle文件中的 defaultConfig添加：  </p>
<p><code>multiDexEnabled true</code><br>如图所示：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320154214.png" alt="QQ截图20180320154214"></p>
<p>这样的设置只能解决一部分的问题，而更加难受的情况是在项目中引入了很多的第三方库，这个时候鬼知道哪个库出了问题，一个一个试可能能够找出来，但是找出来黄花菜都凉了。  </p>
<p>这个时候请移步解决方法二  </p>
<h2 id="根据Message信息找到重复的包"><a href="#根据Message信息找到重复的包" class="headerlink" title="根据Message信息找到重复的包"></a>根据Message信息找到重复的包</h2><p>在Setting-&gt;Build,Execution,Deployment-&gt;Compiler中的Command-line Opptions中输入<strong>–stacktrace</strong>启用堆栈跟踪  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320155125.png" alt="QQ截图20180320155125"></p>
<p> 接着运行APP，就能够在Message上面输出：  </p>
<p> <img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320155325.png" alt="QQ截图20180320155325">  </p>
<p> 这样我根据上面消息找到了butterknife重复包。  </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt实现串口通信控制51单片机（上下位机）]]></title>
      <url>/2018/03/09/2018-3-9-165439/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Qt是我在大一下学期开始接触的，当时刚学完C++，然后每天对着黑漆漆的console窗口，在偶然的机会接触到Qt这个跨平台的C++应用程序开发框架。又在老师的怂恿下（单片机老师说如果做出上下位机实验成绩就是满分），使用Qt来进行上下位机的开发。当然实现的功能很简单，控制LED灯的明灭，输入数字显示在数码管上，控制继电器和蜂鸣器以及定时器。</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>首先是界面截图<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917547.png" alt="{mdFileName}-20183917547"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917553.png" alt="{mdFileName}-20183917553"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917556.png" alt="{mdFileName}-20183917556"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183917559.png" alt="{mdFileName}-20183917559"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018391762.png" alt="{mdFileName}-2018391762"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018391765.png" alt="{mdFileName}-2018391765"><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018391767.png" alt="{mdFileName}-2018391767">  </p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>其实实现的原理很简单，Qt已经是封装好了串口通信的 QSerialPort类，我们只需要设置好串口通信的相关属性（波特率、数据位、奇偶校验位等等），然后调用 QSerialPort的write方法发送命令到下位机就行。当然了，还需要相应的编写下位机的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_openButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    if(ui-&gt;openButton-&gt;text()==tr(&quot;打开串口&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        serial = new QSerialPort;</span><br><span class="line">        //设置串口名</span><br><span class="line">        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());</span><br><span class="line">        //打开串口</span><br><span class="line">        serial-&gt;open(QIODevice::ReadWrite);</span><br><span class="line">        //设置波特率</span><br><span class="line">        serial-&gt;setBaudRate(ui-&gt;BaudBox-&gt;currentText().toInt());</span><br><span class="line">        //设置数据位数</span><br><span class="line">        switch(ui-&gt;BitNumBox-&gt;currentIndex())</span><br><span class="line">        &#123;</span><br><span class="line">         case 8: serial-&gt;setDataBits(QSerialPort::Data8); break;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置奇偶校验</span><br><span class="line">        switch(ui-&gt;ParityBox-&gt;currentIndex())</span><br><span class="line">        &#123;</span><br><span class="line">        case 0: serial-&gt;setParity(QSerialPort::NoParity); break;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置停止位</span><br><span class="line">        switch(ui-&gt;StopBox-&gt;currentIndex())</span><br><span class="line">        &#123;</span><br><span class="line">             case 1: serial-&gt;setStopBits(QSerialPort::OneStop); break;</span><br><span class="line">            case 2: serial-&gt;setStopBits(QSerialPort::TwoStop); break;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置流控制</span><br><span class="line">        serial-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line"></span><br><span class="line">        //关闭设置菜单使能</span><br><span class="line">        ui-&gt;PortBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;BaudBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;BitNumBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;ParityBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;StopBox-&gt;setEnabled(false);</span><br><span class="line">        ui-&gt;openButton-&gt;setText(tr(&quot;关闭串口&quot;));</span><br><span class="line"></span><br><span class="line">        //连接信号槽</span><br><span class="line">        QObject::connect(serial, &amp;QSerialPort::readyRead, this, &amp;MainWindow::Read_Data);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //关闭串口</span><br><span class="line">        serial-&gt;clear();</span><br><span class="line">        serial-&gt;close();</span><br><span class="line">        serial-&gt;deleteLater();</span><br><span class="line"></span><br><span class="line">        //恢复设置使能</span><br><span class="line">        ui-&gt;PortBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;BaudBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;BitNumBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;ParityBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;StopBox-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;openButton-&gt;setText(tr(&quot;打开串口&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关代码上传至百度云：<br>链接：<a href="https://pan.baidu.com/s/1fCpx_fFD9qsZVWKf89QkXg" target="_blank" rel="noopener">https://pan.baidu.com/s/1fCpx_fFD9qsZVWKf89QkXg</a> 密码：0oqe</p>
]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 串口通信 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见排序算法总结（冒泡排序、快速排序、选择排序、插入排序）——Java语言]]></title>
      <url>/2018/03/09/2018-3-9-135602/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排序算法是最基本的算法之一，为此衍生出很多种的排序算法，而不同的排序算法具有不同的使用环境，为此掌握几种常见的排序算法是作为一个精致的程序员必不可少的技能。本文主要是介绍常见的四种排序算法的思想以及Java实现。  </p>
<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><blockquote>
<p>冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 ——来源<a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a></p>
</blockquote>
<h3 id="冒泡排序算法核心思想"><a href="#冒泡排序算法核心思想" class="headerlink" title="冒泡排序算法核心思想"></a>冒泡排序算法核心思想</h3><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  </li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183914350.gif" alt="{mdFileName}-20183914350">    </p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>比如对于8 4 9 2 5 这组无序序列来说：<br>算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">	for (int j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">		if (arr[i]&gt;arr[j]) &#123;</span><br><span class="line">			int temp=arr[i];</span><br><span class="line">			arr[i]=arr[j];</span><br><span class="line">			arr[j]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法的执行思想是：外层循环i是控制第1、2···个数，然后把这第1、2···个数依次与后面的数进行比较，如果后面的数不符合排序规则，那么就进行替换。这样一来，能够保证外层循环已经循环过的数始终是符合排序规则的。  </p>
<p>当然，此类算法还有许多变形，比如下面：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">	for (int j = arr.length-1; j &gt;i ; j--) &#123;</span><br><span class="line">		if (arr[j]&gt;arr[j-1]) &#123;</span><br><span class="line">			int temp=arr[j];</span><br><span class="line">			arr[j]=arr[j-1];</span><br><span class="line">			arr[j-1]=temp;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法的思想是：从后向前进行比较,外层循环只是控制循环的次数，内层循环控制交换。这样一来，始终能保持在最前面的数是符合排序规则的。  </p>
<p>无论是怎样的变形，都是像吐泡泡一样，将符合条件的吐出来，然后没有吐出来的进行比较，直到找到合适的泡泡然后吐出来。  </p>
<h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h2><blockquote>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。快速排序采用“分而治之、各个击破”的观念。  ————来源<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a></p>
</blockquote>
<p>步骤为：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
<li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""> </li>
</ul>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>比如对于22， 5 ，85， 65 ，21 ，99 ，66这组无序序列来说。    </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201839164140.png" alt="{mdFileName}-201839164140">  </p>
<p>在本例子中，选取的是数组中的第一个22作为基准，采用分而治之的思想，将数组小于和大于基准的数分为两组，再采用递归的方法再进行排序，直到排序完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static void quick_sort(int[] a, int l, int r) &#123;</span><br><span class="line">	if (l &lt; r) &#123;</span><br><span class="line">		int i = l, j = r, x = a[l];</span><br><span class="line">		while (i &lt; j) &#123;</span><br><span class="line">			while (i &lt; j &amp;&amp; a[j] &gt;= x) &#123;//先从后面往前面找</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			if (i &lt; j) &#123;//如果找到比基准小的数，将这个比基准小的数放到之前的基准所在的位置去 </span><br><span class="line">				a[i] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			while (i &lt; j &amp;&amp; a[i] &lt; x) &#123;//再从前面往后面找</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (i &lt; j) &#123;//如果找到了比基准大的数，那么将这个比基本大的数放到上一个空出来的位置去</span><br><span class="line">				a[j] = a[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = x;</span><br><span class="line">		quick_sort(a, l, i - 1);//递归调用，对基准左边的数进行排序</span><br><span class="line">		quick_sort(a, i + 1, r);//对基本右边的数进行排序</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。  ————来源<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a>    </p>
</blockquote>
<h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><p>将一组数据分为两组，分别为有序组和无序组。每次从无序组中取出最前面的数和有序组的最后一个数进行比较，为这个数在有序组中找到一个合适的位置，这样始终保持着有序组中的数始终是有序的。  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018310111715.gif" alt="{mdFileName}-2018310111715"><br>图片来源于网络</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void InsertionSort(int num[]) &#123;</span><br><span class="line">	int j=0,temp=0;//定义变量，temp用于保存要进行比较的数（未排序队列的第一个数）</span><br><span class="line">	for (int i = 1; i &lt; num.length; i++) &#123;//遍历（之所以是从数组下标1开始是因为数组下标为0的数只有一个，本身就是一个有序组）</span><br><span class="line">		temp=num[i];//保存未排序队列的第一个数，这个时候相当于数组下标为i的位置为坑，需要找到一个合适的数来填这个坑</span><br><span class="line">		j=i-1;//j定位已经排序好了的队列的最后一个数的下标</span><br><span class="line">		while (j&gt;=0&amp;&amp;num[j]&gt;temp) &#123;//j&gt;=0防止数组越界。num[j]&gt;temp是交换条件 </span><br><span class="line">			num[j+1]=num[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		num[j+1]=temp;//这里是j+1不是j的原因是执行了上一步j--之后，j比本身应该在的位置少1，所以+1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。   ————来源<a href="https://zh.wikipedia.org/zh-cn/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">《维基百科》</a>  </p>
</blockquote>
<h3 id="实例介绍"><a href="#实例介绍" class="headerlink" title="实例介绍"></a>实例介绍</h3><p>图片动画演示   </p>
<p> <img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="图片来源——维基百科"><br>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。<br> 以上动画演示的是数组：a[]={8, 5, 2, 6, 9, 3, 1, 4, 0, 7};接下来会结合动画进行说明：  </p>
<ul>
<li>遍历数组a[0,n] (n为数组的长度)，找到里面最小的数0，放到最前面，数组变为：a[]={0,5,2,6,9,3,1,4,8,7};</li>
<li>遍历数组a[1,n]，找到最小的数1，放到数组下标为1的位置，数组变为a[]={0,1,2,6,9,3,5,4,8,7};</li>
</ul>
<p>重复以上步骤，最终数组变为：a[]={0,1,2,3,4,5,6,7,8,9}。  </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void SelectionSort(int a[]) &#123;</span><br><span class="line">	int k = 0, temp = 0;// 其中k用于记录符合条件的数组的下标，temp用于交换数据作为中间变量</span><br><span class="line">	for (int i = 0; i &lt; a.length - 1; i++) &#123;// 这里减一的原因是，之前的数都是分别和这个最后一个数比较的，所以最后一个数一定是符合排序规则的</span><br><span class="line">		for (int j = i; j &lt; a.length - 1; j++) &#123;</span><br><span class="line">			if (a[j] &lt; a[i]) &#123;</span><br><span class="line">				k = j;// 记录下符合排序规则的数的下标</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 交换</span><br><span class="line">		temp = a[i];</span><br><span class="line">		a[i] = a[k];</span><br><span class="line">		a[k] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>四种最常见的排序算法的相关指标如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201831012532.png" alt="{mdFileName}-201831012532"><br>不同的算法具有很多种的变形，比如冒泡，可以从序列前面开始，也可以从后面开始，其原理都一样。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android InterFilter 匹配]]></title>
      <url>/2018/03/08/2018-3-8-084846/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般来说，启动Activity的方法有两种，显式启动和隐式启动。对于显示启动来说，只需要实例化一个Intent对象，指明被启动对象的组件信息，包括包名以及类名。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=new Intent(MainActivity.this,OtherActivity.class);</span><br></pre></td></tr></table></figure></p>
<p>原则上是单独的使用隐式启动和显式启动，如果两者并存的话，以显式启动为准。<br>隐式调用需要Intent能够匹配目标组件的IntentFilter设置的过滤信息，如果不匹配的话是不能正常的启动Activity。Intent中需要过滤的信息包括：action、category和data。  </p>
<h1 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h1><p>一个过滤列表中的action，category，data可以有多个，所有的action，category，data分别构成不同的类别。只要有一个Intent能够同时匹配action、category、data类别才能匹配成功。一个Activity可以有多个IntentFilter，只要成功的符合一组IntentFilter就可以启动相应的Activity。  </p>
<h2 id="action的匹配规则"><a href="#action的匹配规则" class="headerlink" title="action的匹配规则"></a>action的匹配规则</h2><p>action是一个字符串，系统定义了一些，同时也支持自定义此字符串。action<strong>严格区分大小写</strong>。  </p>
<p>一个过滤规则中可以有多个action，只要有一个action和intent匹配，就可以匹配成功。   </p>
<p><strong>IntentFilter必须存在，否则不能启动Activity。</strong>  </p>
<h2 id="category匹配规则"><a href="#category匹配规则" class="headerlink" title="category匹配规则"></a>category匹配规则</h2><p>category也是字符串，系统也有默认的字符串，和action匹配规则不同的是，在intent中可以不用特别指明category属性。  </p>
<p><strong>IntentFilter中必须要有</strong><code>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</code> 无论intent是否调用addCategory()方法。  </p>
<p>在Manifest文件中也可以像action一样设置多个category标签，只要有一个匹配就可以。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">    intent.setAction(&quot;com.example.dimple.action.activity2&quot;);</span><br><span class="line">    intent.addCategory(&quot;com.example.dimple.category.activity2&quot;);</span><br><span class="line">   //判断是否有Activity能够匹配intent。防止启动报错！</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="data的匹配规则"><a href="#data的匹配规则" class="headerlink" title="data的匹配规则"></a>data的匹配规则</h2><p>data的匹配规则和action类似，如果过滤规则中定义了data，那么在Intent中也需要有可以与之匹配的data。但data可以省略不写。  </p>
<p>语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;data android:scheme=&quot;string&quot; </span><br><span class="line">android:host=&quot;string&quot; </span><br><span class="line">android:port=&quot;number&quot; </span><br><span class="line">android:path=&quot;/string&quot; </span><br><span class="line">android:pathPattern=&quot;string&quot; </span><br><span class="line">android:pathPrefix=&quot;/string&quot; </span><br><span class="line">android:mimeType=&quot;string&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>data 由两部分组成，mimeType和URL（mimeType表示媒体类型，比如image/jpg、audio/mp3等，可以表示图，文本等不同格式），URL的格式如下：  </p>
<p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code> </p>
<ul>
<li>scheme:URL的模式，比如http、file、content，如果URL中没有scheme，那么URL无效。  </li>
<li>host：主机名称，比如www.bianxiaofeng.com，如果没有host，则URL无效。  </li>
<li>port：端口<br>-path、pathPattern、pathPrefix：表示路径信息  </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在通过隐式启动Activity的时候，最好是通过PackageManager的resolveActivity方法或者Intent的resolveActivity方法来判断下是不是有能够负责匹配规则的Activity存在，防止异常出错。 </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> InterFilter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Activity的启动模式]]></title>
      <url>/2018/03/07/2018-3-7-104145/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当用户多次启动同一个Activity的时候，系统默认会一直为这个Activity创建实例，并将实例放入任务栈中，在用户按back键的时候会一一回退，每按一次任务栈的时候，栈顶的任务就会出栈，当任务栈为空的时候系统会回收这个任务栈。这就是在默认的情况下，系统对于Activity的处理方式。而这种默认的方式在某些时候可能不太符合开发者的意图。所以Android出现了多种的启动模式和标志位来更改这一默认的行为。  </p>
<h1 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h1><p>目前有四种LaunchMode，分别是：standard、singleTop、singleTask以及singleInstance。<br>为了方便说明和解释，我这里写了一个Demo，以上传到GitHub，详情请<a href="https://github.com/DimpleFeng/Android-Activity-LaunchMode" target="_blank" rel="noopener">点击</a>。界面如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155052.png" alt="{mdFileName}-201837155052"><br>分别对应4种状态的LaunchMode。</p>
<h2 id="standard-LaunchMode"><a href="#standard-LaunchMode" class="headerlink" title="standard LaunchMode"></a>standard LaunchMode</h2><p>标准模式，这是系统默认的模式，每次启动的Activity的时候会默认创建一个实例，不管这个实例是不是存在。被创建的Activity实例符合典型情况下的生命周期。<br>在这种情况下，谁启动了这个Activity，那么这个Activity就属于启动它的Activity的任务栈中。比如： A启动了B，那么B就属于A的任务栈的成员。  </p>
<p>Demo点击第一项按钮4下结果如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837123217.png" alt="{mdFileName}-201837123217"><br>可以看到：<br>这里依次调用了4次的onCreate，且每次的hashcode都不一样。说明分别创建了4次Activity实例。而且任务栈的ID一直都是88.这也就说明了<strong>谁启动Activity，该Activity就位于哪个任务栈中的说法</strong>。</p>
<h2 id="singleTop-LaunchMode"><a href="#singleTop-LaunchMode" class="headerlink" title="singleTop LaunchMode"></a>singleTop LaunchMode</h2><p>栈顶复用模式。在这种模式下，如果新的Activity已经处于任务栈的栈顶，那么这个Activity将不会被创建。同时，它的onNewIntent方法会被回调，通过此方法就可以取出当前请求的信息。但是如果新的Activity不是位于栈顶，那么这个Activity会被实例化。<br>比如： 一个任务栈中从栈顶到栈底的Activity顺序是：ABCD，如果需要启动任务A，任务A的启动模式为singleTop，那么这个A不会被实例化，而是会调用onNewIntent方法。如果需要启动B，任务B的启动模式为singleTop，那么由于B不在栈顶，那么依然会实例化B，此时任务栈的顺序是：BABCD。  </p>
<p>Demo第二项点击4下Log如图所示：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155237.png" alt="{mdFileName}-201837155237"><br>这里的操作步骤是：点击进入到SingleTop界面，这个时候出现第一次onCreate，随后又点击了一次，这时候由于是singleTop处于栈顶，这个时候只是回调onNewIntent方法。然后又启动其他Activity，出现第二次onCreate，并在其他Activity启动返回到singletop界面，这个时候出现第三次onCreate。<br>可以看到：<br>只第一次点击的时候调用了onCreate方法，之后便是调用的onNewIntent方法。而且hashcode都是一样的。这就说明：<strong>新的Activity如果位于栈顶，那么新的Activity不会被实例化。</strong></p>
<h2 id="singleTask-LaunchMode"><a href="#singleTask-LaunchMode" class="headerlink" title="singleTask LaunchMode"></a>singleTask LaunchMode</h2><p>栈内复用模式。在这种模式下，只要Activity在任务栈中存在，那么就不会重新创建实例，和singleTop一样，系统会自动回调onNewIntent方法。<br>比如：当前任务栈中有ABCD四个Activity，需要启动一个Activity C，这个时候任务栈中有Activity C，那么会直接将Activity C调到栈顶，同时回调onNewIntent方法，<strong>由于singleTask具有cleanTop的效果</strong>，所以此时的任务栈的Activity为CD。如果需要启动Activity F，而Activity F不存在，所以会直接实例化Activity F，并压入栈顶。  </p>
<p>log截图如下：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201837155659.png" alt="{mdFileName}-201837155659">  </p>
<p>这里的操作步骤是：<br>点击进入到singleTask界面，此时出现第一个onCreate，然后点击进入到其他Activity，出现第二个onCrete。此时应该注意到，任务栈的栈顶是其他Activity，这个时候在其他Activity点击返回到singTask。由于采用的是singleTask模式，singleTask已经在任务栈中，所以是直接调用，回调onNewIntent。  </p>
<p><strong>而且由于cleanTop效果，按返回键的时候，其他Activity是不会再出现的。</strong>这一点的话，在BaseActivity.java中重写生命周期的方法就能看出来。  </p>
<h2 id="singleInstance-LaunchMode"><a href="#singleInstance-LaunchMode" class="headerlink" title="singleInstance LaunchMode"></a>singleInstance LaunchMode</h2><p>单实例模式。这是一种加强的singleTask模式，具有singleTask的所有特性（cleanTop等），还有一点：使用这种模式的Activity只能单独的位于一个单独的任务栈中。<br>比如：Activity A是singleInstance模式，当A启动后，系统会单独为这个A创建一个任务栈，由于栈内复用的原因，不会再创建新的Activity A的实例。<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018371622.png" alt="{mdFileName}-2018371622"><br>由于这个是单实例模式，对于同一个Activity来说，是直接复用。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TaskAffinity，任务相关性，这个参数标识了一个Activity需要的任务栈的名字，在默认情况下，这个任务栈的名字为应用的包名。任务栈分为前台任务栈和后台任务栈。位于后台任务栈的Activity是处于暂停状态。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Activity生命周期]]></title>
      <url>/2018/03/05/2018-3-5-121345/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Android开发的过程中，有一个特别重要的组件：Activity，它是除了Windows、Dialog和Toast之外我们用户可以直接看到的界面。本文主要记录下研究Activity中的一些感悟。<br>首先Activity的生命周期总体来说可以分为两种：  </p>
<ul>
<li>正常情况下的Activity生命周期  </li>
<li>异常情况下的Activity生命周期  </li>
</ul>
<h1 id="正常情况下的生命周期"><a href="#正常情况下的生命周期" class="headerlink" title="正常情况下的生命周期"></a>正常情况下的生命周期</h1><blockquote>
<p>所谓的正常的生命周期是指：在有用户的参与的情况下，Activity经历的生命周期的改变。  </p>
</blockquote>
<p>首先上一张Activity的生命流程切换的图：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201835125748.png" alt="{mdFileName}-201835125748">  </p>
<h2 id="7种状态方法说明"><a href="#7种状态方法说明" class="headerlink" title="7种状态方法说明"></a>7种状态方法说明</h2><p>接着对每个方法进行解释说明：</p>
<ul>
<li><p>onCreate()方法：——【<strong>此时处于Activity在后台不可见</strong>】<br>表示Activity正在被创建，这是在Android开发中接触的最多的方法，比如常见的<strong>setContentView()</strong>加载布局资源，对控件和某些数字进行初始化等等。  </p>
</li>
<li><p>onStart()方法：——【<strong>此时Activity在后台可见</strong>】<br>表示启动，此时的Activity已经是处于可见状态了，但是还没有出现在前台，所以还不能进行交互。  </p>
</li>
<li><p>onResume()方法——【<strong>此时Activity在前台且可见</strong>】<br>表示Activity已经可见了，且出现在前台。和<strong>onStart()和onResume()</strong>方法的都是可见状态，但是<strong>onResume()</strong>方法表示工作在前台。   </p>
</li>
<li><p>onPause()方法——【<strong>此时Activity在前台可见</strong>】<br>表示暂停，当Activity需要跳转到另外一个Activity或者程序即将退出的时候都需要执行这个方法。而且在正常情况下，这个方法仅能持续很小的一段时间，紧接着Android系统会接着调用onStop()方法。此时可以停止动画、存储数据等操作。当新的Activity需要显示出来的时候，必须要当前的Activity的onPause()执行完才行。</p>
</li>
</ul>
<ul>
<li><p>onStop()方法——【<strong>Activity不可见仍内存中</strong>】<br>表示Activity即将终止，此时主要做一些比较耗时的操作，如相关资源回收等。  </p>
</li>
<li><p>onDestroy()方法——【<strong>Activity不可见</strong>】<br>表示Activity即将被销毁，这是Activity的最后一个生命周期，在这里了可以做一些最终资源的回收和资源的释放工作等等。  </p>
</li>
<li><p>onRestart()方法——【<strong>Activity重新可见</strong>】<br>表示Activity正在重新启动，触发条件为从不可见转为可见。比如从当前Activity回到上一个Activity，或者从桌面返回到应用程序中去。  </p>
</li>
</ul>
<h2 id="具体场景分析"><a href="#具体场景分析" class="headerlink" title="具体场景分析"></a>具体场景分析</h2><ul>
<li>Activity启动——Activity可见状态的回调情况：<br><code>onCreate()--onStart()--onResume();</code>  </li>
<li>当打开新的Activity或者从当前Activity返回到桌面：<br><code>onPause()--onStop()</code>   </li>
<li>当再次返回到原Activity(从不可见状态切换到可见状态)：<br><code>onRestart()--onStart()--onResume()</code>  </li>
<li>当按下Back键或者退出应用程序：<br><code>onPause()--onStop()--onDestroy()</code>  </li>
</ul>
<h2 id="疑难问题"><a href="#疑难问题" class="headerlink" title="疑难问题"></a>疑难问题</h2><ul>
<li>Activity生命周期中onStart和onResume、onPause和onStop有什么不同？  </li>
</ul>
<p>onStart()方法是表示已经启动Activity但 处于不可见状态。而当生命周期走到onResume()状态的时候，Activity是处于可见状态的，这时就可以与用户进行交互。而onPause()此时仍然是处于可见的状态，当到了onStop()的时候是完全处于不可见的状态了。在实际使用中没有其他区别。<br>总结来说就是： onStart和onStop是从Activity是否可见的两种状态。而onPause和onResume是Activity是否位于前台。  </p>
<ul>
<li>当用户启动一个新的Activity，那么之前Activity的onPause和当前Activity的onResume谁先执行？  </li>
</ul>
<p>onPause方法先执行，只有当前的Activity的onPause执行完毕之后才会执行新的Activity的onResume方法。  </p>
<h1 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h1><blockquote>
<p>Android 系统出了会受到用户操作导致正常的生命周期异常结束，还有一些异常情况，比如当Android资源配置改变以及系统内存不足的情况下，Activity可能会被杀死。这个时候的生命周期可能会有一些不同。  </p>
</blockquote>
<h2 id="资源相关的系统配置发生改变导致Activity被杀死"><a href="#资源相关的系统配置发生改变导致Activity被杀死" class="headerlink" title="资源相关的系统配置发生改变导致Activity被杀死"></a>资源相关的系统配置发生改变导致Activity被杀死</h2><p>在默认情况下，如果Activity不做特别处理的话，当系统配置发生改变之后，Activity会被销毁并被重新创建。  </p>
<p>当系统配置发生改变的时候，当前Activity会执行完所有的生命周期（包括onPause、onStop、onDestroy），在这个过程中，会调用onSaveIntanceState来保存当前的Activity的状态（比如当前的输入框中的文字，当前的选择内容，当前的页面位置等等），然后会重新加载，即调用onCreate等方法。在这个过程中（onCreate）会检查onSaveIntanceState是否有数据，如果有则证明是异常重新加载。这个时候会在onCreate方法中重新赋值相关内容，而这个过程是调用onRestoreInstanceState。  </p>
<p>而关于保存和恢复View中的内容的系统工作流程如下：<br>首先Activity异常后，会直接调用onSaveInstaenceState保存数据，然后Activity会委托Windows保存数据，接着WWindows会调用上面的顶层容器去保存数据，最后顶层容器再通知每一个子View保存数据。  </p>
<p>只有在Activity异常终止的时候才会onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他的情况是不会触发这个过程的。  </p>
<h2 id="资源内存不足导致低优先级的Activity被杀死"><a href="#资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="资源内存不足导致低优先级的Activity被杀死"></a>资源内存不足导致低优先级的Activity被杀死</h2><p>Activity优先级如下：  </p>
<ul>
<li>前台Activity——正在和用户进行交互的Activity，其优先级最高。</li>
<li>可见但是非前台的Activity——比如Activity中弹出一个对话框，导致Activity可见但是位于前台无法直接和用户进行交互。  </li>
<li>后台Activity——已经被暂停的Activity，比如已经执行了onStop方法，优先级最低。  </li>
</ul>
<p>当系统内存不足的时候，系统会按照优先级的顺序从低到高的杀死目标Activity的进程，然后通过onSaveInstanceState和onRestoreInstance来存储和恢复数据。<br>一些后台工作不适合脱离四大组件运行，这样的话进程很快被系统杀死。所以一般的做法是将后台工作放在Services中来保证进程具有一定的优先级，这样进程才不会被轻易的杀死。  </p>
<p>当系统的配置发生改变之后，Activity会被重新创建。采用以下方式可以不让Activity重新创建。<br>可以在AndroidManifest中给Activity指定configChanges属性。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在onPause和onStop中都尽量不需要执行太多的耗时操作。尤其是onPause，只有在onPause执行完毕之后，新的Activity才能显示在前台。所以一般来说耗时的数据存储等工作应该放在onStop中完成。此外，在Activity被异常杀死的时候，会完整的经历onPause，onStop，onDestroy过程。并不是直接就被杀死了。从时序上，onRestoreInstanceState的调用时机是在onStart之后。  </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android BroadcastReceiver 的静态动态注册及区别]]></title>
      <url>/2018/03/04/2018-3-4-135539/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了方便Android系统各个应用程序及程序内部进行通信，Android系统引入了一套广播机制。各个应用程序可以对感兴趣的广播进行注册，当系统或者其他程序发出这条广播的时候，对发出的广播进行注册的程序便能够收到这条广播。为此，Android系统中有一套完整的API，允许程序只有的发送和接受广播。<br>本文会分别介绍静态注册广播和动态注册广播的方法并比较这两种的区别。   </p>
<p><strong>在此会先说明发送广播的两种方法</strong></p>
<h1 id="广播两种基本类型"><a href="#广播两种基本类型" class="headerlink" title="广播两种基本类型"></a>广播两种基本类型</h1><p>在一个程序中，可以发送广播供当前程序的广播接收器收到。首先我们来看下两种方式的发送广播。<br>在Android系统中，主要有两种基本的广播类型：  </p>
<ul>
<li>标准广播（Normal Broadcasts）  </li>
<li>有序广播（Ordered Broadcasts）  <h2 id="标准广播"><a href="#标准广播" class="headerlink" title="标准广播"></a>标准广播</h2></li>
</ul>
<p>是一种完全异步执行的广播，在广播发出之后，所有的广播接收器会在同一时间接收到这条广播，广播无法被截断。   </p>
<p>发送广播的方式十分简单，只需要实例化一个<strong>Intent</strong>对象，然后调用<strong>context</strong>的<strong> sendBroadcast() </strong>方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//intent中的参数为action</span><br><span class="line">Intent intent=new Intent(&quot;com.example.dimple.BROADCAST_TEST&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>
<p>这样就完成了广播的发送，至于接收呢，需要用到广播接收器，这个下面会写到。  </p>
<h2 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h2><p>是一种同步执行的广播，在广播发出之后，优先级高的广播接收器可以优先接收到这条广播，并可以在优先级较低的广播接收器之前截断停止发送这条广播。    </p>
<p>至于有序广播：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//intent中的参数为action</span><br><span class="line">Intent intent=new Intent(&quot;com.example.dimple.BROADCAST_TEST&quot;);</span><br><span class="line">sendOrderBroadcast(intent，null);//第二个参数是与权限相关的字符串。</span><br></pre></td></tr></table></figure></p>
<p>到此时，如果你的程序中只有一个广播接收器的话，是体现不出有序广播的特点的，<br>右击包名——New——Other——BroadcastReceiver多创建几个广播接收器。 </p>
<p>此时你还是会发现，所有的广播接收器是同时接收到广播消息的。注意上面介绍的时候说到优先级，这个时候我们需要设置优先级，在AndroidManifest文件中的Receiver标签中设置广播接收器的优先级。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.MyReceiver&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;!--注意此时有一个Priority属性--&gt;</span><br><span class="line">    &lt;intent-filter android:priority=&quot;100&quot;&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BROADCAST_TEST&quot;&gt;&lt;/action&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>优先级越高的广播接收器可以先收到广播，也可以在收到广播的时候调用<strong>abortBroadcast()</strong>方法截断广播。优先级低的广播接收器就无法接收到广播了。</p>
<h1 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h1><h2 id="自定义BroadcastReceiver"><a href="#自定义BroadcastReceiver" class="headerlink" title="自定义BroadcastReceiver"></a>自定义BroadcastReceiver</h2><p>在Android的广播接收机制中，如果需要接收广播，就需要创建广播接收器。而创建广播接收器的方法就是<strong>新建一个类（可以是单独新建类，也可以是内部类（public））</strong> 继承自<strong>BroadcastReceiver</strong>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class myBroadcastReceiver extends BroadcastReceiver&#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">         //接收到广播的处理，注意不能有耗时操作，当此方法长时间未结束，会报错。</span><br><span class="line">         //同时，广播接收器中不能开线程。</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="两种注册方法"><a href="#两种注册方法" class="headerlink" title="两种注册方法"></a>两种注册方法</h2><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>所谓动态注册是指在代码中注册。步骤如下 ：  </p>
<ul>
<li>实例化自定义的广播接收器。</li>
<li>创建<strong>IntentFilter</strong>实例。  </li>
<li>调用<strong>IntentFilter</strong>实例的<strong>addAction()</strong>方法添加监听的广播类型。 </li>
<li>最后调用<strong>Context</strong>的<strong>registerReceiver(BroadcastReceiver,IntentFilter)</strong>动态的注册广播。  </li>
</ul>
<p>此时，已经为我们自定义的广播接收器绑定了广播，当收到和绑定的广播一直的广播的时候，就会调用广播接收器中的<strong>onReceiver</strong>方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyBroadcastReceiver myBroadcastReceiver=new MyBroadcastReceiver();</span><br><span class="line">IntentFilter intentFilter=new IntentFilter();</span><br><span class="line">intentFilter.addAction(&quot;com.example.dimple.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(myBroadcastReceiver,intentFilter);</span><br></pre></td></tr></table></figure>
<p>PS:这里提醒一点，如果需要接收系统的广播（比如电量变化，网络变化等等），别忘记在AndroidManifest配置文件中加上权限。  </p>
<p>另外，动态注册的广播在活动结束的时候需要取消注册：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    unregisterReceiver(myBroadcastReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>这里我们使用静态注册来接收开机广播。<br>使用Android Studio 中的快捷方法来创建广播接收器。  </p>
<p>右击包名——New——Other——BroadcastReceiver。  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-20183414490.png" alt="{mdFileName}-20183414490">  </p>
<p>PS：静态注册的广播接收器需要在AndroidManifest文件中注册，由于使用的AS的快捷方式，所以已经创建好了。<br>如图所示：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201834145034.png" alt="{mdFileName}-201834145034">  </p>
<p>在创建好的广播接收器中添加一个Toast提示。代码如下：    </p>
<figure class="highlight plain"><figcaption><span>class MyReceiver extends BroadcastReceiver &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        Toast.makeText(context,&quot;开机启动！&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在AndroidManifest文件中添加：  </p>
<ul>
<li><p>权限<br><code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;&lt;/uses-permission&gt;</code>    </p>
</li>
<li><p>Intent-filter  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.MyReceiver&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;!--添加以下3行--&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;&lt;/action&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>此时重启Android系统就可以收到开机提示了。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态注册和静态注册的区别：  </p>
<ul>
<li><p>动态注册的广播接收器可以自由的控制注册和取消，有很大的灵活性。但是只能在程序启动之后才能收到广播，此外，不知道你注意到了没，广播接收器的注销是在onDestroy()方法中的。所以广播接收器的生命周期是和当前活动的生命周期一样。  </p>
</li>
<li><p>静态注册的广播不受程序是否启动的约束，当应用程序关闭之后，还是可以接收到广播。</p>
</li>
</ul>
<p>标准广播和有序广播的接收和发送都是全局性的，这样会使得其他程序有可能接收到广播，会造成一定的安全隐患。为了解决这个问题，Android系统中有一套本地广播的机制。这个机制是让所有的广播事件（接收与发送）都在程序内部完成。主要是采用的一个<strong>localBroadcastReceiver</strong>对广播进行管理。  </p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android学习之路笔记]]></title>
      <url>/2018/01/29/2018-1-29-220254/</url>
      <content type="html"><![CDATA[<p>最近是看了下大二上学期的时候学习Android的一些笔记资料，觉得以前是写的还有需要改进的地方，所以准备再重新整理整理发出来。学习Android的时候，是采用的视频+文档结合的方式。书呢看的是：郭大神的《第一行代码》。所以本篇笔记还是按照郭大神的目录来进行记录的。  </p>
<h1 id="第一章：了解全貌——Android王国简介"><a href="#第一章：了解全貌——Android王国简介" class="headerlink" title="第一章：了解全貌——Android王国简介"></a>第一章：了解全貌——Android王国简介</h1><p> 1、Android的四层架构：Linux内核层、系统运行库层、应用框架层和应用层<br> 2、Android的四大组件：活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）<br> 3 、使用res目录下的资源的两种方式     </p>
<pre><code>例如：
    使用Res/values/string.xml文件，内容如下   
&lt;resources&gt;
    &lt;string name=&quot;app_name&gt;HrlloWorld&lt;/string&gt;
&lt;/resources&gt;
在代码中采用R.string.app_name获得HelloWorld的引用
在XML中通过@string/app_name获得引用
</code></pre><p> 4、app下的build.grade文件分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;   应用的插件，有两种值可以选，com.android.application 表示这是一个应用程序模块，com.android.library表示这是一个库模块。</span><br><span class="line">                                         应用程序模块和库模块的最大区别是应用程序模块是可以直接运行的，而库模块只能作为代码库依赖于其他应用程序模块来运行。</span><br><span class="line">android</span><br><span class="line">   compileSdkVersion 25   项目编译的版本</span><br><span class="line">   buildToolsVersion &quot;25.0.2&quot;   项目构建工具的版本</span><br><span class="line">   defaultConfig &#123;  对项目的更多细节进行配置</span><br><span class="line">       applicationId &quot;com.example.dimple.alertdialog&quot;   指定项目的包名</span><br><span class="line">       minSdkVersion 25    指定项目最低兼容的安卓版本</span><br><span class="line">       targetSdkVersion 25    表示Android25上已经做了充分的测试，</span><br><span class="line">       versionCode 1      指定项目的版本号</span><br><span class="line">       versionName &quot;1.0&quot;    指定项目的版本名</span><br><span class="line">       testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   buildTypes &#123; 用于指定安装文件的相关配置</span><br><span class="line">       release &#123;</span><br><span class="line">           minifyEnabled false   表示是否对项目进行代码混淆</span><br><span class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;  指定混淆的时候使用的规则文件</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">dependencies &#123;  指定当前项目的依赖关系，Android中一共有三种依赖方式：本地依赖、库依赖、远程依赖。</span><br><span class="line">                本地依赖可以对本地的jar包或者目录添加依赖关系，库依赖可以对项目中的库模块进行添加依赖关系。</span><br><span class="line">                远程依赖可以对jcenter库上的开源项目添加依赖关系。</span><br><span class="line">   compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])   本地依赖声明，表示将lib目录下的所有的jar文件添加到项目的构建路径中</span><br><span class="line">   androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123;</span><br><span class="line">       exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;</span><br><span class="line">   &#125;)</span><br><span class="line">   compile &apos;com.android.support:appcompat-v7:25.3.0&apos;   标准的远程依赖库格式，其中“com.android.support”是域名部分，用于和其他公司的库作区分。</span><br><span class="line">                                                        “appcompat-v7”是组名称，用于和同一个公司的不同的库作区分。“25.3.0”是版本号，用于和同一个库的不同版本作区分。</span><br><span class="line">   compile &apos;com.android.support.constraint:constraint-layout:1.0.1&apos;</span><br><span class="line">   testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第二章-先从看得到的入手——探究活动"><a href="#第二章-先从看得到的入手——探究活动" class="headerlink" title="第二章 先从看得到的入手——探究活动"></a>第二章 先从看得到的入手——探究活动</h1><h2 id="1、Genenate-Layout-File-是表示自动为Activity创建一个布局，Launcher-Activity表示将当前活动设置为主活动。"><a href="#1、Genenate-Layout-File-是表示自动为Activity创建一个布局，Launcher-Activity表示将当前活动设置为主活动。" class="headerlink" title="1、Genenate Layout File 是表示自动为Activity创建一个布局，Launcher Activity表示将当前活动设置为主活动。"></a>1、Genenate Layout File 是表示自动为Activity创建一个布局，Launcher Activity表示将当前活动设置为主活动。</h2><h2 id="2、配置主活动的方法：在Manifest中的Activity标签中添加标签，并在这个标签中添加"><a href="#2、配置主活动的方法：在Manifest中的Activity标签中添加标签，并在这个标签中添加" class="headerlink" title="2、配置主活动的方法：在Manifest中的Activity标签中添加标签，并在这个标签中添加"></a>2、配置主活动的方法：在Manifest中的Activity标签中添加<intent-filter>标签，并在这个标签中添加</intent-filter></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">&lt;category android:name-&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3、在活动中使用Menu"><a href="#3、在活动中使用Menu" class="headerlink" title="3、在活动中使用Menu"></a>3、在活动中使用Menu</h2><p>在res中新建Menu文件夹，创建XML文件，然后在相应的Java代码中重写onCreateOptionMenu()和onOptionItemSelect()方法。  </p>
<p>在onCreateOptionMenu()方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean onCreateOptionMenu()</span><br><span class="line">&#123;</span><br><span class="line">   getMenuInflater().inflater(R.menu.main,menu);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onOptionItemSelect()用于响应用户的事件。在此函数中，可以通过:<strong>item.getItemId</strong>判断点击的是哪一个菜单项。  </p>
<h2 id="4、销毁一个活动使用finish-函数，效果和按下back键是一样的"><a href="#4、销毁一个活动使用finish-函数，效果和按下back键是一样的" class="headerlink" title="4、销毁一个活动使用finish()函数，效果和按下back键是一样的"></a>4、销毁一个活动使用finish()函数，效果和按下back键是一样的</h2><h2 id="5、使用Intent"><a href="#5、使用Intent" class="headerlink" title="5、使用Intent"></a>5、使用Intent</h2><blockquote>
<p>Intent是Android程序中各组件之间进行交互的主要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同的组件之间进行数据的传递。Intent一般可以用于启动活动，启动服务，以及发送广播等场景。  </p>
</blockquote>
<p>Intent有多个构造函数：<strong>Intent(Context packageContext,Class&lt;?&gt;cls)</strong>；第一个参数Context要求提供一个启动活动的上下文，第二个参数class用于指定想要启动的目标。  </p>
<p>使用<strong>StartActivity(Intent intent)</strong>；启动活动。  </p>
<p>使用隐式的Intent启动方法  </p>
<p>在需要启动的活动的Manifest文件中配置Intent-filter 中的action和category<br>然后使用Intent的构造函数，传进去action和category，如果category是默认的话就可以不用传入进去。  </p>
<p>如果不是默认的，需要使用<strong>intent.addcategory();</strong>  </p>
<p>Intent的其他用法：<br>打开网页、拨号、<br>Intent向下一个活动传递数据  </p>
<p>使用<strong>intent.putExtra(String name,boolean/String value)</strong>函数，此方法就可以将想要存放的数据暂存在Intent中。第一个参数是键，第二个参数是要传入的数据。  </p>
<p><strong>getStringExtra(String name)</strong>和<strong>getIntExtra(String name)</strong>等系列方法可以获得数据。  </p>
<h2 id="6、Intent向上一个活动传递数据。"><a href="#6、Intent向上一个活动传递数据。" class="headerlink" title="6、Intent向上一个活动传递数据。"></a>6、Intent向上一个活动传递数据。</h2><p>使用<strong>startActivityForResult(Intent intent,int requestCode)</strong>方法在A中来启动Activity B；第一个参数是Intent，第二个参数是请求码，用于在回调之后来判断数据的来源。  </p>
<p>在B中Intent中<strong>putExtra(String name,value)</strong>来返回要传递的数据。  </p>
<p>同时调用ApplicationContext的<strong>setResult(int requestCode,intent data)</strong>方法，第一个参数是要上一个活动A传递的处理结果，一般只使用<strong>RESULT_OK</strong>或<strong>RESULT_CANCELED</strong>两个值，第二个参数将带有数据的Intent返回。  </p>
<p>在A中重写<strong>onActivityResult(int requestCode,int resultCode,Intent intent)</strong>方法，此方法有三个参数，第一个参数requestCode是我们在A中使用<strong>startActivityForResult()</strong>方法传入的，第二个参数是resultCode是在B中返回数据的时候传入的setResult方法中的结果码。第三个参数是传入的数据的Intent对象。  </p>
<p>一般是重写back键按下之后回调的方法：<strong>onBackPressed()</strong>;</p>
<h2 id="7、活动的生命周期"><a href="#7、活动的生命周期" class="headerlink" title="7、活动的生命周期"></a>7、活动的生命周期</h2><ul>
<li>当活动被首次创建的时候：<br>会依次调用：    onCreate()方法、onStart()方法、onResume方法。  </li>
<li>当从当前的活动跳转到另一个界面的时候（当前活动不可见）<br>会依次调用：      onPause()方法、onStop()方法  </li>
<li>当从其他活动再跳转回来的时候<br>会依次调用：     onRestart()方法、onStart()方法、onResume()方法  </li>
<li>当从当前活动跳转自另一个活动的时候（当前活动可见）<br>会依次调用：    onPause()方法   </li>
<li>当从这个活动跳转会主活动的时候<br>会依次调用：    onResume()方法  </li>
<li>结束当前活动的时候<br>会依次调用：     onDestory()方法  <h1 id="第三章-常用控件的使用方法"><a href="#第三章-常用控件的使用方法" class="headerlink" title="第三章 常用控件的使用方法"></a>第三章 常用控件的使用方法</h1><h2 id="ListView的使用"><a href="#ListView的使用" class="headerlink" title="ListView的使用"></a>ListView的使用</h2><h3 id="listView-的简单用法"><a href="#listView-的简单用法" class="headerlink" title="listView 的简单用法"></a>listView 的简单用法</h3><pre><code>首先，需要在布局中加入ListView控件，然后需要定义适配器（一般是ArrayAdapter）
</code></pre>ArrayAdapter<string>adapter=new ArrayAdapter<string>(<br>  context,resourse,data);<br>listView.setAdapter(adapter);<h3 id="ListView之自定义适配器"><a href="#ListView之自定义适配器" class="headerlink" title="ListView之自定义适配器"></a>ListView之自定义适配器</h3>  首先先创建一个类，这个类中包含了需要进行自定义适配器需要用到的相关资源文件，此类为JAVABean。<br>此外，还需要一个适配器，适配器继承自ArrayAdapter&lt;&gt;并泛型为定义的类。在此适配器中，重写getView()方法。   </string></string></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/***  </span><br><span class="line">* 自定义适配器,继承自ArrayAdapter,并将泛型指定为Fruit类  </span><br><span class="line">*/  </span><br><span class="line">class MyAdapter extends ArrayAdapter&lt;Fruit&gt;&#123;  </span><br><span class="line">   /**  </span><br><span class="line">    *  </span><br><span class="line">    * @param context  </span><br><span class="line">    * @param resource  </span><br><span class="line">    * @param objects  </span><br><span class="line">    */  </span><br><span class="line">   private  int Resource;  </span><br><span class="line">   public MyAdapter(@NonNull Context context, @LayoutRes int resource, @NonNull List&lt;Fruit&gt; objects) &#123;  </span><br><span class="line">       super(context, resource, objects);  </span><br><span class="line">       Resource=resource;  </span><br><span class="line">   &#125;  </span><br><span class="line">​  </span><br><span class="line">   @NonNull  </span><br><span class="line">   @Override  </span><br><span class="line">   public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;  </span><br><span class="line">       View view;  </span><br><span class="line">       ViewHolder viewHolder;  </span><br><span class="line">       Fruit fruit=getItem(position);    </span><br><span class="line">       if (convertView==null)&#123;  </span><br><span class="line">           view= LayoutInflater.from(getContext()).inflate(Resource,parent,false);  </span><br><span class="line">           viewHolder-new ViewHolder();  </span><br><span class="line">           viewHolder.ImageView imageView=view.findViewById(R.id.imageView);  </span><br><span class="line">           viewHolder.TextView textView=view.findViewById(R.id.textView);  </span><br><span class="line">           view.setTag(viewHolder);//将ViewHolder存储在View中</span><br><span class="line">       &#125;else&#123;  </span><br><span class="line">           view=convertView;  </span><br><span class="line">           viewHolder=(ViewHolder)getTag();//重新获取ViewHolder  </span><br><span class="line">       &#125;  </span><br><span class="line">       imageView.setImageResource(fruit.getFruitImage());  </span><br><span class="line">       textView.setText(fruit.getFruitName());  </span><br><span class="line">       return view;  </span><br><span class="line">   &#125;  </span><br><span class="line">   class ViewHolder()&#123;  </span><br><span class="line">       ImageView fruitImage;  </span><br><span class="line">       TextView fruitName;  </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中<strong>getItem()</strong>方法是每个子项滚动到屏幕类的时候被调用。   convertView将之前的项目进行缓存。<br>新建一个内部类ViewHolder，用于对实例对象进行缓存，把控件的实例都存放在viewHolder中，然后调用View的setTag()方法，将ViewHolder对象保存在View中，当convertView不为null的时候，调用View中的getTag()方法，将ViewHolder取出。这样系统每次就不用通过findViewById()来获取控件实例。<br>    点击事件需要设置监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       @Override</span><br><span class="line">       public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;</span><br><span class="line">          Fruit fruit=fruitList.get(i);</span><br><span class="line">           Toast.makeText(getApplicationContext(),&quot;position&quot;+i+fruit.getFruitName(),Toast.LENGTH_LONG).show();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RecyclerView使用"><a href="#RecyclerView使用" class="headerlink" title="RecyclerView使用"></a>RecyclerView使用</h2><p>由于是新增的部件，所以需要添加依赖包  </p>
<p><code>compile &#39;com.android.support:recyclerview-v7:26.+&#39;  //此处需要注意的是V7:后的，是appcompat后面的版本号</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">      initData();//初始化集合List中的数据</span><br><span class="line">       RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerview);</span><br><span class="line">       FruitAdapter adapter = new FruitAdapter(fruitList);</span><br><span class="line">       /**</span><br><span class="line">        * 这里用于指定RecyclerView的布局方式</span><br><span class="line">        */</span><br><span class="line">       LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext());</span><br><span class="line">       recyclerView.setLayoutManager(linearLayoutManager);</span><br><span class="line">       recyclerView.setAdapter(adapter);</span><br><span class="line">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123;</span><br><span class="line">   private List&lt;Fruit&gt;mFruitList;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 构造函数用于将要展示的数据传入，并赋值给一个全局变量mFruitList。</span><br><span class="line">        * @param mFruitList</span><br><span class="line">        */</span><br><span class="line">       public FruitAdapter(List&lt;Fruit&gt; mFruitList) &#123;</span><br><span class="line">           this.mFruitList = mFruitList;</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * 首先定义了一个内部类ViewHolder，ViewHolder要继承自RecyclerView.ViewHolder，然后ViewHolder的构造函数要传入一个view参数</span><br><span class="line">        * 这个参数通常就是RecyclerView子项最外层的布局。</span><br><span class="line">        */</span><br><span class="line">       static class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class="line">           ImageView fruitImage;</span><br><span class="line">           private View fruitView;//设置view点击事件  添加此变量来保存子项最外层的布局的实例</span><br><span class="line">           TextView fruitName;</span><br><span class="line">           public ViewHolder(View view) &#123;</span><br><span class="line">               super(view);</span><br><span class="line">               fruitView=view;//获取View</span><br><span class="line">               fruitImage=view.findViewById(R.id.imageView);</span><br><span class="line">               fruitName=view.findViewById(R.id.textView);</span><br><span class="line">    ​</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * onCreateViewHolder()是用于创建ViewHolder实例的，在这个方法中，将布局加载到ViewHolder的实例中，然后将ViewHolder实例返回</span><br><span class="line">        * @param parent</span><br><span class="line">        * @param viewType</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public FruitAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">           View view= LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false);</span><br><span class="line">    ​</span><br><span class="line">           final ViewHolder holder=new ViewHolder(view);</span><br><span class="line">           /**</span><br><span class="line">            * ViewHolder设置点击事件</span><br><span class="line">            */</span><br><span class="line">           holder.fruitView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onClick(View view) &#123;</span><br><span class="line">                   /*</span><br><span class="line">                   通过ViewHolder的getAdapterPosition获得position</span><br><span class="line">                   然后可以通过该位置在List中获取实例</span><br><span class="line">                    */</span><br><span class="line">                   int position =holder.getAdapterPosition();</span><br><span class="line">                   Fruit fruit=mFruitList.get(position);</span><br><span class="line">                   Toast.makeText(view.getContext(),&quot;this is &quot;+ fruit.getFruitName(),Toast.LENGTH_LONG).show();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           return holder;</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * 用于对RecyclerView子项的数据进行赋值，当每个子项被滚动到屏幕内的时候被调用</span><br><span class="line">        * @param holder</span><br><span class="line">        * @param position</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public void onBindViewHolder(FruitAdapter.ViewHolder holder, int position) &#123;</span><br><span class="line">           Fruit fruit=mFruitList.get(position);</span><br><span class="line">           holder.fruitImage.setImageResource(fruit.getFruitImage());</span><br><span class="line">           holder.fruitName.setText(fruit.getFruitName());</span><br><span class="line">       &#125;</span><br><span class="line">    ​</span><br><span class="line">       /**</span><br><span class="line">        * 返回当前要加载的数据源的长度</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public int getItemCount() &#123;</span><br><span class="line">           return mFruitList.size();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>瀑布流使用： StaggeredGridLayoutManager  设置瀑布流的布局方式  </p>
<p>如果需要设置为横向滑动的话就需要在MainActivity中的LinearLayoutManager设置方向</p>
<p>  linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);</p>
<p>使用步骤：</p>
<p>获取RecyclerView实例——设置layoutManager布局对象——绑定适配器<br>创建JavaBean类<br>创建适配器——继承自《RecyclerView.Adapter<javabean.viewholder>》（ViewHolder为内部类）——创建ViewHolder内部类继承自RecyclerView.ViewHolder并完成控件的初始化——创建构造器进行相关数据的传入——重写onCreaterViewHolder()、onBindViewHolder()、getItemCount()方法。<br>重写onCreateViewHolder()方法——获取View对象，创建ViewHolder实例，返回ViewHolder实例（同时可以设置点击事件）<br>重写onBindViewHolder()方法（对子项的数据进行赋值操作，通过Position获取实例）——将数据设置到ViewHolder中的控件实例中。  </javabean.viewholder></p>
<h1 id="第四章-碎片"><a href="#第四章-碎片" class="headerlink" title="第四章 碎片"></a>第四章 碎片</h1><h2 id="碎片的静态加载"><a href="#碎片的静态加载" class="headerlink" title="碎片的静态加载"></a>碎片的静态加载</h2><p>在MainActivity的布局文件中添加<fragment>的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;fragment  </span><br><span class="line">       android:id=&quot;@+id/id_fragment_title&quot;  </span><br><span class="line">       android:name=&quot;com.zhy.zhy_fragments.TitleFragment&quot;  </span><br><span class="line">       android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">       android:layout_height=&quot;45dp&quot; /&gt;</span><br></pre></td></tr></table></figure></fragment></p>
<p>在TitleFragment的布局文件和JAVA文件中进行操作<br>在java文件中重写onCreateView方法，注意要继承只V4包的Fragment。  </p>
<h2 id="碎片的动态加载"><a href="#碎片的动态加载" class="headerlink" title="碎片的动态加载"></a>碎片的动态加载</h2><p>在MainActivity的布局文件中声明一个区域作为碎片出现的位置 。<br>找MainActivity的JAVA文件中首先设置默认的显示的Fragment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prvate void setDefaultFragment()&#123;</span><br><span class="line">   FragmentManager fm =getFragmentManager();</span><br><span class="line">   FragmentTransaction transaction = fm.beginTransaction();</span><br><span class="line">   FragmentOne one=new FragmentOne();</span><br><span class="line">   transaction.replace(R.id.mainactivity_fragment,one);</span><br><span class="line">   transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Fragment常用的API："><a href="#Fragment常用的API：" class="headerlink" title="Fragment常用的API："></a>Fragment常用的API：</h3><p>Fragment常用的三个类</p>
<p>要用于定义Fragment。</p>
<ul>
<li>android.app.FragmentManager主要用于在Activity中操作Fragment。</li>
<li>android.app.FragmentTransaction保证一系列Fragment操作的原子性。</li>
</ul>
<p>获取FragmentManager的方式  </p>
<ul>
<li>getFragmentManager()  //在V4包中，getSupportFragmentManager()</li>
</ul>
<p>主要的操作中都是FragmentTransaction的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    FragmentManager fm =getSupportFragmentManager();  </span><br><span class="line">    FragmentTransaction transaction = fm.beginTransaction();//开启一个事务  </span><br><span class="line">    transaction.add(); //向Activity中添加一个Fragment  </span><br><span class="line">    transaction.remove();//从Activity中移除一个Fragment  </span><br><span class="line">    transaction.replace();//使用另一个Fragment替换掉当前的Fragment，实际上是remove()和add()的合体  </span><br><span class="line">    transaction.show();//显示之前隐藏的Fragment  </span><br><span class="line">    transaction.hide();//隐藏当前的Fragment，仅仅设置为隐藏，并不会销毁  </span><br><span class="line">    transaction.commit();//提交一个事务 </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">注：如果希望保留用户在当前fragment的数据，就使用hide()和show()组合，这样不会销毁当前的Fragment  </span><br><span class="line">        如果不希望保留用户当前在Fragment的数据，就使用remove()和add()组合或者直接使用replace()，这样就会销毁当前的Fragment，再进去的时候就会重新加载  </span><br><span class="line">        如果使用replace的话，当程序已经不在当前的界面的时候，在其他界面按Back键的时候，将不会返回到这个界面，直接退出  </span><br><span class="line">        想要保留这个fragment的话，就需要将它添加到回退栈中：   ** transaction.addToBackStack();**  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[参考博客](http://blog.csdn.net/lmj623565791/article/details/37970961/)</span><br><span class="line"></span><br><span class="line"># 第五章 广播</span><br><span class="line"></span><br><span class="line">## 1、广播的两种类型</span><br><span class="line"></span><br><span class="line">- 标准广播  广播发出后，所有的广播接收器会在同一时间接收到这条广播。效率较高，无法截断。</span><br><span class="line">- 有序广播  广播发出后，同一时刻只有一个广播接收器能够接收到这条广播，并且优先级高的可以先接收到这条广播，并且前面的广播接收器可以截断广播。</span><br><span class="line"></span><br><span class="line">## 2、注册广播的两种方式</span><br><span class="line"></span><br><span class="line">    在代码中注册——动态注册——在程序关闭之后就不能再接收到广播  </span><br><span class="line">    在AndroidManifest中注册——静态注册——与程序是否关闭无关(开机状态就能被唤醒)  </span><br><span class="line"></span><br><span class="line">## 3、创建广播接收器的方法</span><br><span class="line">新建一个类，继承自BroadcastReceiver，并重写父类的onReceive()方法。  </span><br><span class="line">这样，当有广播到来的时候，onReceive()方法就会得到调用。  </span><br><span class="line">## 4、动态注册广播的方法</span><br><span class="line">创建IntentInfilter的实例，添加一个action</span><br></pre></td></tr></table></figure></p>
<pre><code>IntentInfilter intentInfliter =new IntentInfliter();//创建IntentFilter实例  
intentInfilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);//为这个IntentFilter添加action  
registerReceiver(networkChageReceiver,interFilter);//动态注册广播，这样networkChangeReceiver就会接收到所有值为android.net.conn.CONNECTIVITY_CHANGE的广播
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**动态注册的广播需要取消注册，在onDestory中调用unRegisterReceiver()方法来实现的。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5、静态注册广播的方法</span><br><span class="line"></span><br><span class="line">使用android Studio的快捷键创建一个广播接收器，点击包名——New——Other——Broadcast Receiver，Exported表示是否允许广播接收器接收本程序以外的广播，Enable表示是否启用这个广播。  </span><br><span class="line"></span><br><span class="line">（静态注册的广播接收器必须要在AndroidManifest中注册才能使用，使用Android Studio创建的广播接收器已经在AndroidManifest中注册了）</span><br><span class="line">注册方式信息如下：</span><br></pre></td></tr></table></figure>
<pre><code>    &lt;receiver
        android:name=&quot;.MyReceiver&quot;
        android:enabled=&quot;true&quot;//是否启用该广播接收器
        android:exported=&quot;true&quot;&gt;//是否允许接受本程序之外的广播
        &lt;intent-filter  android:priority=&quot;100&quot;&gt;//priority是设置广播的优先级，优先级越高系统响应越快
            &lt;action android:name=&quot;android.intent.action.BATTERY_LOW&quot;/&gt;//当系统低电量的时候就会发出这个广播
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在&lt;intent-filter&gt;标签中添加相应的Action标签</span><br><span class="line"></span><br><span class="line">**注意某些操作需要用到权限，需要在Manifest中添加权限。**</span><br><span class="line"></span><br><span class="line">此外，在onReceive中不能添加太多的逻辑以及耗时操作，在广播接收器中是不允许多开线程的，当此方法运行了太长时间而没有结束，程序会报错。</span><br><span class="line"></span><br><span class="line">发送动态广播的方法：</span><br></pre></td></tr></table></figure>
<pre><code>Intent intent=new Intent(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);
sendBroadcast(intent);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 6、自定义广播</span><br><span class="line"></span><br><span class="line">创建一个自定义的广播接收器继承自BroadcastReceicer，并重写onReceive()方法。</span><br><span class="line">然后使用Intent发送广播。</span><br><span class="line"></span><br><span class="line">- 有序广播  </span><br><span class="line">在Manifest中的Broadcast标签的Intent-filter中设置优先级属性priority  </span><br><span class="line">发送广播的时候与标准广播不同  </span><br><span class="line">**sendOrderBroadcast(intent,null)**//第一个是Intent实例，第二个是与权限相关的字符串，这里传入null  </span><br><span class="line">- 截断广播  </span><br><span class="line">**abortBroadcast()**;//在广播接收器中调用这个方法就可以截断广播</span><br><span class="line"></span><br><span class="line">## 7、本地广播  </span><br><span class="line">    本地广播的出现是为了解决广播在整个系统中运行中的安全性的问题，全局广播会被其他程序所截获，造成信息泄露。  </span><br><span class="line">    本地广播的用法  </span><br><span class="line">主要是使用一个LocalBroadcastManager来对广播进行管理，并提供了发送广播和和注册广播的方法。</span><br></pre></td></tr></table></figure>
<pre><code>localBroadcastManager=LocalBroadcastManager.getInstance(getApplicationContext());
      Button button= (Button) findViewById(R.id.button);
      button.setOnClickListener(new View.OnClickListener() {
          @Override
          public void onClick(View v) {
              Intent intent=new Intent(&quot;com.example.dimple.mytest.MYMY&quot;);
              localBroadcastManager.sendBroadcast(intent);
          }
      });
      IntentFilter intentFilter=new IntentFilter();
      intentFilter.addAction(&quot;com.example.dimple.mytest.MYMY&quot;);
      localBroadcastManager.registerReceiver(new MyReceiver(),intentFilter);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">**本地广播只能通过动态注册。**</span><br><span class="line"></span><br><span class="line">**获取步骤**  </span><br><span class="line">- 通过LocalBroadcastMaager的**getInstance()**方法得到实例。  </span><br><span class="line">- 然后注册广播的时候就调用LocalBroadcastManager的**registerRecriver()**方法.  </span><br><span class="line">- 在发送广播的时候就调用LocalBroadcastManager的**sendBroadcastManager()**方法。</span><br><span class="line"></span><br><span class="line"># 第六章 存储</span><br><span class="line">## 1、使用SharedPreferences</span><br><span class="line">SharedPreferences是采用键值对的方式来存储数据的。  </span><br><span class="line">要使用SharedPreferences需要首先获得SharedPreferences对象。获取该对象的方式有：  </span><br><span class="line">- Context类中的**getSharedPreferences(String name,int mode)**方法，接收两个参数，第一个参数是文件的名称，第二个参数指定操作模式MODE，目前只能选择MODE_PRIVATE。  </span><br><span class="line">- Activity类中的**getPreferences(int mode)**方法，和**getSharePreferences(String name,int mode)**差不多，区别是使用**getPreferences(int mode)**会使用当前的类名作为文件名。  </span><br><span class="line">- PreferencesManager类中的**getDefaultSharedPreferences(Context context)**方法 ，这是一个静态方法，接收一个context参数，会自动将当前的应用程序的包名作为前缀来命名SharePreferences文件 </span><br><span class="line"></span><br><span class="line">**使用步骤**  </span><br><span class="line">调用sharedPreferences对象的editor()方法来获得一个 sharedPerferences.Editor()对象  </span><br><span class="line">向sharedPerferences.Editor()对象添加数据。调用editor的putString()等些列方法  </span><br><span class="line">调用editor的apply()方法提交数据。</span><br></pre></td></tr></table></figure>
<pre><code>SharedPreferences.Editor editor=getSharedPreferences(&quot;test&quot;,MODE_PRIVATE).edit();
editor.putString(&quot;name&quot;,&quot;Tom&quot;);
editor.apply();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**读取SharedPreferences的方法**  </span><br><span class="line"></span><br><span class="line">获取SharedPreferences对象，通过getString()系列方法得到数据。注意这里有两个参数，第一个是要读取的数据的键，第二个参数是没有找到这个数据返回的值。</span><br></pre></td></tr></table></figure>
<pre><code>SharedPreferences sharedPreferences=getSharedPreferences(&quot;test&quot;,MODE_PRIVATE);
sharedPreferences.getString(&quot;name&quot;,&quot;没有找到name属性的值&quot;);
</code></pre><p>```</p>
<h2 id="2、使用SQLite数据库进行存储"><a href="#2、使用SQLite数据库进行存储" class="headerlink" title="2、使用SQLite数据库进行存储"></a>2、使用SQLite数据库进行存储</h2><p>android中为了更好的管理数据库，提供了一个SQLiteOpenHelper的帮助类（抽象类），需要实现SQLiteOpenHelper抽象方法中的抽象方法onCreate()（在数据库被创建的时候会调用），onUpgrade()（在数据库版本被升级的时候被调用）  </p>
<p>获取实例的方法：(都可以打开或者创建数据库)<br>getReadableDatebase()只能是通过只读的方式来打开数据库。<br>getWritableDatebase()使用读写的方式打开数据库。  </p>
<p><strong>使用方法：</strong><br>新建一个JAVA类继承自SQLiteOpenHelper，实现两个抽象方法onCreate()和onUpgrade()，创建构造器（使用参数较少的那一个构造器），其参数有  </p>
<pre><code>Context context, String name, SQLiteDatabase.CursorFactory factory, int version
</code></pre><p>/<em><br>第一个参数是context上下文<br>第二个参数是数据库名<br>第三个参数允许在查询的时候返回一个自定义的Cursor，一般为null<br>第四个参数是当前数据库的版本号，可用于对数据库的更新操作
</em>/</p>
<p>构建出SQLiteOpenHelper实例（new）以后，调用getReadableDatebase()或者getWritableDatebase()就可以创建数据库了。<br>创建的数据库的名字一般放在 /data/data/<package name="">/datebase目录下。</package></p>
<p>配置adb 在安卓SDK的目录下有一个platform-tools文件夹，将这个文件夹配置到系统的环境变量中，使用adb shell进入控制台终端</p>
<p>使用sqlite3 +数据库名称 打开数据库<br>使用.table 查看数据库中的表、<br>使用 .schema 查看建表语句  </p>
<p>3、向SQLite数据库中添加数据<br>调用SQLiteOpenHelper的getReadableDatebase()或者getWritableDatebase()创建数据库后会返回一个SQLiteDatabase对象，借助这个对象就可以对数据库进行CRUD操作<br><strong>添加数据</strong><br>    SQLiteDatabase提供一个insert()方法用于添加数据。这个方法有三个参数。第一个参数是数据库表名称，第二个是用于指定在未添加数据的情况下给某些数据项自动赋值为null，第三个参数是ContentValues对象，它提供一系列的put()方法重载，用于向contentValues添加数据。使用此方法的时候需要创建ContentValues对象。  </p>
<pre><code>sqLiteDatabase.insert(&quot;Book&quot;,null,contentValues);//插入信息到Book
</code></pre><p><strong>更新数据</strong><br>    SQLiteDatabase提供一个update()的方法，第一个参数是表名，第二个参数是ContentValues对象，第三四个参数用于约定更新某一行或者某几行的数据。  </p>
<pre><code>sqLiteDatabase.update(&quot;Book&quot;,contentValues,&quot;id=?&quot;,new String[]{&quot;1&quot;});//更新id为1的书的信息
第三个参数对应的是SQL的where语句，第四个提供约束的具体信息。
</code></pre><p><strong>删除数据</strong></p>
<pre><code>SQLiteDatabase提供一个delete()的方法，第一个参数是表名，第二三个参数用于约定删除某一行或者某几行的数据。   

 sqLiteDatabase.delete(&quot;Book&quot;,&quot;pages&gt;?&quot;,new String[]{&quot;500&quot;});//删除页数超过500页的书的信息  
</code></pre><p><strong>查询数据</strong>  </p>
<pre><code>query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit)方法各参数的含义：
</code></pre><ul>
<li><p>table：表名。相当于select语句from关键字后面的部分。如果是多表联合查询，可以用逗号将两个表名分开。</p>
</li>
<li><p>columns：要查询出来的列名。相当于select语句select关键字后面的部分。</p>
</li>
<li><p>selection：查询条件子句，相当于select语句where关键字后面的部分，在条件子句允许使用占位符“?”</p>
</li>
<li><p>selectionArgs：对应于selection语句中占位符的值，值在数组中的位置与占位符在语句中的位置必须一致，否则就会有异常。</p>
</li>
<li><p>groupBy：相当于select语句group by关键字后面的部分</p>
</li>
<li><p>having：相当于select语句having关键字后面的部分</p>
</li>
<li><p>orderBy：相当于select语句order by关键字后面的部分，如：personid desc, age asc;</p>
</li>
<li><p>limit：指定偏移量和获取的记录数，相当于select语句limit关键字后面的部分。  </p>
<pre><code>               sqLiteDatabase=mySqlite.getWritableDatabase();
               Cursor cursor=sqLiteDatabase.query(&quot;Book&quot;,null,null,null,null,null,null);//查询完毕后得到一个游标Cursor对象，通过这个对象去访问数据
               if (cursor.moveToFirst()){//将游标移动到第一行的位置
                   do{//接下来是循环
                       //在这个循环中可以通过Cursor的getColumnIndex()方法获取到某一行的索引。将这个索引传入相应的取值方法中就可以得到相应的数据了。
​
                       String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;));
                       String author =cursor.getString(cursor.getColumnIndex(&quot;author&quot;));
                       int pages=cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));
                       double price=cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));
                       builder.append(&quot;name\n&quot;).append(name).append(&quot;author\n&quot;).append(author).append(&quot;pages\n&quot;).append(pages).append(&quot;price\n&quot;).append(price);
                   }while (cursor.moveToNext());
                   textView.setText(builder);
               }
</code></pre></li>
</ul>
<h2 id="4、使用LitePal操作数据库"><a href="#4、使用LitePal操作数据库" class="headerlink" title="4、使用LitePal操作数据库"></a>4、使用LitePal操作数据库</h2><p><strong>配置过程</strong><br>    编辑app/build.gradle文件，在dependencies闭包中加入  </p>
<pre><code>compile &apos;org.litepal.android:core:1.3.2&apos;
</code></pre><p>然后在app/src/main目录新建一个assets目录，在此目录下创建一个litepal.xml文件  </p>
<pre><code>&lt;litepal&gt;  
    &lt;!--dbname标签用于指定数据库名，version标签用于指定数据库版本号，list标签用于指定所有的映射模型--&gt;  
    &lt;dbname value=&quot;BookStore&quot;&gt;&lt;/dbname&gt;
    &lt;version value =&quot;2&quot;&gt;&lt;/version&gt;
    &lt;list&gt;
        &lt;mapping class=&quot;com.example.dimple.sharedpreferencestest.Book&quot;&gt;&lt;/mapping&gt;
        &lt;mapping class=&quot;com.example.dimple.sharedpreferencestest.Category&quot;&gt;&lt;/mapping&gt;
    &lt;/list&gt;
&lt;/litepal&gt;
</code></pre><p>最后需要在AndroidManifest中将项目的application配置为  </p>
<pre><code>&lt;application
    android:name=&quot;org.litepal.LitePalApplication&quot;
    android:allowBackup=&quot;true&quot;
    android:icon=&quot;@mipmap/ic_launcher&quot;
</code></pre><p><strong>创建数据库：</strong><br>    使用面向对象的思想，定义一个Book类JavaBean类。<br>    将关系模型添加到映射模型列表中  </p>
<pre><code>&lt;mapping class=&quot;com.example.dimple.sharedpreferencestest.Book&quot;&gt;&lt;/mapping&gt;
</code></pre><p>注：不管需要多少关系模型，注意要使用完整的类名，不管需要多少模型类映射，都需要用同样的方式在<list>标签下配置。  </list></p>
<p>在代码中使用Connector.getDatabase()；创建数据库。  </p>
<p>升级版本号，就可以直接修改litepal.xml中的version即可。此升级不会删除数据库。  </p>
<p><strong>添加数据</strong><br>    需要将JavaBean类继承自DataSupport类。<br>    在java代码中，直接new一个JavaBean类的对象出来，然后调用set系列方法，最后调用DataSupport父类传下来的save()方法即可。</p>
<p><strong>更新数据</strong><br>直接new一个JavaBean对象出来，调用要修该的数据项的set函数，然后updataAll();  此方法可以设置约束条件  </p>
<pre><code>book.updateAll(&quot;name=?&quot;,&quot;the da vinvi code &quot;);//修改所有name=the da vinvi code的数据项。
</code></pre><p><strong>删除数据</strong>  </p>
<pre><code> DataSupport.deleteAll(Book.class,&quot;price&gt;?&quot;,&quot;17&quot;);
第一个参数是指定表，后面的参数是指定参数的数据项的属性。
</code></pre><p><strong>查询数据</strong><br>注：<br> for (Book book:bookList)的意思是循环bookList集合，每次取得的实例就给Book book；</p>
<p>List<book> bookList=DataSupport.findAll(Book.class);<br>findAll()返回的是一个List集合。  </book></p>
<p><strong>常用的查询API</strong></p>
<ul>
<li><p>查询第一条数据  </p>
<pre><code>Book book =DataSupport.findFirst(Book.class);  
</code></pre></li>
<li><p>查询最后一条数据  </p>
<pre><code>Book book =DataSupport.findLast(Book.class);  
</code></pre></li>
<li><p>select()方法可以指定查询那几列的数据。  </p>
<pre><code>List&lt;Book&gt; bookList =DataSupport.select(&quot;name&quot;,&quot;pages&quot;).find(Book.class);
</code></pre></li>
<li><p>where()方法可以指定查询的约束条件   </p>
<pre><code>List&lt;Book&gt; bookList =DataSupport.where(&quot;name=?&quot;,&quot;bianxiaofeng&quot;).find(Book.class);  
</code></pre></li>
<li><p>order()方法可以指定结果的排序方式  </p>
<pre><code>List&lt;Book&gt; bookList =DataSupport.order(&quot;pages desc&quot;).find(Book.class);
</code></pre></li>
<li><p>limit()方法可以指定结果的数量  </p>
<pre><code>List&lt;Book&gt; bookList =DataSupport.limit(3).find(Book.class);
</code></pre></li>
</ul>
<p>还可以对所有的方法进行连缀组合操作。  </p>
<h1 id="第七章-内容提供器"><a href="#第七章-内容提供器" class="headerlink" title="第七章 内容提供器"></a>第七章 内容提供器</h1><h2 id="1、内容提供器主要在不同的应用程序之间实现数据共享的功能。使用内容提供器是Android跨程序共享数据的标准方式。"><a href="#1、内容提供器主要在不同的应用程序之间实现数据共享的功能。使用内容提供器是Android跨程序共享数据的标准方式。" class="headerlink" title="1、内容提供器主要在不同的应用程序之间实现数据共享的功能。使用内容提供器是Android跨程序共享数据的标准方式。"></a>1、内容提供器主要在不同的应用程序之间实现数据共享的功能。使用内容提供器是Android跨程序共享数据的标准方式。</h2><h2 id="2、运行时权限"><a href="#2、运行时权限" class="headerlink" title="2、运行时权限"></a>2、运行时权限</h2><pre><code>权限分为普通权限和危险权限。危险权限分为9组24个。每一个危险权限都属于一个权限组，一旦用户同意了某个权限组的一个权限，则对应的权限组都可以被获得权限。  
</code></pre><p><strong>步骤：</strong><br>第一步需要判断用户是不是已经授权了。借助的是ContextCompat.setSelfPermission()方法。此方法接收两个参数：第一个是Context上下文，第二个是具体的权限名。<br> Manifest.permission.```。使用方法的返回值和PackageManager.PERMISSION_GEANTED作比较，相等就表示已经授权。不相等就表示没有授权。</p>
<p>如果授权的话就执行具体的逻辑。如果不等的话就说明还没有得到用户的权限的同意，这个时候需要申请用户的权限。</p>
<p>调用ActivityCompat.requestPermission()方法来向用户申请权限。requrestPermission接受三个参数，第一个参数是要求的Activity实例，第二个参数是String数组，这里需要把要申请的权限名写在里面，第三个是请求码，需要唯一。在这个方法中判断是否得到授权。</p>
<pre><code>//申请权限
if (ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission
                       .CALL_PHONE)!=PackageManager.PERMISSION_GRANTED){
                   ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest
                           .permission.CALL_PHONE},1);
               }else {
                  //do something else
               }
@Override
   public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
                                          @NonNull int[] grantResults) {
           switch (requestCode){
               case 1:
                   if (grantResults[0]==PackageManager.PERMISSION_GRANTED){
                       //do something else.
                   }else{
                       Toast.makeText(MainActivity.this,&quot;failed!&quot;,Toast.LENGTH_LONG).show();
                   }
           }
   }
</code></pre><h2 id="3、contentResolver的基本用法"><a href="#3、contentResolver的基本用法" class="headerlink" title="3、contentResolver的基本用法"></a>3、contentResolver的基本用法</h2><p>对于一个应用程序来说，如果访问内容提供器中的共享的数据，就一定要借助ContentResolver类。可以通过getContentReslover来获取该类的实例。  </p>
<p>使用inset()用于添加数据。update()用于更新数据。delete()用户删除数据。queny()用于查询数据。ContentReslover的增删查改需要接受Uri对象作为参数。  </p>
<p>和数据库的操作一样是使用ContentValues作为中转传数据。调用CRUD函数进行操作。</p>
<h1 id="第八章-运用手机多媒体"><a href="#第八章-运用手机多媒体" class="headerlink" title="第八章 运用手机多媒体"></a>第八章 运用手机多媒体</h1><h2 id="1、使用通知Notification"><a href="#1、使用通知Notification" class="headerlink" title="1、使用通知Notification"></a>1、使用通知Notification</h2><p>使用通知的步骤<br>首先需要一个NotificationManager来对通过通知进行管理，可以调用Context的getSystemService()方法来获取到。<br>getSystemService()方法接受一个字符串参数用于确定获取系统的哪一个服务。这里传入Context.NOTIFICATION_SERVICE即可。 </p>
<pre><code>NotificationManger manager=(NitificationManager)getSystemSerice(Context.NOTIFICATION_SERVICE);
</code></pre><p>接下来需要一个Builder构造器来创建Notification对象（为了实现兼容，使用v4包的NotificationCompat类）  </p>
<pre><code>Notification notification =new NotificationCompat.Builer(context);  
</code></pre><p>然后调用一系列的set方法对这个实体类进行设置。最后调用manager的notify()方法，该方法接收两个参数，第一个参数是Notification的id，第二个参数是Notification的类。<br>以上功能实现后就可以发送通知了，不过通知不可点击。如果需要点击需要PendingIntent</p>
<p>注：PendingIntent和Intent的异同点：</p>
<ul>
<li><p>都可以指明一个意图，都可以用于启动活动，服务，以及发送广播。</p>
</li>
<li><p>Intent倾向于立即去执行某个动作，PendingIntent更加倾向在合适的时机去执行某个动作。</p>
</li>
</ul>
<p><strong>pendingIntent的使用方法：</strong><br>使用静态方法获得PendingIntent的实例，getActivity()、getBroadcast()、getService()。  </p>
<p>四个参数：content，0，Intent对象、0</p>
<pre><code>Intent intent=new Intent(MainActivity.this,nextActivity.class);
PendingIntent pi=PendingIntent.getActivity(MainActivity.this,0,intent,0);
</code></pre><p><strong>不能这个通知写在OnClickListener的匿名内部类</strong></p>
<h2 id="2、调用摄像头"><a href="#2、调用摄像头" class="headerlink" title="2、调用摄像头"></a>2、调用摄像头</h2><pre><code>private void camera() {
       /**
        * 首先创建了一个File对象，用于存放摄像头拍下的图片，这里将图像命名为outputImage.jpg，并将它存放在手机的关联目录下、
        * 接着进行一个判断，如果设备系统的版本低于7.0 的话就，就调用Uri的fromFile()方法将File转化为Uri对象，这个Uri对象标识着outputImage这张图片的真实路径，否则
        * 就调用FileProvider的geUriForFile()将File转化成一个封装过的Uri对象。
        */
       File outputImage=new File(Environment.getExternalStorageDirectory(),&quot;output_image.jpg&quot;);
       try{
           if (outputImage.exists()) {
               outputImage.delete();
           }
           outputImage.createNewFile();
       } catch (IOException e) {
           e.printStackTrace();
       }
       if (Build.VERSION.SDK_INT&gt;=24){
           imageUri= FileProvider.getUriForFile(MainActivity.this,&quot;com.example.dimple.test619.fileProvider&quot;,outputImage);
       }else{
           imageUri=Uri.fromFile(outputImage);
       }
       Intent intent=new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);
       intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);//填入指定的文件输出地址
       startActivityForResult(intent,TAKE_PHOTO);
   }
@Override
   protected void onActivityResult(int requestCode, int resultCode, Intent data) {
       switch (requestCode) {
           case TAKE_PHOTO: {
               if (resultCode == RESULT_OK) {
                   try{
                       Bitmap bitmap= BitmapFactory.decodeStream(getContentResolver()//将图片解析为bitmap对象
                               .openInputStream(imageUri));
                       picture.setImageBitmap(bitmap);
                   } catch (FileNotFoundException e) {
                       e.printStackTrace();
                   }
​
               }
           }
           break;
           default:
               break;
       }
</code></pre><p>因为用到了ContentProvider，所以需要在Manifest中注册</p>
<pre><code>&lt;provider
            android:authorities=&quot;com.example.dimple.test619.fileProvider&quot;
            android:name=&quot;android.support.v4.content.FileProvider&quot;
           android:exported=&quot;false&quot;
           android:grantUriPermissions=&quot;true&quot;&gt;
           &lt;meta-data   //指定Uri的共享路径
               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
               android:resource=&quot;@xml/file_paths&quot;/&gt;
        &lt;/provider&gt;
    &lt;/application&gt;
​
&lt;/manifest&gt;
</code></pre><p>新建XML文件  </p>
<pre><code>&lt;?xml version =&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
    &lt;path xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;external-path name=&quot;my_images&quot; path=&quot;&quot;/&gt;
&lt;/path&gt;  
</code></pre><h2 id="3、播放音频"><a href="#3、播放音频" class="headerlink" title="3、播放音频"></a>3、播放音频</h2><p>在Android中播放音频文件一般都是使用MediaPayer来实现的，它对多种格式的音频文件提供了非常全面的控制方法，使得音频播放比较简单。</p>
<pre><code>方法名            功能描述          备注    
setDataSource()        设置要播放的文件的地址        
prepare()        在开始播放之前调用这个方法完成准备工作        
start()        开始播放视频        
pause()        暂停播放音频        
reset()        将Mediaplayer对象重置为刚开始创建的状态        
seekTo()        从指定的位置开始播放音频        
stop()        停止播放音频        
release()        释放掉与MediaPlyer相关的资源        
isPlaying()        判断当前MediaPlayer是否在播放        
getDuration()    获取之路的音频文件的时长    
</code></pre><h2 id="4、播放视频"><a href="#4、播放视频" class="headerlink" title="4、播放视频"></a>4、播放视频</h2><pre><code>方法名               功能描述          备注    
setVideoPat()   设置要播放的视频文件的地址            
start()        开始或继续播放视频        
pause()        暂停播放视频        
resume()        将视频从头播放        
isPlaying()        是否正在播放        
getDuration()        获取时长    
seekTo()        从指定的位置开始播放    
XML中包含VideoView。
通过VideoView来进行操作。
</code></pre><h1 id="第九章-使用网络技术"><a href="#第九章-使用网络技术" class="headerlink" title="第九章 使用网络技术"></a>第九章 使用网络技术</h1><h2 id="1、WebView-的用法"><a href="#1、WebView-的用法" class="headerlink" title="1、WebView 的用法"></a>1、WebView 的用法</h2><p>获取WebView的实例，通过getSetting()方法对浏览的相关属性进行设置。调用setJavaScriptEnabled()方法来让WebView支持JavaScript脚本。调用wenViewClient()方法。是希望网页依然在本程序中，不然就会跳转出去。</p>
<h2 id="2、使用HTTP协议访问网络"><a href="#2、使用HTTP协议访问网络" class="headerlink" title="2、使用HTTP协议访问网络"></a>2、使用HTTP协议访问网络</h2><p>首先开启一个子线程，在子线程中进行网络数据请求操作，获取HttpRULConnection实例。  </p>
<pre><code>URL url=new URL(&quot;https://www.baidu.com&quot;);
HttpURLConnection connection==(HttpURLConnection)url.openConnection();
connection.setConnectionTimeOut(8000);//设置链接超时
connection.setReadTimeOut(8000);//设置读取超时
</code></pre><p>之后再调用getInputStream()方法获取到服务器返回的流，然后进行流读取。  </p>
<pre><code>ImputStream in=connection.getInputStream();
//下面进行流读取
BufferedReader reader=new BufferedReader(new InputStreamReader(in));
String line;
StringBuilder builder=new StringBuilder();
while((line=reader.readerLine())!=null){
  builder.append(line);
}

最后关闭链接
connection.disconnect();
</code></pre><h2 id="3、使用OkHttp"><a href="#3、使用OkHttp" class="headerlink" title="3、使用OkHttp"></a>3、使用OkHttp</h2><p>在app/build.grade中dependencies中添加如下内容：  </p>
<pre><code>compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;
</code></pre><p>具体使用步骤：<br>创建一个OkHttpClient实例  </p>
<pre><code>OkHttpClient client=new OkHttpClient();  
</code></pre><p>接下来如果需要发起一条Http请求，需要创建一个Request对象  </p>
<pre><code>Request request=new Request.Builder().build();  
</code></pre><p>以上代码创建了一个空的Request对象，没有什么实际作用，在build()方法之前加入很多连缀来丰富这个request对象，可以使用uri()方法来设置目标网络地址。  </p>
<p>之后调用OkHttpClient的newCall()方法来创建一个Call对象，并调用它的execute()方法来发送请求并获得服务器的数据。  </p>
<pre><code>Response response=client.newCall(request).execute();
</code></pre><p>其中Resopnse就是服务器返回的数据了，以下方法可以得到具体的内容</p>
<pre><code>String responseData=response.body().string();
</code></pre><p>发送数据：  </p>
<p>首先需要构建出一个RequestBody对象来存放待提交的数据。</p>
<pre><code>ResquestBody requestBody=new FormBody.Builder().add(&quot;username&quot;,&quot;admin&quot;).add(&quot;password&quot;,&quot;123456&quot;).build();
</code></pre><p>接下来就和Get请求一样了，调用execute()方法来获得服务器返回的数据。</p>
<h2 id="4、解析JOSN数据"><a href="#4、解析JOSN数据" class="headerlink" title="4、解析JOSN数据"></a>4、解析JOSN数据</h2><p><a href="http://mobileapi.72g.com/index.php?tp=andv4/quan&amp;op=qinfo" target="_blank" rel="noopener">http://mobileapi.72g.com/index.php?tp=andv4/quan&amp;op=qinfo</a></p>
<h2 id="5、解析Json数据"><a href="#5、解析Json数据" class="headerlink" title="5、解析Json数据"></a>5、解析Json数据</h2><p>首先配置服务器：电脑端访问网址为127.0.0.1 模拟器访问端网址：10.0.2.2</p>
<p><strong>使用JsonObject：</strong><br>首先将从服务器中的数据放在JSONArray中，然后循环遍历这个Json数组，从中取出的每一个元素都是JSONObject对象，调用getString()方法就可以取出数据。  </p>
<pre><code>JSONArray jsonArray=new JSONArray(response);
    for (int i=0;i&lt;jsonArray.length();i++){
        JSONObject jsonObject=jsonArray.getJSONObject(i);
        Log.d(&quot;TAG&quot;, &quot;Data :&quot;+jsonObject.getString(&quot;name&quot;)+jsonObject.getString(&quot;id&quot;)+jsonObject.getString(&quot;version&quot;));
    }
</code></pre><p><strong>使用Gson</strong><br>首先需要添加依赖  </p>
<pre><code>compile &apos;com.google.code.gson:gson:2.8.1&apos;
</code></pre><p>Gson可以将一段Json格式的字符串自动映射成为一个对象，从而不需要我们编写代码进行解析。</p>
<p>比如：一段json格式的数据如下<br>{“name”：”Tom”，”age”:”20”}<br>我们可以定义 一个Person类，并加入name和age两个字段。只需要简单的调用如下代码就可以将JSON数据自动解析成一个Person对象了。 </p>
<pre><code>Gson gson=new Gson();
Person person=gson.fromJson(jsonData,Person.class)  
</code></pre><p>如果解析的是一段json数组就需要借助TypeToken将期望解析成的数据类型传入到fromJson中。  </p>
<pre><code>Gson gson=new Gson();
 List&lt;App&gt;appList=gson.fromJson(response,new TypeToken&lt;List&lt;App&gt;&gt;(){}.getType());
for (App app:appList){
  Log.d(&quot;TAG&quot;, &quot;run: &quot;+app.getId()+&quot;\n&quot;+app.getName()+&quot;\n&quot;+app.getVersion());
 }
</code></pre><p>定义Okhttp工具类  </p>
<pre><code>public class HttpUtility {
   public static void senOkHttpRequest(String address,okhttp3.Callback callback){
       OkHttpClient client=new OkHttpClient();
       Request request=new Request.Builder().url(address).build();
       client.newCall(request).enqueue(callback);
   }
}
​
</code></pre><p>在调用工具类的时候就这样写：</p>
<pre><code>HttpUtility.senOkHttpRequest(&quot;http://10.0.2.2/me.json&quot;, new okhttp3.Callback() {
           @Override
           public void onFailure(Call call, IOException e) {
//                T网络请求失败&quot;相关逻辑
           }
​
           @Override
           public void onResponse(Call call, Response response) throws IOException {
//                网络请求成功相关逻辑
               String responseData=response.body().string();
               showResponse(responseData);
           }
       });
</code></pre><h1 id="第12章-Material-Design"><a href="#第12章-Material-Design" class="headerlink" title="第12章 Material Design"></a>第12章 Material Design</h1><h2 id="1、ToolBar代替ActionBar"><a href="#1、ToolBar代替ActionBar" class="headerlink" title="1、ToolBar代替ActionBar"></a>1、ToolBar代替ActionBar</h2><p> 需要在Manifest中设置主题为NoActionBar  </p>
<pre><code>&lt;android.support.v7.widget.Toolbar
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;?attr/actionBarSize&quot;
       android:id=&quot;@+id/toolBar&quot;
       android:background=&quot;@color/colorPrimary&quot; /&gt;
Toolbar toolbar = (Toolbar) findViewById(R.id.toolBar);
       setSupportActionBar(toolbar);
</code></pre><p>扩展：在ToolBar中添加其他控件<br>新建menu文件夹，在其中添加Menu resourse file，创建一个xml文件。  </p>
<pre><code>&lt;item  
       android:id=&quot;@+id/delete&quot;
       android:icon=&quot;@drawable/wujiaoxing&quot;//指定按钮的图标
       android:title=&quot;@string/delete&quot;//指定按钮的文字
       app:showAsAction=&quot;always&quot; /&gt;//指定按钮的显示位置。always表示永远显示再ToolBar中，如果屏幕不够就不显示
                                   nerver表示永远显示再菜单项中，ifRoom表示屏幕空间足够的情况下就显示在ToolBar中，如果不够的话就显示在菜单项中。
​
</code></pre><p>在MainActivity中重写onCreateOptionMenu方法显示出menu，使用onOptionsItemSelected()方法来响应点击事件。</p>
<h2 id="2、滑动菜单——DrawerLayout"><a href="#2、滑动菜单——DrawerLayout" class="headerlink" title="2、滑动菜单——DrawerLayout"></a>2、滑动菜单——DrawerLayout</h2><p>首先它是一个布局，在布局中只允许放入 两个直接控件，第一个子控件是主屏幕显示的内容，第二个子控件是滑动菜单栏显示的内容。</p>
<p>使用  </p>
<pre><code>&lt;android.support.v4.widget.DrawerLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre><p>注意：</p>
<p>第二个子控件需要设置android:layout_gravity=””，需要告诉DrawerLayout菜单是再屏幕的右边还是左边  </p>
<pre><code>android:layout_gravity=&quot;start&quot;  
</code></pre><p>使用ToolBar的最左边加入导航按钮。  </p>
<pre><code>ActionBar actionBar=getSupportActionBar();//获取ActionBar的实例，这个实例的具体提现是由ToolBar来实现的。


       if (actionBar!=null){
           actionBar.setDisplayHomeAsUpEnabled(true);//显示导航键
           actionBar.setHomeAsUpIndicator(R.drawable.meiyuan);//设置导航键的图标。这个图标叫做HOMEAsUp
       }
</code></pre><p>在onOptionsItemSelected()方法来对HomeAsUp按钮的点击事件，HomeAsUp的id是<br>android.R.id.home  </p>
<p>然后调用DrawerLayout的openDrawert()方法将滑动菜单显示出来。  </p>
<h2 id="3、NavigationView"><a href="#3、NavigationView" class="headerlink" title="3、NavigationView"></a>3、NavigationView</h2><p>NavigationView是DesignSupport库中提供的一个控件。</p>
<p>使用的时候需要添加闭包关系  </p>
<pre><code>compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;
compile &apos;com.android.support:design:26.0.0-alpha1&apos;
</code></pre><p>在使用Navigation之前，需要准备两个东西，menu和headLayout </p>
<p>menu是在navigationView中显示菜单项的，headLayout是在NavigationView中显示头部布局的。</p>
<p>头部布局中使用circleImage来设置圆形头像。</p>
<p>设置完毕后在MainActivity中添加  </p>
<pre><code>&lt;android.support.design.widget.NavigationView
       android:id=&quot;@+id/nav_view&quot;
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;match_parent&quot;
       android:layout_gravity=&quot;start&quot;
       app:headerLayout=&quot;@layout/nav_header&quot;
       app:menu=&quot;@menu/nav_menu&quot; /&gt;
</code></pre><p>同时可以设置监听  </p>
<pre><code>public boolean onNavigationItemSelected(@NonNull MenuItem item)
</code></pre><h2 id="4、悬浮按钮和可交互提示"><a href="#4、悬浮按钮和可交互提示" class="headerlink" title="4、悬浮按钮和可交互提示"></a>4、悬浮按钮和可交互提示</h2><p><strong>悬浮按钮</strong>  </p>
<p>添加FloatActionButton布局  </p>
<pre><code>&lt;android.support.design.widget.FloatingActionButton
    android:id=&quot;@+id/floatButton&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;bottom|end&quot;
    app:elevation=&quot;8dp&quot;设置悬浮高度
    android:layout_margin=&quot;10dp&quot;
    android:src=&quot;@drawable/meiyuan&quot; /&gt;
</code></pre><p>setOnClickListener可以设置点击事件</p>
<p><strong>可交互提示：SnakeBar</strong>  </p>
<pre><code>Snackbar.make(view,&quot;Date Deleted&quot;,Snackbar.LENGTH_LONG)   //make方法创建了一个Snake对象，第一个 参数需要传入一个人View，只要是当前界面的任意一个View都可以，第二个参数是SnakeBar中显示的内容，第三个是显示的时长
                    .setAction(&quot;Un Do&quot;, new View.OnClickListener() {//调用setAction来设置一个动作，从而让SnakeBar不仅仅是一个提示，而是可以和用户进行交互的//第一个是按钮的名字，第二个是点击事件。
                        @Override
                        public void onClick(View view) {
                            Toast.makeText(MainActivity.this, &quot;Un Do Successed!&quot;, Toast.LENGTH_SHORT).show();
                        }
                    }).show();
</code></pre><p>调用setAction来设置一个动作，从而让SnakeBar不仅仅是一个提示，而是可以和用户进行交互的//第一个是按钮的名字，第二个是点击事件。  </p>
<p>出现界面重叠，需要使用CoordinatorLayout来替换掉FrameLayout，它可以监听所有子控件的所有事件，从而自动做出合理的响应。  </p>
<h2 id="5、卡片式布局"><a href="#5、卡片式布局" class="headerlink" title="5、卡片式布局"></a>5、卡片式布局</h2><p>添加依赖：  </p>
<pre><code>compile &apos;com.android.support:recyclerview-v7:26.0.0-alpha1&apos;
compile &apos;com.android.support:cardview-v7:26.0.0-alpha1&apos;
compile &apos;com.github.bumptech.glide:glide:4.0.0-RC1&apos;
</code></pre><p>Glide是一个强大的图片加载库，它不仅可以加载本地图片，还可以加载网络图片，GIF图片，甚至是本地视频。  </p>
<p>具体操作见recyclerView，只是将recyclerView 的子项布局的外层布局改为CardView</p>
<p>这种会将ToolBar遮盖，使用AppBarLayout<br>使用AppBarLayout包裹ToolBar，同时指定RecyclerView的布局行为  </p>
<pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
</code></pre><p>同时还可以设置滑动隐藏<br>在toolBar中加入  </p>
<pre><code>app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;
</code></pre><p>scroll表示RecyclerView向上滑动的时候，ToolBar会一起向上隐藏，enterAlways表示向下滚动的时候，ToolBar会同步显示。snap表示还没有完全隐藏的时候，会自动向上向下偏移。</p>
<h2 id="6、下拉刷新"><a href="#6、下拉刷新" class="headerlink" title="6、下拉刷新"></a>6、下拉刷新</h2><p>SwipeRefreshLayout就是用于下拉刷新的核心类。使用《swipeRefreshLayout》包裹需要下拉刷新的部件。  </p>
<pre><code>wipeRefresh.setColorSchemeResources(R.color.colorPrimary);
       swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
           @Override
           public void onRefresh() {
               refreshFuite();
           }
       });  
</code></pre><h2 id="7、可折叠标题栏ColapsingToolbarLayout"><a href="#7、可折叠标题栏ColapsingToolbarLayout" class="headerlink" title="7、可折叠标题栏ColapsingToolbarLayout"></a>7、可折叠标题栏ColapsingToolbarLayout</h2><p>colapsing不能独立存在，在设计的时候就只能用作AppBarLayout的直接子布局。而AppBarLayout又必须是CoordinatorLayout的子布局</p>
<p>DrawerLayout ——滑动菜单栏——只能拥有两个字节子布局（第一个是主屏幕的内容、第二个是滑动屏的内容）   </p>
<p>NavigationView——滑动菜单栏滑动屏布局（需要headLayout、和menu布局 （showAsAction））——需要Design Support库  </p>
<p>FloatActionButton——悬浮按钮  </p>
<p>SnakeBar——提示工具  </p>
<p>CoordinatorLayout——加强版的FrameLayout——监听子控件各种事件、自动做出合理的响应。防止控件重叠。  </p>
<p>CardView_FrameLayout——提供圆角和阴影效果（cardCornerRadius指定卡片的弧度，elevation指定卡片的高度）   </p>
<p>Glide——图片加载库  </p>
<p>AppBarLayout——解决FrameLayout中的默认位置为左上角造成的遮挡ToolBar——将ToolBar嵌套到AppBarLayout（    app:layout_scrollFlags=”scroll|snap|enterAlways”），然后给重叠的部件指定布局行为behaver  </p>
<p>SwipeRefreshLayout——下拉刷新——包裹需刷新的部件  </p>
<p>CollapsingToolbarLayout——可折叠标题栏——不能独立存在只能作为AppBarLayout的直接子布局、AppBarLayout必须是coordinatorLayout的子布局  </p>
<p>NestedScrollView——ScrollView——内部只能存在一个直接子布局  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是我的Android学习过程中整理的一些东西，重新再整理了一遍，也算是重新学习了一次，在重新学习的过程中，还是发现有很多不足不周到的地方。温故而知新，自己还记录了很多笔记，趁现在还时间充裕，还会再好好温习一下。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境]]></title>
      <url>/2018/01/19/2018-1-19%20153336/</url>
      <content type="html"><![CDATA[<h1 id="使用VSCode-七牛云图床插件-自定义快捷键配置Hexo博文编写环境"><a href="#使用VSCode-七牛云图床插件-自定义快捷键配置Hexo博文编写环境" class="headerlink" title="使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境"></a>使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我的电脑上安装了MarkdownPad++还有VSCode（主要是用来写前端的），VSCode也是可以写md文章的。之所以之前我是安装了MarkdownPad++，是因为它有一个可以上传图片的功能，再加上它还有一些VSCode没有的快捷键，所以一直是两个软件并存，直到今天重新捣鼓了一下，终于可以去掉MarkdownPad++了。不得不说VSCode确实很强大，更加难得的是支持中文，这使我对这个软件的好感度哧溜的加加加。 </p>
<p>特写下这个教程，方便同样是我这种情况的朋友。   </p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li>首先你得要有VSCode对吧，没有的话我也是附上链接：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Go</a>  </li>
</ul>
<ul>
<li>其次是在VSCode中安装一个预览MD文件的插件<code>Markdown Preview Enhanced</code>，这样写文章的时候能够做到实时预览了。  </li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155259.png" alt="{mdFileName}-2018119155259"></p>
<ul>
<li>为了能够最大程度的获得一些markdown的通用快捷键，这里可以下载一个<code>Markdown Shortcuts</code>插件，比如Ctrl+l插入链接、Ctrl+B加粗之类的。  </li>
</ul>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155358.png" alt="{mdFileName}-2018119155358">  </p>
<ul>
<li><p>最核心的一步——安装七牛云图床插件。</p>
<ul>
<li><p>安装插件<code>qiniu-upload-image</code>。<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155541.png" alt="{mdFileName}-2018119155541"></p>
</li>
<li><p>注册<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>（注册后需要认证，我的认证时间是半天。）<br>接着在<img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916325.png" alt="{mdFileName}-201811916325">新建对象存储。这里会有一个默认的【测试域名】，如果你的网站还没有备案的话，就用这个默认的吧。备案了的可以自定义域名。</p>
</li>
<li><p>配置VSCode过程 </p>
<ul>
<li>依次打开【文件】-【首选项】-【设置】</li>
<li>在【搜索设置】中搜索<code>qiniu</code>关键字</li>
<li>将【qiniu configuration】中的6个子设置从【默认设置】拷贝到【用户设置】<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119155911.png" alt="{mdFileName}-2018119155911">  </li>
<li>其中的【AccessKey 签名授权】【SecretKey 签名授权】在<a href="https://portal.qiniu.com/user/key" target="_blank" rel="noopener">密钥管理</a></li>
<li>七牛图片上传空间是你的存储空间的名字，七牛图床域名为测试域名。</li>
</ul>
</li>
</ul>
</li>
<li><p>接着还想在VSCode里面直接完成部署功能。<br>有两种方法：</p>
<ul>
<li>1 安装<code>vscode-Hexo</code>插件 然后直接在命令面板中输入以下命令：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201811916939.png" alt="{mdFileName}-201811916939">  </li>
<li>2 按住Ctrl+` 在VSCode中弹出终端，也可以在这里面直接输入命令操作。<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018119161338.png" alt="{mdFileName}-2018119161338"></li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>卸载掉MarkdownPad ，电脑又轻松了几百M。如果需要帮助的盆友请留言。</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 七牛云图床，VSCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大学期间的视频文档]]></title>
      <url>/2018/01/17/2018-1-17%20162928/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>考完试恍恍惚惚，简直不敢相信大三已经又过去了一半了，时间是真的快。经历了前两天去西岭雪山玩的时候手机丢了的不愉快，决定好好整理了下大学做过的一些东西，做一个备份。  </p>
<h2 id="视频篇"><a href="#视频篇" class="headerlink" title="视频篇"></a>视频篇</h2><h3 id="成都大学信息科学与工程学院-2016年迎新晚会暖场视频"><a href="#成都大学信息科学与工程学院-2016年迎新晚会暖场视频" class="headerlink" title="成都大学信息科学与工程学院 2016年迎新晚会暖场视频"></a>成都大学信息科学与工程学院 2016年迎新晚会暖场视频</h3><p>这是我担任学生会科文部部长的时候带领小干事们做的一些东西。权当留个纪念吧，我相信这套视频，对于16级的小同学们来说有着特别的意义。 </p>
<embed src="http://player.video.qiyi.com/428f02012a8d2b16fd49c579b2cd0d6d/0/0/w_19rwhy0npt.swf-albumId=11158755709-tvId=11158755709-isPurchase=0-cnId=7" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">  




<h3 id="成都大学信息科学与工程学院学生会招新视频"><a href="#成都大学信息科学与工程学院学生会招新视频" class="headerlink" title="成都大学信息科学与工程学院学生会招新视频"></a>成都大学信息科学与工程学院学生会招新视频</h3><embed src="http://player.youku.com/player.php/sid/XMTY5NjQ5NTM4NA==/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">

<p>###《基于无线传感器网的物联网智慧农业系统》展示视频</p>
<p>这一套系统呢是由我担任硬件开发兼项目负责人，我的学长余悦担任软件开发，当时大一小朋友蒋蕊担任项目答辩。最好的成绩呢是获得了全国物联网大赛一等奖。</p>
<embed src="http://player.video.qiyi.com/9e817fa08135f87b24712d990d0e12de/0/0/w_19rwhxeq81.swf-albumId=11159832109-tvId=11159832109-isPurchase=0-cnId=30" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">  


<h3 id="来影——一款基于AR与3D的旅游软件项目展示"><a href="#来影——一款基于AR与3D的旅游软件项目展示" class="headerlink" title="来影——一款基于AR与3D的旅游软件项目展示"></a>来影——一款基于AR与3D的旅游软件项目展示</h3><p>这个是我担任Android开发以及项目负责人做的视频，获得了中星杯计算机作品大赛二等奖，计算机设计大赛，互联网+大赛的一些奖。</p>
<embed src="http://player.video.qiyi.com/d2e4f573be6687e53a8ffe0cb29ea7df/0/0/w_19rwhwxmw1.swf-albumId=11159064909-tvId=11159064909-isPurchase=0-cnId=7" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">





<p>还有很多给老师做的一些视频就不放上来了。  </p>
<h2 id="文档篇"><a href="#文档篇" class="headerlink" title="文档篇"></a>文档篇</h2><h3 id="OFFICE使用手册"><a href="#OFFICE使用手册" class="headerlink" title="OFFICE使用手册"></a>OFFICE使用手册</h3><h4 id="PPT使用手册"><a href="#PPT使用手册" class="headerlink" title="PPT使用手册"></a>PPT使用手册</h4><p><a href="https://pan.baidu.com/s/1c3T7Nf6" target="_blank" rel="noopener">PPT 使用手册</a>  </p>
<p><img src="https://i.imgur.com/UBnUHGw.png" alt=""></p>
<h4 id="Word使用手册"><a href="#Word使用手册" class="headerlink" title="Word使用手册"></a>Word使用手册</h4><p><a href="https://pan.baidu.com/s/1sneCBmt" target="_blank" rel="noopener">Word 使用手册</a>  </p>
<p><img src="https://i.imgur.com/2c4Zq8E.png" alt=""></p>
<h4 id="Excel使用手册"><a href="#Excel使用手册" class="headerlink" title="Excel使用手册"></a>Excel使用手册</h4><p><a href="https://pan.baidu.com/s/1pNaCVvt" target="_blank" rel="noopener">Excel 使用手册</a>  </p>
<p><img src="https://i.imgur.com/FycYtNl.png" alt="">  </p>
<p>洋洋洒洒的几十页，在成都大学信工学院的学生群里面传播，也希望能够实实在在的帮助到他们。 如果有需要的话可以直接下载了。   </p>
<h3 id="IT来袭策划书"><a href="#IT来袭策划书" class="headerlink" title="IT来袭策划书"></a>IT来袭策划书</h3><p>当然了，作为部长的我是经历了成都大学第八届、第九届、第十届的IT来袭的，覆盖全校的校级大型活动，作为负责人还是很辛苦的，也很感谢我身边的人，不管是我的老部长还有小干事们，还有帮助我们活动的各位老大们。  </p>
<p><img src="https://i.imgur.com/mAhepJa.png" alt="">    </p>
<p>链接：<a href="https://pan.baidu.com/s/1mkd0ScS" target="_blank" rel="noopener">https://pan.baidu.com/s/1mkd0ScS</a> 密码：0hdb  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是有一些感触的，很多视频做的时候就完全不知道怎么做，逼出来的，现在看看还是很不错的。权当留个纪念吧，自己的电脑是一日不如一日，不知道什么时候就彻底歇逼了。对于IT来袭活动，印象应该是最深的了吧。我全程陪伴，全程关注。分配了任务，我会一点一点的督促落实，也得到了各位老师同学的肯定，参与人数达历史新高，近2000人。<br>科文部确实是一个很好的部门，带给人的影响积极而无声。</p>
]]></content>
      
        <categories>
            
            <category> 大学资料 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 成都大学信工学院迎新晚会视频 </tag>
            
            <tag> 成都大学 </tag>
            
            <tag> 基于无线传感器网的物联网智慧农业系统 </tag>
            
            <tag> 来影——一款基于AR与3D的旅游软件项目展示 </tag>
            
            <tag> OFFICE使用手册 </tag>
            
            <tag> IT来袭策划书 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo-NexT主题添加评论功能（来必力、Hypercomments、畅言、友言）]]></title>
      <url>/2018/01/17/2018-01-17%20102253/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近捣鼓着博客的评论功能，看到很多形形色色的评论插件，比如来必力，畅言等等之类的。功能是各不一样，网上教程是关于某一类的评论插件的介绍，不是很全面，所以本文主要是弄一个全面的评论插件集成，然后分别说一下各自的优点以及不足，千挑万选之后总有一个适合你。<br>我使用的是NexT主题，NexT主题是集成了评论功能的。所以这里就直接是以NexT主题为例了。  </p>
</blockquote>
<h1 id="多说"><a href="#多说" class="headerlink" title="多说"></a>多说</h1><p>多说的功能还是很强大的，加上很早之前就有了各种社交途径的分享，很受大家喜爱。虽然多说在2017年6月1日正式停止，但是还是纪念下多说吧。虽然我没有用过，但是我在一些技术交流群中还是听到很多人在说多说。<br><img src="https://i.imgur.com/IcR5S7r.png" alt="">  </p>
<h1 id="Hypercomments"><a href="#Hypercomments" class="headerlink" title="Hypercomments"></a>Hypercomments</h1><blockquote>
<p>Communication is Empathy.<br>Tailored comment system for your site.    </p>
</blockquote>
<p><img src="https://i.imgur.com/BgAR237.png" alt=""></p>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>这是一个国外的评论系统，总的来说，界面设计等等还是很不错的。在NexT主题中操作也还算简单，事实上所有的评论在NexT上的操作都还是很简单的。  </p>
<p>但是这个界面是繁体中文的，目前我还没有找到改为简体中文的方法，看着是有一点难受。这个呢，可以<strong>匿名评论</strong>，说到匿名评论其实做的还是不错的，匿名评论可以添加能够联系到你的邮箱地址，这样当有人回答你的时候有邮件提醒。不得不说这点还是不错的。  </p>
<h2 id="添加Hypercomments评论"><a href="#添加Hypercomments评论" class="headerlink" title="添加Hypercomments评论"></a>添加Hypercomments评论</h2><ol>
<li>在<a href="https://www.hypercomments.com/" target="_blank" rel="noopener">Hypercomments</a>官网登录，目前只支持谷歌账号登录，国内有万里长城阻隔，翻墙注意安全！</li>
<li>选择Lite版本，点击Install。<img src="https://i.imgur.com/gsT39R9.png" alt=""></li>
<li>在设置中（齿轮图标的那个），点击Widget，然后在代码框中找到<code>Widget_id</code>，记录下来。</li>
<li>在NexT主题的配置文件<code>—config</code>中搜索hypercomments_id，然后去掉前面的#号，冒号后面加一个空格填入上面记录的Id。</li>
<li>部署就能看到效果。</li>
</ol>
<h2 id="参考界面"><a href="#参考界面" class="headerlink" title="参考界面"></a>参考界面</h2><ol>
<li>评论效果：  <img src="https://i.imgur.com/448OmUd.png" alt=""></li>
<li>匿名评论界面：<img src="https://i.imgur.com/zdUopLe.png" alt=""></li>
<li>Lite Demo ：<a href="https://www.hypercomments.com/en/demo?type=blogs" target="_blank" rel="noopener">Demo</a></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>繁体中文看的我是很难受。虽然只有几行而已。优点呢是评论可以匿名，可以评论上传图片、影片等。功能还是比较强大，设置界面是英文，且没有中文支持！</p>
<h1 id="畅言"><a href="#畅言" class="headerlink" title="畅言"></a>畅言</h1><p><img src="https://i.imgur.com/TxLKDXM.png" alt=""></p>
<blockquote>
<p>畅言是业内领先的社会化评论系统，支持PC和移动端两种接入方式，为网站提供了一种全新的评论方式。畅言拥有多种常用账号登录、三重过滤机制、实时的数据统计、快捷数据导出、全面支持移动端等领先功能。充分满足了当前各大网站对于用户登录、评论、分享 、审核等方面的需求。<br>畅言在业内率先实现三重过滤机制。当评论数据产生后，首先经过搜狐垃圾过滤系统，防灌水、防垃圾、防广告；然后经过官方提供违禁词库和站长自定义的敏感词过滤；最后是网站的自主审核，所有畅言合作网站都有专属的管理后台，管理所有本网评论。网站对本站评论拥有完全的管理，可以设置先发后审与先审后发等多种审核形式。  </p>
</blockquote>
<h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><ol>
<li>注册畅言  <a href="https://changyan.kuaizhan.com/" target="_blank" rel="noopener">Go</a></li>
<li>将畅言密钥复制到NexT主题的配置文件<code>—config</code>中，搜索changyan，填写下面的代码，注意替换成你的代码。</li>
</ol>
<pre><code># changyan
changyan:
  enable: true
  appid: yourid
  appkey: yourkey
</code></pre><h2 id="参考界面-1"><a href="#参考界面-1" class="headerlink" title="参考界面"></a>参考界面</h2><p> 1.畅言后台 <img src="https://i.imgur.com/Kpb83UA.png" alt=""><br> 2.评论登录后需要手机号码验证：<img src="https://i.imgur.com/TsA80yh.png" alt=""><br> 3.评论界面：<img src="https://i.imgur.com/C9JCqzJ.png" alt="">  </p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p> 关于畅言，大家可能印象最深的是灌水功能了，这个功能目前已经是出于失灵与半失灵的状态，官方估计也没怎么维护了。最难受的是，需要手机号验证，这也就阻挡了大部分的评论者。如果能够添加一个像Hypercomments的匿名功能的话，可能会好很多。最最重要的是，畅言是需要你的备案号的，就是说，你一个没有备案的网站是没法长时间使用畅言的。</p>
<h1 id="友言"><a href="#友言" class="headerlink" title="友言"></a>友言</h1><p> <img src="https://i.imgur.com/F9aMLio.png" alt=""></p>
<blockquote>
<p>友言是一个简单而强大的社会化评论及聚合平台。用户可以使用社交账号一键评论同步至社交网络，将内容和自己的评论分享给好友。增加第三方网站用户活跃度，调动好友参与评论，帮助网站实现社会化网络优化SMO，有效提升网站社会化流量！  </p>
<h2 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h2><p>友言的添加方法也极其简单：</p>
</blockquote>
<ol>
<li>在<a href="http://www.uyan.cc" target="_blank" rel="noopener">友言官网</a>注册账号，得到用户ID</li>
<li>将友言ID复制到NexT主题的配置文件<code>—config</code>中，搜索youyan，将youyan_uid前面的#号去掉，将id填写到youyan_uid：后面。</li>
<li>部署到你的网站。</li>
</ol>
<p>PS：部署成功后可能不会立即显示你的网站，这个时候你去你的网站评论一下就行了。</p>
<h2 id="参考界面-2"><a href="#参考界面-2" class="headerlink" title="参考界面"></a>参考界面</h2><ol>
<li>留言评论界面<img src="https://i.imgur.com/LK7ij0Z.png" alt=""></li>
<li>后台管理界面：<img src="https://i.imgur.com/rWfmRzF.png" alt=""><img src="https://i.imgur.com/hsEwGrE.png" alt=""><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2>对于友言，我觉得确实是我比较喜欢的类型了，支持匿名评论功能（默认是关闭的，需要手动开启），但是匿名只是匿名，没有留联系方式的地方，这点我觉得还是有点不好。</li>
</ol>
<h1 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h1><p><img src="https://i.imgur.com/UEsZmFf.png" alt=""></p>
<blockquote>
<p>使用社交网站账户登录，免去注册过程。<br>提高用户的参与和沟通意愿。<br>管理/删除我的评论内容。<br>提供管理页面，管理网站文章及评论内容。</p>
</blockquote>
<h2 id="添加方法-2"><a href="#添加方法-2" class="headerlink" title="添加方法"></a>添加方法</h2><ol>
<li>在<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a>的官网上注册账号。</li>
<li>在<a href="https://livere.com/insight/myCode" target="_blank" rel="noopener">此处</a>获取data-uid。</li>
<li>打开NexT主题的配置文件<code>—config</code>中，搜索livere_uid，将livere_uid前面的#号去掉，将id填写到livere_uid：后面。</li>
</ol>
<h2 id="参考界面-3"><a href="#参考界面-3" class="headerlink" title="参考界面"></a>参考界面</h2><ol>
<li>设置界面<img src="https://i.imgur.com/dvonjM1.png" alt=""></li>
<li>数据分析界面<img src="https://i.imgur.com/NLFltb6.png" alt=""></li>
<li>体验Demo：<a href="https://livere.com/city-demo" target="_blank" rel="noopener">Demo</a></li>
</ol>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>如果大家仔细观察应该能发现这是韩国人的东西，但也正是因为这是外国人的东西，收到国内的各种条条框框的限制比较少。对于来必力，这个产品比较不错，首先界面美化上就比之前的几种类型要好很多。但是没有匿名评论，支持邮箱账号注册评论。</p>
<h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><p>考试之前就像写一篇博文来介绍这几类评论工具了，但是平时的时候没有特别认真听，导致那个时候一点时间都不敢耽搁。哎~。评论工具还有很多很多，如果需要的话，还是需要自己修改一些代码才行。就我个人感觉而言，我觉得Hypercomments、来必力还有友言都还不错，畅言需要备案。就看各位老铁们喜欢什么了。</p>
<p>顺便说一句，寒假快乐！</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next优化 </tag>
            
            <tag> Comment </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018React-Native环境安装及运行第一个demo]]></title>
      <url>/2018/01/07/2018-01-07%20121946/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android放下很久了，前段时间一直扎根于前端三大件（HTML、CSS、JavaScript）的学习，目的呢是想为之后的学习React Native学习做好准备。趁着离考试还有一段时间，也是重新走上Android开发的道路。<br>现在确实是移动设备占优，现在智能手机能够完成网页端很多的工作。大有一统江山的趋势。移动开发在未来的很长时间里面都是热门。<br>工欲善其事必先利其器，本文主要是结合自己的相关经验搭建开发环境，来开始关于React Native的第一篇博文。纵观网上的各种教程，还有官方的一些教程吧，写的是比较简略的，所以本文的定位是写一点比较详细的环境安装教程。  </p>
<h1 id="关于react-native"><a href="#关于react-native" class="headerlink" title="关于react native"></a>关于react native</h1><p>还是老规矩，介绍下这个东东吧。  </p>
<blockquote>
<p>React Native 是一个 JavaScript 的框架，用来撰写实时的、可原生呈现 iOS 和 Android 的应用。其是基于 React的，而 React 是 Facebook 的用于构建用户界面的 JavaScript 库，但是这里不是给浏览器解释的，而是为移动平台。换句话说：如果你是一名 web 开发者，你可以使用熟悉的框架和单一的 JavaScript 代码库，即 React Native来撰写清晰的、高效的移动应用。</p>
<p>相比较于 iOS 和 Android 原生的开发，React Native 提供更好的开发者体验。因为你的程序大多数都是 JavaScript，你可以从 web 开发中汲取大量的经验，比如能够立即“刷新”你的应用来查看你代码的修改。相比于在传统的应用开发中花很长的时间去等待构建的过程，会让人感觉这简直是天赐之物。</p>
<p>另外，React Native 还为开发者提供了智能的错误报告和标准的 JavaSript 调试工具，这些让移动开发更加的顺手。  </p>
</blockquote>
<p>确实现在的开发，RN在后面的很长时间是主流。毕竟原生开发存在着诸多问题，最大的问题是在用户体验上。废话不多说，进入正题。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装过程可以参考<a href="https://reactnative.cn/docs/0.51/getting-started.html" target="_blank" rel="noopener">React Native中文网</a><br>那你以为这样就完了吗？没有。</p>
<p>官方文档上面说了，必须安装的东西，其实有些东西是没有必要的，比如Chocolatey这个包管理器，下载速度及其慢，完了还不支持断点续传，网络一有波动就GG。</p>
<p>所以遇到按照官方的步骤配置的遇到错误的，到我这里来就对了。  </p>
<h2 id="Node-js以及Python安装"><a href="#Node-js以及Python安装" class="headerlink" title="Node.js以及Python安装"></a>Node.js以及Python安装</h2><p>这里需要用到的两个软件分别是Python2和Node.js（其中Python必须安装2.x.x版本，Node.js随便安装都无所谓）。</p>
<p>我们采用安装包的方式安装这两个软件，下载地址为：  </p>
<ul>
<li>Python：<a href="https://www.python.org/downloads/release/python-2714/" target="_blank" rel="noopener">Python2.7.14</a>  </li>
<li>Node.js:<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 8.9.4LTS</a></li>
</ul>
<p>安装过程一路默认就行，但是要注意，需要把Python的根目录添加到环境变量。C:\Python27  </p>
<p>其次，Node.js也是需要将其根目录配置到环境变量的。  </p>
<p>具体流程就不详细介绍了，如果有问题请询度娘。</p>
<h2 id="Yarn、React-Native安装"><a href="#Yarn、React-Native安装" class="headerlink" title="Yarn、React Native安装"></a>Yarn、React Native安装</h2><p>Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p>
<pre><code>npm install -g yarn react-native-cli
</code></pre><p>安装完yarn设置镜像源：</p>
<pre><code>yarn config set registry https://registry.npm.taobao.org --global
yarn config set disturl https://npm.taobao.org/dist --global    
</code></pre><p>PS：这里不设置也是可以的，亲测没有什么差别。  </p>
<h2 id="Android-Studio安装"><a href="#Android-Studio安装" class="headerlink" title="Android Studio安装"></a>Android Studio安装</h2><p>React Native是支持3.x版本的。所以博主是用的3.1的版本，这个版本的Android虚拟机做了些优化，无论是启动速度还是性能各个方面都很优秀。另外3.x出来快大半年了，还停留在2.3版本的朋友可以考虑给手中的AS升级了。   </p>
<p>关于Android Studio的安装我就不详细介绍了，官方教程写的还是很详细的，另外官方教程的安装步骤2.3和3.1的没有差别。</p>
<p>PS：这里再说一下，Java JDK不支持9.0版本的，我之前用的就是9.0版本，发现不兼容，果断换回了8.0.  </p>
<p>这里直接简述下安装过程，相信AS这种级别的软件安装不是很难吧。</p>
<p>下载地址：<a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio中文社区</a>  </p>
<ul>
<li>安装软件的步骤是一路Next就行，没有坑  </li>
<li>安装完成后打开AS，然后这里会下载一些组件，请保持网络连接。  </li>
<li>确保 Android SDK和Android Device Emulator选中  </li>
<li>打开软件后选择custom选项，接下来会叫你选择主题什么的，你开心就好  </li>
<li>这里SDK Components Setup 里面的东西全部选中，当然你要更改SDK的路径也是可以的  </li>
<li>安装完成后，在Android Studio的欢迎界面中选择Configure | SDK Manager。</li>
<li>在SDK Platforms窗口中，选择Show Package Details，然后在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。 </li>
<li>在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须包含有这个版本。当然如果其他插件需要其他版本，你可以同时安装其他多个版本）。然后还要勾选最底部的Android Support Repository.</li>
<li>将SDK的目录加到环境变量，单独配置Android SDK的tools和platform-tools目录添加到PATH变量中。 </li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>这个安不安装在现阶段是无所谓的，但是作为一个程序员，不用Git感觉就像村里没通电一样。  </p>
<h2 id="配置Android-Device-Emulator"><a href="#配置Android-Device-Emulator" class="headerlink" title="配置Android Device Emulator"></a>配置Android Device Emulator</h2><p>用过AS的可以跨过这一步。  </p>
<p>打开Android virture Devices Manager，然后新建就行了。</p>
<p><img src="https://i.imgur.com/7qNNXPo.png" alt=""><br><img src="https://i.imgur.com/NIRq9qi.png" alt=""><br><img src="https://i.imgur.com/5mIuNq2.png" alt=""></p>
<p>OK，到现在基本上环境是安装好了。接下来弄一个小小的demo测试下。  </p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在你合适的位置新建一个文件夹用来放置RN的文件。 在此处发开PowerShell（Shift+鼠标右键，选择PowerShell）。输入命令：  </p>
<pre><code>react-native init 你的项目名  
</code></pre><p><img src="https://i.imgur.com/LYH1nxn.png" alt=""></p>
<p>PS：这个下载过程有点长，我用的最短时间是0.25分钟，最长5分钟。  </p>
<p>接下来在cd进入你的项目，输入以下命令：（在此之前，需要打开模拟器）</p>
<pre><code>react-native run-android 
</code></pre><p>此时会弹出Node的命令行界面：</p>
<p><img src="https://i.imgur.com/IhR1EFS.png" alt="">  </p>
<p>稍等一会就会出现以下界面：   </p>
<p><img src="https://i.imgur.com/mcqwAJ6.png" alt="">  </p>
<p>代表安装成功。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是简单的简述了下我的配置RN的过程，路漫漫其修远兮。后面我会继续学习RN，同时还需要准备下算法学习备战蓝桥杯个人赛。记录下我的安装步骤，在安装的过程中也是需要耐心的，官方教程也不是万能宝典，还是要辩证的来看吧，使用包管理器确实下载很不方便，而且出了问题也不知道出在哪里，还是安装包直接点。如果在安装过程中有不懂的地方，欢迎留言评论。</p>
]]></content>
      
        <categories>
            
            <category> react-native学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react-native </tag>
            
            <tag> Android混合开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo内嵌html或者Js代码遇到的问题]]></title>
      <url>/2018/01/05/2018-01-05%20201655/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://i.imgur.com/3Ewq7e1.gif" alt=""><br>在没有遇到这个坑之前我是完全不知道原来markdown里面是可以嵌入html或者js代码运行的。好吧是我孤陋寡闻了。在了解了原来还有这种操作的时候，整个人是惊呆了。<img src="https://i.imgur.com/DxDVkwv.gif" alt="">，但想想也是，不然一个博客里面随随便便冒出一个<code>button</code>还能点击是怎么做出来的。  </p>
<h1 id="进坑过程"><a href="#进坑过程" class="headerlink" title="进坑过程"></a>进坑过程</h1><p><code>&lt;script type=&quot;text/javascript&quot;  alert(&quot;hello world！&quot;);&gt;</code></p>
<p>比如上面一段代码，写出来了，在<code>markdownpad</code>上面还是可以看到的，但是在<code>hexo</code>中就看不到了。此时脸上笑嘻嘻，心里<em>*</em>。（以上代码我是直接用``括起来的，如果没有扩起来的话，博文后面的内容是完全看不到的。）也是很奇怪这个东西，好像是因为hexo把MD文档全部按照它自己的语法编译了一次，这样就导致编译看起来效果不错，发布出去到处是坑。</p>
<p>昨晚上我写了一篇博文，<code>hexo g</code>的时候就宝一大堆错，我尝试在其报错的位置进行解决，但是左看右看确实没错。原来是因为hexo文档中的有js代码，引起了连锁反应。毕竟hexo到现在虽然很不错了，但是还有些问题。  </p>
<h1 id="脱坑过程"><a href="#脱坑过程" class="headerlink" title="脱坑过程"></a>脱坑过程</h1><p>遇事不决用谷歌，带着问题翻墙出去。结果发现没有人遇到和我一样的问题。难受。各个大佬群咨询，大佬们给出的建议都尝试了，还是没有办法。</p>
<p>卸载重装，我就差换电脑了，哈哈哈。 </p>
<p>好了，说下脱坑方法，在你的JS或者HTML代码前面加上4个空格，编译完美通过。</p>
<p>记录下我的经历，方便以后遇到同样问题的兄弟。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到问题不要慌。能够解决问题的程序员才是好程序员。不断的写bug，不断解决bug才是开发的乐趣。hexo是可以内嵌前端代码的，注意不要被这个坑了，好了，现在弄得差不多了，后面准备回归我的老本行了，写Android了。  </p>
<p>最近新发现了一个markdown编辑器，还不错，如果不是因为不支持上传图片的话，我就转过去了。我也和开发的人聊了下，准备接入图床或者七牛云的接口。据说是hexo定制的，现在hexo的github主页就挂的这个编译器。有需要的可以去试试。  </p>
<p>附上链接地址：<a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HEXOEditor </a>  </p>
<p>好了就到这里，踩了很多坑，不一一列出来了，大家有问题的话可以留言评论！</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo疑难杂症 </tag>
            
            <tag> hexo问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018最新版Hexo博客Next主题6.0配置优化]]></title>
      <url>/2018/01/04/2018-01-04%20213124/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>或许是对默认的东西没有好感，总觉得默认的主题是很丑很丑的，完美控是接受不了这个东东的，还好hexo是可以修改主题的。这里首推NexT主题，<code>精于心，简于形</code>标语说的是真的不错。使用NexT主题的人比较多，这也说明这个主题确实很成熟了。优化，配置，扩展很多都集成了，比较简单。博文重质量，弄的太花哨确实没啥用。。。</p>
</blockquote>
<p>读者可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a>可以查看你喜欢的主题。 这里我主要说下NexT主题的相关配置。其他主题可以多看看官方文档。  </p>
<h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><p>安装的过程就一行代码，你需要在博客根目录出打开命令行输入以下命令：    </p>
<pre><code>git clone https://github.com/theme-next/hexo-theme-next themes / next
</code></pre><p>以上代码的意思是从 <a href="https://github.com/iissnan/hexo-theme-next将next下载到当前目录下的themes里面的next文件夹中。" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next将next下载到当前目录下的themes里面的next文件夹中。</a>  </p>
<h1 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h1><p>修改站点配置文件<code>_config.yml</code>  </p>
<pre><code># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: next
</code></pre><h1 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h1><p><img src="http://theme-next.iissnan.com/assets/img/NextSchemes3.png" alt=""></p>
<p>选择 Scheme  </p>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新  </li>
<li>Gemini - 左侧网站信息及目录，块+片段结构布局<br>cheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 </li>
</ul>
<h1 id="设置-语言"><a href="#设置-语言" class="headerlink" title="设置 语言"></a>设置 语言</h1><p>编辑站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：</p>
<pre><code>language: zh-Hans  
</code></pre><p>PS：这里提一下，你使用<code>hexo s</code>预览的时候，你会发现是设置了语言之后界面还是英文，这个时候不要慌，使用<code>hexo clean</code>清理下database文件夹以及public文件夹就行了。然后再使用<code>hexo s</code> 预览。事实上，这个方法在遇到很多问题的时候都是通用的。</p>
<h1 id="设置-菜单"><a href="#设置-菜单" class="headerlink" title="设置 菜单"></a>设置 菜单</h1><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</p>
<p>编辑 主题配置文件，修改以下内容：</p>
<p>设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。  </p>
<h1 id="设置标签、分类的界面"><a href="#设置标签、分类的界面" class="headerlink" title="设置标签、分类的界面"></a>设置标签、分类的界面</h1><p>设置菜单那里，我设置了显示标签、分类、关于几个选项。如图：<br><img src="https://i.imgur.com/mAF33TE.png" alt="">  </p>
<p>但是点击进去，却报错：<code>Cannot GET /tags/</code>，不要慌，不能获取tags，创建一个就OK！  </p>
<p>这里介绍创建page的语法：   </p>
<pre><code>hexo new page &apos;name&apos; # name分别为tags、categories  
</code></pre><p>这样就创建了pages。<br>在控制台输入以下命令：  </p>
<pre><code>hexo new page &apos;tags&apos; #创建tags子目录
hexo new page &apos;categories&apos; #创建categories子目录
</code></pre><p>在你的网站根目录下面的source文件夹会分别生成tags、categories以及about文件夹。 </p>
<p>分别修改这tags和categories文件夹中的index.md文件，新增type属性，如下：</p>
<pre><code>---
title: tags
date: 2018-01-04 11:45:41
type: tags
---
</code></pre><p> categories的修改类似。   </p>
<p>当你新建一篇博文的时候，增加上tags和categories属性值，就能在tags和categories界面检索到你的文章了。   </p>
<h1 id="个性化定制"><a href="#个性化定制" class="headerlink" title="个性化定制"></a>个性化定制</h1><h2 id="添加fork-me-on-github"><a href="#添加fork-me-on-github" class="headerlink" title="添加fork me on github"></a>添加fork me on github</h2><p>在<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">http://tholman.com/github-corners/</a>或者<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">https://github.com/blog/273-github-ribbons</a>选择合适的样式复制代码到<code>themes/next/layout/_layout.swig</code>，在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下面：<br><img src="https://i.imgur.com/QHwALhC.png" alt="">  </p>
<h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><p>实现效果之一：<br><img src="https://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/466" alt=""><br>目前NexT主题最新的是V6.0版本，这个版本中可以有4种动态背景：  </p>
<ul>
<li>Canvas-nest  </li>
</ul>
<ul>
<li>three_waves  </li>
</ul>
<ul>
<li>canvas_lines  </li>
</ul>
<ul>
<li>canvas_sphere  </li>
</ul>
<p>设置方法也很简单，直接设置里需要的动态背景为<code>true</code>。</p>
<h2 id="点击出现桃心效果"><a href="#点击出现桃心效果" class="headerlink" title="点击出现桃心效果"></a>点击出现桃心效果</h2><p>浏览器输入：<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</a>  </p>
<p>拷贝所有代码，在<code>/themes/next/source/js/src</code>里面新建<code>love.js</code>，然后在<code>\themes\next\layout\_layout.swig</code>文件末尾添加以下代码：     </p>
<p><code>&lt;!-- 页面点击小红心 --&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="文章底部带-号的标签"><a href="#文章底部带-号的标签" class="headerlink" title="文章底部带#号的标签"></a>文章底部带#号的标签</h2><p><img src="https://i.imgur.com/FNMiJmQ.png" alt="">   </p>
<p>去掉文章后面的标签前面的#号。   </p>
<p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2><p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：   </p>
<pre><code>&lt;div&gt;
{% if not is_index %}
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    {% endif %}
&lt;/div&gt;
</code></pre><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在post-body 之后， 添加以下代码：   </p>
<pre><code>&lt;div&gt;
{% if not is_index %}
    {% include 'passage-end-tag.swig' %}
  	{% endif %}
&lt;/div&gt;
</code></pre><p>添加位置如图：  </p>
<p><img src="https://i.imgur.com/NWZw9uo.png" alt="">  </p>
<p>然后打开主题配置文件（_config.yml),在末尾添加： </p>
<pre><code># 文章末尾添加“本文结束”标记
passage_end_tag:
  enabled: true
</code></pre><p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p>
<h2 id="侧边栏社交小图标设置"><a href="#侧边栏社交小图标设置" class="headerlink" title="侧边栏社交小图标设置"></a>侧边栏社交小图标设置</h2><p>实现效果：<br><img src="https://i.imgur.com/rwwMWVj.png" alt=""></p>
<p>打开主题配置文件_config.yml，搜索<code>social:</code>, <code>||</code>之后是在图标库中对应的图标。注意空格就行。  </p>
<p><img src="https://i.imgur.com/KXJGPqS.png" alt="">  </p>
<p>图标库链接：<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">http://fontawesome.io/icons/</a></p>
<h2 id="主页文章加阴影"><a href="#主页文章加阴影" class="headerlink" title="主页文章加阴影"></a>主页文章加阴影</h2><p>具体实现方法<br>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：</p>
<pre><code>// 主页文章添加阴影效果
 .post {
   margin-top: 60px;
   margin-bottom: 60px;
padding: 25px;
-webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
-moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
}
</code></pre><h2 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h2><p>具体实现方法<br>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code></p>
<p>在<code>&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</code>下添加一句：  </p>
<pre><code>&lt;span&gt;℃&lt;/span&gt;
</code></pre><p>然后打开，<code>/themes/next/languages/zh-Hans.yml</code>  </p>
<p>将<code>visitors: 阅读次数</code>改为<code>visitors: 热度</code></p>
<h2 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h2><p>默认的网站图标是一个N，当然是需要制定一个图了，在网上找到图后，将其放在<code>/themes/next/source/images</code>里面，然后在主题配置文件中修改下图所示图片位置</p>
<p><img src="https://i.imgur.com/sHd5kLC.png" alt="">  </p>
<p>还有一些就不详细说了，另外注意下好多的东西已经过时了。比如next主题已经换了域了。很多教程还停留在3.0时代，但是现在next的版本是V6.0，截止我这篇教程发布的时期。</p>
<h2 id="设置文章浏览数（热度）"><a href="#设置文章浏览数（热度）" class="headerlink" title="设置文章浏览数（热度）"></a>设置文章浏览数（热度）</h2><p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201821323114.png" alt="{mdFileName}-201821323114">   </p>
<p>如上图所示  </p>
<p>首先需要在<a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a>上注册一个账号，注册的过程省略。  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018213231335.png" alt="{mdFileName}-2018213231335">  </p>
<p>点击<strong>访问控制台</strong>  </p>
<p>点击<strong>创建应用</strong><br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018213231512.png" alt="{mdFileName}-2018213231512">  </p>
<p>这里选择开发版就行，应用名称随意。  </p>
<p>随后进入设置界面  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018213231716.png" alt="{mdFileName}-2018213231716">  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018213231754.png" alt="{mdFileName}-2018213231754">   </p>
<p>在next主题的配置文件中填写以下信息：  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-201821323191.png" alt="{mdFileName}-201821323191">  </p>
<p>随后在主题文件的languages目录下找到你设置的语言yml下，把visitors后面的字符改为<strong>热度</strong>，到此大功告成。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就只是简单的介绍了下NexT主题，关于这个主题呢，要达到个性化定制的话，还是需要再花点功夫的。还有就是这个<code>hexo s</code>预览效果确实不好，修改了网站内容之后，需要重新<code>hexo clean</code>再<code>hexo s</code>才能看到效果，有同样问题的兄dei就不需要担心自己的修改是错的。</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> next主题优化 </tag>
            
            <tag> next6.0 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018最新版hexo+Github搭建个人博客教程（2018-1-22 更新）]]></title>
      <url>/2018/01/04/2018-01-04%20212731/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>现在是大三了，身边的甚多朋友技术都还不错，动不动就搭建自己的网站什么的。本着向大佬学习（zhuangbi）的心情，我也开始在阿里云上面买了一个云服务器（学生套餐9.9），使用phpstudy软件一键部署了一个web服务器。但是想想其实没什么用，我只是想找一个属于自己的个人博客而已。所以将目光转向了hexo。 经过很多的摸索，终于是做好了我的博客：<a href="http://bianxiaofeng.com" target="_blank" rel="noopener">http://bianxiaofeng.com</a>, 就像每个语言入门必写<code>hello world</code>一样，我也想把自己使用hexo的相关经历写下来，方便自己以后查阅也希望能够帮助到更多的朋友。  </p>
</blockquote>
<p>博主使用是Windows10操作系统，其他系统自测。</p>
<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>搭建的过程分为以下几步：  </p>
<ol>
<li>安装Node.js  </li>
</ol>
<ol>
<li>安装Git软件  </li>
</ol>
<ol>
<li>安装hexo博客框架  </li>
</ol>
<ol>
<li>测试本地运行（线下访问个人博客）  </li>
</ol>
<ol>
<li><p>部署到Coding以及GitHub上（线上访问个人博客）  </p>
</li>
<li><p>设置域名解析  </p>
</li>
<li><p>其他（写一篇新的博文，设置categories,tags）</p>
</li>
</ol>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Node.js下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>    </p>
<p>安装过程一路默认安装即可。   </p>
<p>详细安装文档参看：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-install-setup.html</a>  </p>
<h2 id="安装Git软件"><a href="#安装Git软件" class="headerlink" title="安装Git软件"></a>安装Git软件</h2><p>Git软件下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a>  </p>
<p>安装过程一路默认安装即可。 </p>
<p>关于更多的Git讲解参看：  </p>
<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a>  </p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 </p>
<p>Hexo官方网站：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装命令：  </p>
<pre><code>npm install -g hexo-cli  #-g表示全局安装
</code></pre><p><em>这里提一下：关于hexo的终端操作最好是在管理员模式下，读者可以采用<code>按住Shift然后再点击鼠标右键</code>选择弹出菜单的<code>在此处打开Powershell窗口</code>保证运行在管理员状态下。</em>  </p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>在电脑合适的位置新建一个文件夹存放博客。本文中取名为<code>Blog</code>文件夹。  </p>
<p>控制台命令行使用cd命令进入到Blog文件夹，输入以下命令进行初始化：  </p>
<pre><code>hexo init  # 初始化 
</code></pre><p>初始化完成之后，因为会出现有些依赖包未安装成功的情况，所以请再输入以下命令安装依赖包:  </p>
<pre><code>hexo install   # 安装依赖包  
</code></pre><h2 id="测试本地运行"><a href="#测试本地运行" class="headerlink" title="测试本地运行"></a>测试本地运行</h2><p>完成以上安装步骤后，便可以在本地预览博客效果了。  </p>
<p>输入以下命令：  </p>
<pre><code>hexo g   # 等同于hexo generate，生成静态文件
hexo s   # 等同于hexo server，在本地服务器运行
</code></pre><p>然后打开浏览器地址栏输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>便可以预览生成的博客框架雏形了。  </p>
<h2 id="部署到GitHub以及Coding上"><a href="#部署到GitHub以及Coding上" class="headerlink" title="部署到GitHub以及Coding上"></a>部署到GitHub以及Coding上</h2><blockquote>
<p>建立博客网站肯定是要让大家看到的，由于Github是歪果仁的网站，且禁止百度爬虫访问，所以会导致百度搜不到你的网站。所以我们要做好两手准备：国内采用Coding托管，国外采用GitHub托管。  </p>
</blockquote>
<p>分别注册GitHub以及Coding的账号。  </p>
<ul>
<li><p>GitHub网址如下：<a href="http://www.github.com" target="_blank" rel="noopener">http://www.github.com</a>  </p>
</li>
<li><p>Coding网址如下：<a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a>  </p>
</li>
</ul>
<h3 id="GitHub注册"><a href="#GitHub注册" class="headerlink" title="GitHub注册"></a>GitHub注册</h3><p>1、在GitHub首页点击<code>Start Project</code>  </p>
<p>2、创建Repository </p>
<p><img src="https://i.imgur.com/HKup5ys.png" alt="">  </p>
<p>PS：创建时，填写<code>Repository name</code>的时候，Repository name的格式必须为{user_name}.github.io，其中{user_name}必须与你的用户名一样，这是GitHub Pages的特殊命名规范（亲测不区分大小写）。</p>
<h3 id="Coding注册"><a href="#Coding注册" class="headerlink" title="Coding注册"></a>Coding注册</h3><blockquote>
<p>CODING 是国内专业的一站式云端软件服务平台，成立于 2014 年 2 月，总部位于深圳，并于北京、上海、成都、西雅图设立分部，已获得了 IDG 和光速的两轮投资共计 1500 万美元。旗下自主研发运营 Coding.net 云端开发协作平台，累积 25 万开发者，37 万个项目。在云计算时代，把代码托管、产品演示、WebIDE 等开发工具集成到浏览器中，免除繁杂的开发环境部署，节省成本，帮助软件开发者提高生产效率，并实现 “Coding Anytime Anywhere” 的愿景。2015 年 10 月，基于 Coding.net 的工具平台，CODING 推出云端软件众包服务平台 “码市”，旨在通过云端协作以及众包的方式提高软件交付的效率，帮助软件开发行业实现高效的资源匹配。</p>
<p>Coding.net 为开发者提供了免费的基础服务，包括但不限于 Git 代码托管，项目管理，Pages 服务，代码质量管理。您可以在 Coding.net 一站完成代码及代码质量，项目及项目人员的管理，Coding.net 让开发变得前所未有的敏捷和简单。</p>
</blockquote>
<p>Coding的仓库容量只有256M，但是用来发布博文是够了的。  </p>
<p>注册步骤没啥好说的。  </p>
<p>主要说一下创建仓库的时候（顺便说一句：Coding毕竟还是国内的，各方面比较适合国人的习惯，操作起来是比GitHub顺手点。 ）  </p>
<p>点击下面的“加号”创建一个仓库：  </p>
<p><img src="https://i.imgur.com/vanCb7s.png" alt="">  </p>
<p>然后输入项目名称以及项目描述：  </p>
<p><img src="https://i.imgur.com/0ze8avx.png" alt=""><br><em>此处的项目名称不像GitHub那样有着严格的命名规范，你可以按照你能想象到的方式输入。建议不要输入中文，不然后面会走的很安详。这里我是输入的自己的用户名作为项目名称。</em>  </p>
<p>开启Pages服务（步骤如下图）  </p>
<p><img src="https://i.imgur.com/F4nGZCc.png" alt=""><br>选择部署来源为<code>master分支</code>，然后点击<a href="http://username.coding.me/yourRepoName" target="_blank" rel="noopener"> http://username.coding.me/yourRepoName</a>就可以查看你的博客了，不过你点进去是404，因为你仓库里面啥都没有。  </p>
<p>到此，注册和创建仓库一步骤已经全部完成了。  </p>
<h3 id="部署到线上（GitHub和Coding）"><a href="#部署到线上（GitHub和Coding）" class="headerlink" title="部署到线上（GitHub和Coding）"></a>部署到线上（GitHub和Coding）</h3><blockquote>
<p>我看到很多博客上面说到配置文件的时候，没有区分站点配置文件和主题配置文件，这里我先说清楚。站点配置文件和主题配置文件名称都是一样的<code>_config.yml</code>，站点配置文件在网站根目录，主题配置文件在根目录下的theme文件的具体theme下的<code>_config.yml</code>。  </p>
</blockquote>
<h4 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h4><p>打开<code>_config.yml</code>到最后<code>deploy</code>选项：<br>配置如下：  </p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repo:
    github: https://github.com/DimpleFeng/dimplefeng.github.io.git,master
    coding: https://git.coding.net/DimpleFeng/test.git,master
</code></pre><p>注意：每个冒号后面都是有一个空格的，这是node的语法。  </p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>部署之前需要安装<code>git</code>部署插件，否则会提示<code>Deployer not found</code>错误。  </p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>安装完毕后控制台输入：  </p>
<pre><code>hexo g -d   
</code></pre><p>随后访问你的以下网址（注意替换）：</p>
<p><a href="yourName.github.io">yourName.github.io </a><br><a href="yourName.coding.me">yourName.coding.me </a>  </p>
<h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><blockquote>
<p>作为一个有梦想的程序员，总是希望拥有自己别具一格的域名，这怎么办呢，你可以选择购买域名，然后指向你的静态pages。具体怎么做呢，请看下面。  </p>
</blockquote>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>你可以在<a href="https://dnspod.cloud.tencent.com/?from=qcloudHpProductDns" target="_blank" rel="noopener">腾讯云</a>以及<a href="https://wanwang.aliyun.com/?utm_content=se_1101812" target="_blank" rel="noopener">阿里云</a>上购买你的域名。</p>
<p>我是分别在阿里云上和腾讯云上购买过域名。分别是<code>www.bianxiaofeng.top</code>和<code>www.bianxiaofeng.com</code>。<code>.top域名已经没有使用了（2元一年是相当的便宜）</code>，这里想说的是，这两个代理商的操作模式有些不同。  </p>
<h3 id="设置域名解析-1"><a href="#设置域名解析-1" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>这里我分别以阿里云和腾讯云的举例：</p>
<h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><p>进入<a href="https://console.cloud.tencent.com/domain/mydomain" target="_blank" rel="noopener">腾讯云DNS解析网站</a>，然后是点击解析。<img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122142027.png" alt="{mdFileName}-2018122142027">  </p>
<p>添加如图所示的几条解析指令。  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122142345.png" alt="{mdFileName}-2018122142345">  </p>
<p>注意：此处的记录名是github填写你的仓库名，Coding按照我上面的填写。  </p>
<h4 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h4><p>进入<a href="https://dc.console.aliyun.com/dns/" target="_blank" rel="noopener">阿里云DNS解析网站</a>点击解析设置：<br><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122143222.png" alt="{mdFileName}-2018122143222">  </p>
<p> 添加以下几条解析命令：</p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122143452.png" alt="{mdFileName}-2018122143452"></p>
<h2 id="设置Coding和GitHub"><a href="#设置Coding和GitHub" class="headerlink" title="设置Coding和GitHub"></a>设置Coding和GitHub</h2><p>按照上面的步骤添加完毕之后，分别设置Coding和GitHub的指向。  </p>
<h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>打开Coding，然后点击你的网站仓库，按照下面的步骤，添加你的域名  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122143916.png" alt="{mdFileName}-2018122143916"></p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>在你的博客的文件夹中找到Source文件夹，在里面加添一个CNMAE的文件，文件内容为你的域名，比如我的就是：<code>bianxiaofeng.com</code>  </p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/%7BmdFileName%7D-2018122144052.png" alt="{mdFileName}-2018122144052"></p>
<p>OK ,大功告成，你可以通过你的域名访问你的网站了。<a href="http://www.bianxiaofeng.com">Dimple</a></p>
<p>###</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="写一篇新的博文"><a href="#写一篇新的博文" class="headerlink" title="写一篇新的博文"></a>写一篇新的博文</h2><p>两种方法：  </p>
<ul>
<li>在博文根目录的Source文件夹的post文件夹下直接新建一个md文件</li>
<li>在博文根目录打来PowerShell，然后输入<code>hexo new &#39;你的标题&#39;</code>回车在你的post文件夹下就新建了一个博文，打开编辑即可。然后使用<code>hexo g -d</code>部署到线上。  </li>
</ul>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>接下来呢，我还会针对Next主题、相关的网站配置以及域名和百度谷歌收录进行说明，欢迎关注我的系列文章。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>洋洋洒洒的写了4000+字，确实每一步都是在仔仔细细的做，记录。这篇博文参考了hexo的官方文档，以及百度谷歌的各种教程，重复杂乱居多，网上各种文章都是复制粘贴重复很多且不是最新的，我只想用最平凡的文字记录最清晰的道路。我是一个被代码耽误的诗人，这是我朋友给我的评价哈哈哈。</p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客从零搭建 </tag>
            
            <tag> 最新 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[站点被百度谷歌收录]]></title>
      <url>/2018/01/02/2018-01-02%20120748/</url>
      <content type="html"><![CDATA[<p>精心写一篇博文但是没人看怎么办呢？百度搜不到，谷歌搜不到？别慌，还需要将你的网站提交到百度和谷歌。</p>
<p>在开始之前，你可以按照以下格式在百度和谷歌搜索下你的网站：<br><img src="https://i.imgur.com/5hnjkNo.png" alt=""></p>
<p><img src="https://i.imgur.com/yQ3UAjT.png" alt=""><br>注意：提交到谷歌需要科学上网。</p>
<h1 id="提交百度搜索引擎"><a href="#提交百度搜索引擎" class="headerlink" title="提交百度搜索引擎"></a>提交百度搜索引擎</h1><p>登录<a href="http://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">http://ziyuan.baidu.com/site/index</a></p>
<p>ps：可能需要个人信息认证，按照提示认证即可！  </p>
<p><img src="https://i.imgur.com/YpUnA4O.png" alt=""></p>
<h2 id="点击添加站点"><a href="#点击添加站点" class="headerlink" title="点击添加站点"></a>点击添加站点</h2><p>会看到如下界面：<br><img src="https://i.imgur.com/zWlFN8G.png" alt="">  </p>
<h2 id="在图中文本框添加你的个人网站域名"><a href="#在图中文本框添加你的个人网站域名" class="headerlink" title="在图中文本框添加你的个人网站域名"></a>在图中文本框添加你的个人网站域名</h2><p>最好是带上<code>www</code></p>
<h2 id="设置站点领域"><a href="#设置站点领域" class="headerlink" title="设置站点领域"></a>设置站点领域</h2><p>这里我选择<code>信息技术</code>，点击下一步。 </p>
<h2 id="选择验证方式"><a href="#选择验证方式" class="headerlink" title="选择验证方式"></a>选择验证方式</h2><h3 id="验证方式一：文件验证"><a href="#验证方式一：文件验证" class="headerlink" title="验证方式一：文件验证"></a>验证方式一：文件验证</h3><p><img src="https://i.imgur.com/lj9qSFz.png" alt=""><br>  这里我选择的是文件验证，建议大家也使用文件验证方式，这样比较简单。 </p>
<blockquote>
<ol>
<li>请点击 下载验证文件 获取验证文件（当前最新：baidu_verify_Rkofa3ZBzc.html）</li>
</ol>
<ol>
<li>将验证文件放置于您所配置域名(www.bianxiaofeng.com)的根目录下</li>
</ol>
<ol>
<li>点击这里确认验证文件可以正常访问</li>
</ol>
<ol>
<li>请点击“完成验证”按钮</li>
</ol>
<p>为保持验证通过的状态,成功验证后请不要删除HTML文件   </p>
</blockquote>
<p>网站的根目录在那里呢？  </p>
<p>在你的博客的本地根目录的<code>Source</code>文件夹内。  </p>
<p><img src="https://i.imgur.com/NbWMPCi.png" alt=""><br> 然后控制台输入：<code>hexo g -d</code>，部署到网站上。</p>
<p>验证方式：<br>点击3步骤的验证。如果能点击进去证明成功。   </p>
<h2 id="随后点完成验证。"><a href="#随后点完成验证。" class="headerlink" title="随后点完成验证。"></a>随后点完成验证。</h2><h3 id="HTML标签验证"><a href="#HTML标签验证" class="headerlink" title="HTML标签验证"></a>HTML标签验证</h3><p>本文使用的是Next主题。在<code>themes/next/layout/_partials/head.swig</code>内：修改meta标签为站长网站上给出的标签即可：</p>
<p><img src="https://i.imgur.com/5BsCvZk.png" alt="">  </p>
<p>同时，在themes/next/_config.yml中将google-site-verification和baidu_site_verification的值设置为true即可。</p>
<p> 然后控制台输入：<code>hexo g -d</code>，部署到网站上。</p>
<h2 id="CNAME验证"><a href="#CNAME验证" class="headerlink" title="CNAME验证"></a>CNAME验证</h2><p><img src="https://i.imgur.com/IfCkGvN.png" alt="">  </p>
<p>配置方式如图：</p>
<p><img src="https://i.imgur.com/UeHI8VE.png" alt="">  </p>
<h1 id="谷歌验证"><a href="#谷歌验证" class="headerlink" title="谷歌验证"></a>谷歌验证</h1><p>登录<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">https://www.google.com/webmasters/tools/home?hl=zh-CN</a><br>如图：<br><img src="https://i.imgur.com/g9YE3s8.png" alt="">   </p>
<h2 id="在上图输入你的网站地址"><a href="#在上图输入你的网站地址" class="headerlink" title="在上图输入你的网站地址"></a>在上图输入你的网站地址</h2><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="https://i.imgur.com/XqmMJLv.png" alt=""></p>
<p>按照下图进行选择：</p>
<p><img src="https://i.imgur.com/BkGlDW2.png" alt="">  </p>
<p>在阿里云的解析当中添加下面的解析：<br><img src="https://i.imgur.com/LlISN8f.png" alt="">  </p>
<p>点击验证即可。  </p>
<p><img src="https://i.imgur.com/fLZQwgj.png" alt="">  </p>
<h1 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h1><blockquote>
<p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 </p>
</blockquote>
<h2 id="安装百度谷歌的站点地图文件"><a href="#安装百度谷歌的站点地图文件" class="headerlink" title="安装百度谷歌的站点地图文件"></a>安装百度谷歌的站点地图文件</h2><pre><code>npm install hexo-generator-sitemap --save

npm install hexo-generator-baidu-sitemap --save  
</code></pre><h2 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h2><p>打开站点配置文件：<br><img src="https://i.imgur.com/AcrthZy.png" alt="">  </p>
<p>主要是将url设置为你的站点名称。</p>
<p>然后执行：<code>hexo clean</code>和<code>hexo g</code>  </p>
<p>这样在你的网站根目录的<code>public</code>文件夹下生成sitemap.xml文件和baidusitemap.xml文件：  </p>
<p><img src="https://i.imgur.com/jqyyXOX.png" alt="">  </p>
<p>其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。  </p>
<h2 id="向谷歌提交链接"><a href="#向谷歌提交链接" class="headerlink" title="向谷歌提交链接"></a>向谷歌提交链接</h2><p>google站点平台：<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">https://www.google.com/webmasters/tools/home?hl=zh-CN</a>，然后就是注册账号、验证站点、提交sitemap，</p>
<p><img src="https://i.imgur.com/A5rvI8A.png" alt="">    </p>
<p><img src="https://i.imgur.com/UOvfbDi.png" alt="">  </p>
<p>提交你的site就行了</p>
<h2 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h2><p>百度收录很麻烦，效率比谷歌差远了。</p>
<h3 id="设置自动推送"><a href="#设置自动推送" class="headerlink" title="设置自动推送"></a>设置自动推送</h3><p>在主题配置文件下设置,将baidu_push设置为true：</p>
<pre><code># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO
baidu_push: true 
</code></pre><h3 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h3><p>将生成的baidusitemap.xml提交到百度<a href="http://ziyuan.baidu.com/linksubmit/index" target="_blank" rel="noopener">http://ziyuan.baidu.com/linksubmit/index</a></p>
<p>点击链接提交 ：</p>
<p><img src="https://i.imgur.com/sCONlMv.png" alt="">  </p>
<p>输入文件地址提交  </p>
<p><img src="https://i.imgur.com/M8JJBIe.png" alt=""></p>
<p>稍后你刷新页面，就可以看到状态了。</p>
<p>本文参考：<br><a href="http://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">http://blog.csdn.net/sunshine940326/article/details/70936988</a></p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> google </tag>
            
            <tag> baidu </tag>
            
            <tag> 收录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博文置顶（自定义排序）]]></title>
      <url>/2018/01/01/2018-01-01%20212957/</url>
      <content type="html"><![CDATA[<blockquote>
<p>HEXO默认是按照时间顺序排一条线，然后按照时间顺序来决定显示的顺序的。按照网上的教程整理了一份方法。</p>
</blockquote>
<h1 id="Hexo博文置顶（自定义排序）"><a href="#Hexo博文置顶（自定义排序）" class="headerlink" title="Hexo博文置顶（自定义排序）"></a>Hexo博文置顶（自定义排序）</h1><p>使用的是<code>top</code>属性，<code>top</code>值越高，排序越在前，不设置<code>top</code>值得博文按照时间顺序排序。<br>修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js  </p>
<p>打开在最后添加如下<code>javascript</code>代码  </p>
<pre><code>posts.data = posts.data.sort(function(a, b) {
if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义
    if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排
    else return b.top - a.top; // 否则按照top值降序排
}
else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）
    return -1;
}
else if(!a.top &amp;&amp; b.top) {
    return 1;
}
else return b.date - a.date; // 都没定义按照文章日期降序排
</code></pre><p>}); </p>
<p>在写文章的时候添加top属性就行了。 </p>
<p>文章有多种属性，一个一个添加是不是很麻烦呢？  </p>
<p>这个时候可以修改：HEXO博客的<code>scaffolds\post.md</code>  </p>
<p>附上个人的<code>post</code>设置   </p>
<p><img src="https://i.imgur.com/QS4D72n.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> hexo个人博客搭建之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博文置顶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>/2018/01/01/hexo/</url>
      <content type="html"><![CDATA[<p>以下内容加密访问<br><a id="more"></a></p>
<p>进军hexo，留下足迹！</p>
]]></content>
      
        <categories>
            
            <category> 网站相关文件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网站文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyEclipse2017 CI7 集成开发环境的破解与使用]]></title>
      <url>/2017/12/30/2017-12-30%20180202/</url>
      <content type="html"><![CDATA[<h1 id="MyEclipse2017-CI7-集成开发环境的破解与使用"><a href="#MyEclipse2017-CI7-集成开发环境的破解与使用" class="headerlink" title="MyEclipse2017 CI7  集成开发环境的破解与使用"></a>MyEclipse2017 CI7  集成开发环境的破解与使用</h1><blockquote>
<p>MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。<br>MyEclipse企业级工作平台（MyEclipseEnterprise Workbench ，简称MyEclipse）是对EclipseIDE的扩展，利用它我们可以在数据库和JavaEE的开发、发布以及应用程序服务器的整合方面极大的提高工作效率。它是功能丰富的JavaEE集成开发环境，包括了完备的编码、调试、测试和发布功能，完整支持HTML，Struts，JSP，CSS，Javascript，Spring，SQL，Hibernate  。<br>MyEclipse 是一个十分优秀的用于开发Java, J2EE的 Eclipse 插件集合，MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持十分不错。MyEclipse可以支持Java Servlet，AJAX，JSP，JSF，Struts，Spring，Hibernate，EJB3，JDBC数据库链接工具等多项功能。可以说MyEclipse是几乎囊括了目前所有主流开源产品的专属eclipse开发工具。—— <a href="https://baike.baidu.com/item/MyEclipse/783967?fr=aladdin" target="_blank"> [百度百科 ]</a></p>
</blockquote>
<p><em>本文主要通过本人自己的经验对网上的一些各类大神的教程进行总结与更新（大神们的教程已经发布很久了，不能适用现在的最新版本）。</em></p>
<p>备注：本教程默认读者是配置好了JAVA的相关环境的，请读者自行配置相关环境。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>下载地址建议还是去官方的网站吧，为了安全。嘻嘻</p>
<pre><code>附上下载地址：http://www.myeclipsecn.com/download/
</code></pre><p>注：下载需要微信扫码获取密码。<br><img src="http://img.blog.csdn.net/20170907122010684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="注意我使用的版本为MyEclipse 2017 CI 7（2017-7-12更新），以后更新的版本有可能破解方法不能适用"><br>    注意我使用的版本为MyEclipse 2017 CI 7（2017-7-12更新）</p>
<p>下载默认安装即可。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong><em>安装完毕之后，一定要记住，不要选择那个默认的打开MyEclipse ！！！</em></strong></p>
<p><img src="http://img.blog.csdn.net/20170907162256989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>然后使用我们的破解工具：<br>        破解工具下载地址：<a href="http://download.csdn.net/download/qq_32454537/9968200" target="_blank" rel="noopener">http://download.csdn.net/download/qq_32454537/9968200</a></p>
<h3 id="1、解压文件后打开文件夹："><a href="#1、解压文件后打开文件夹：" class="headerlink" title="1、解压文件后打开文件夹："></a>1、解压文件后打开文件夹：</h3><p><img src="http://img.blog.csdn.net/20170907122456966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h3 id="2、复制这里面的所有内容："><a href="#2、复制这里面的所有内容：" class="headerlink" title="2、复制这里面的所有内容："></a>2、复制这里面的所有内容：</h3><p><img src="http://img.blog.csdn.net/20170907122549774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="3、到MyEclipse的安装目录下："><a href="#3、到MyEclipse的安装目录下：" class="headerlink" title="3、到MyEclipse的安装目录下："></a>3、到MyEclipse的安装目录下：</h3><p><img src="http://img.blog.csdn.net/20170907122656782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="4、复制到这个plugins文件夹内，覆盖就可。"><a href="#4、复制到这个plugins文件夹内，覆盖就可。" class="headerlink" title="4、复制到这个plugins文件夹内，覆盖就可。"></a>4、复制到这个plugins文件夹内，覆盖就可。</h3><p>ps：一共是64个文件。</p>
<h3 id="5、打开myeclipse2017-keygen这个文件夹"><a href="#5、打开myeclipse2017-keygen这个文件夹" class="headerlink" title="5、打开myeclipse2017_keygen这个文件夹"></a>5、打开myeclipse2017_keygen这个文件夹</h3><p><img src="http://img.blog.csdn.net/20170907122900501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="6、打开之后双击打开红框部分"><a href="#6、打开之后双击打开红框部分" class="headerlink" title="6、打开之后双击打开红框部分"></a>6、打开之后双击打开红框部分</h3><p><img src="http://img.blog.csdn.net/20170907122934081?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="7、打开后如图"><a href="#7、打开后如图" class="headerlink" title="7、打开后如图"></a>7、打开后如图</h3><p>填写UserCode为任意英文或者数字，这里填写为admin、<br>下面一个下拉选择框选择BLUE<br>按SystemId按钮，可能需要按两下，知道SystemId输入框出现一连串的“莫名其妙”的符号。<br>这个时候再按Active按钮，此时最下面的TextView就会出现这么一坨东西，代表基本成功<br><img src="http://img.blog.csdn.net/20170907162902448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这个时候，还需要点击Tools，选择tools里的save propertity<br><img src="http://img.blog.csdn.net/20170907163006825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>PS：附上操作顺序图<br><img src="http://img.blog.csdn.net/20170907123217745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>然后打开MyEclipse敬请享用吧。</p>
<p>如果有问题欢迎回复。我在线都会答。</p>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><h3 id="2017年9月8日更新："><a href="#2017年9月8日更新：" class="headerlink" title="2017年9月8日更新："></a>2017年9月8日更新：</h3><p>如果出现了破解失败，即进去显示还有5天就到期。<br>请按照以下步骤执行：<br>1、首先卸载MyEclipse ，卸载完毕后请删除MyEclipse中的所有的文件。<br>2、按住Windows键+R，输入regedit，进去注册表编辑页面，按住Ctrl+F，出来搜索框，请输入：MyEclipse，然后回车，进行搜索，搜索出来了按del键进行删除。然后再按住F3继续搜索，直到搜索完毕。<br>3、重新按照如上步骤，重新破解安装。</p>
<h3 id="2017年12月30日更新："><a href="#2017年12月30日更新：" class="headerlink" title="2017年12月30日更新："></a>2017年12月30日更新：</h3><p>也没更新啥，就换了下排版嘻嘻嘻！</p>
<p>本文链接：<a href="http://blog.csdn.net/qq_32454537/article/details/77880294" target="_blank" rel="noopener">http://blog.csdn.net/qq_32454537/article/details/77880294</a></p>
]]></content>
      
        <categories>
            
            <category> Java学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Eclipse破解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 优化]]></title>
      <url>/2017/12/04/2017-12-04%20212731/</url>
      <content type="html"><![CDATA[<blockquote>
<p><em>安装好Android Studio之后需要根据自己的习惯进行一些设置，下载些插件、设置下软件的相关属性等等。刚好重装了下系统，针对这个Android Studio进行了相关的设置，在这里将经历说一下，避免自己以后晚了相关设置也方便一些需要帮助的朋友</em>  </p>
</blockquote>
<p>更新记录：2017年12月24日22:32:37更新</p>
<p>本文主要分为设置篇和插件篇： </p>
<h1 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h1><p>##快速查找以及快捷键搜索<br>在AS的面板上双击<code>shift</code>键，即可调出全局搜索。<img src="http://img.blog.csdn.net/20171224213924058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>AS有很多的快捷键，对于这些快捷键你不一定随时都能记得，这个时候可以使用<code>Win+Shift+A</code>键输入你想用的功能。后面会提示相关的快捷键的。<br><img src="http://img.blog.csdn.net/20171224214158337?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<h2 id="恢复默认布局"><a href="#恢复默认布局" class="headerlink" title="恢复默认布局"></a>恢复默认布局</h2><p>当你各种乱动默认的面板布局的时候，有的面板你想找的时候却发现找不到了，这个时候按住 <code>Shift+F12</code>就可以重置默认面板。<br><img src="http://img.blog.csdn.net/20171224214521926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="Tip-of-the-day"><a href="#Tip-of-the-day" class="headerlink" title="Tip of the day"></a>Tip of the day</h2><p>打开软件的时候随机显示关于Android Studio的相关使用提示。（很有用的，别关）</p>
<p><img src="http://img.blog.csdn.net/20171224215949578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Android-Studio相关网站"><a href="#Android-Studio相关网站" class="headerlink" title="Android Studio相关网站"></a>Android Studio相关网站</h2><ul>
<li><a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio 中文社区</a> </li>
<li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">优质的问答社区（英文的）</a> </li>
</ul>
<h1 id="设置篇"><a href="#设置篇" class="headerlink" title="设置篇"></a>设置篇</h1><blockquote>
<p>Android Studio到底是外国人开发的，这个东西拿到手感觉和我们日常使用的IDE有点···· </p>
</blockquote>
<h2 id="鼠标滚轮滑动调整字体大小"><a href="#鼠标滚轮滑动调整字体大小" class="headerlink" title="鼠标滚轮滑动调整字体大小"></a>鼠标滚轮滑动调整字体大小</h2><p>打开<code>File</code>里的<code>Setting</code> 勾选<code>Change font size(Zoom)with Ctrl——Mouse Wheel</code><br><img src="http://img.blog.csdn.net/20171224214754310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="查看参数定义"><a href="#查看参数定义" class="headerlink" title="查看参数定义"></a>查看参数定义</h2><p>使用快捷键<code>Ctrl+P</code>可以查看当前鼠标所在位置的方法的参数定义。<br><img src="http://img.blog.csdn.net/20171224222531022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<h2 id="鼠标移动显示API文档"><a href="#鼠标移动显示API文档" class="headerlink" title="鼠标移动显示API文档"></a>鼠标移动显示API文档</h2><p>设置当鼠标移动到方法上的时候显示API文档。<code>Editor-&gt;General-&gt;show quick document on mouse move</code>  后面那个Delay Time 是设置延时的，单位为毫秒。但是建议电脑性能差一点的不要开，会很卡。<br><img src="http://img.blog.csdn.net/20171224222926874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="设置默认的字体大小"><a href="#设置默认的字体大小" class="headerlink" title="设置默认的字体大小"></a>设置默认的字体大小</h2><p>打开AS的时候发现蚊子一样大小的代码，密密麻麻的密集恐惧症受不了。<code>Editor-&gt;Colors&amp;Fonts-&gt;Font</code><br>一般设置到18就行了<br><img src="http://img.blog.csdn.net/20171224215037079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h2><p>设置<code>Keymap</code>，快捷键太多，可以使用搜索框搜索 </p>
<p><img src="http://img.blog.csdn.net/20171224220232053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="设置代码提示"><a href="#设置代码提示" class="headerlink" title="设置代码提示"></a>设置代码提示</h2><p>Android Studio的代码提示是对大小写敏感的，选择None就可以匹配到很多方法或者关键字，这个在你忘了这个方法怎么写的时候非常有用。<br>此外<strong>Ctrl+Q</strong>快捷键也可以设置代码提示。<br><img src="http://img.blog.csdn.net/20171224220954002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="去掉代码编辑区的竖线"><a href="#去掉代码编辑区的竖线" class="headerlink" title="去掉代码编辑区的竖线"></a>去掉代码编辑区的竖线</h2><p> 编辑区域总是有一条竖线，这条竖线的作用是用来警示程序员代码不要写的过长的。<br> <img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320143743.png" alt="QQ截图20180320143743">  </p>
<h2 id="设置方法之间横线隔开"><a href="#设置方法之间横线隔开" class="headerlink" title="设置方法之间横线隔开"></a>设置方法之间横线隔开</h2><p>操作方法如图：勾选 <strong>Show method separators</strong></p>
<p><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320143838.png" alt="QQ截图20180320143838"> </p>
<h2 id="炫酷的Log"><a href="#炫酷的Log" class="headerlink" title="炫酷的Log"></a>炫酷的Log</h2><p>设置地址：Preferences → Editor → Colors &amp; Fonts → Android Logcat<br>将各种类型的log设置颜色：<br>参考别人的配色如下：附上<a href="https://meedamian.com/post/deuglifying-android-studio/" target="_blank" rel="noopener">链接</a></p>
<p> <pre>Type        Color<br>verbose:    #BBB<br>debug:      #33B5E5<br>info:       #9C0<br>assert:     #A6C<br>error:      #F44<br>warning:    #FB3<br>  </pre><br>效果如下：<br><img src="http://p2sj58chj.bkt.clouddn.com/QQ截图20180320150409.png" alt="QQ截图20180320150409"></p>
<h1 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h1><h2 id="AndroidAccessors"><a href="#AndroidAccessors" class="headerlink" title="AndroidAccessors"></a>AndroidAccessors</h2><p>快速生成<code>get</code>和<code>set</code>系列方法。这个在你定义<code>JavaBean</code>的时候非常有用。<br><img src="http://img.blog.csdn.net/20171224221252982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  </p>
<h2 id="ButterKnifeZelezny-插件"><a href="#ButterKnifeZelezny-插件" class="headerlink" title="ButterKnifeZelezny 插件"></a>ButterKnifeZelezny 插件</h2><p>如果你厌倦了findViewById这样的写法，那么这个插件是你的选择。这个配合ButterKnife使用的。</p>
<h2 id="ReciteWords"><a href="#ReciteWords" class="headerlink" title="ReciteWords"></a>ReciteWords</h2><p>是一个IntelliJ IDEA、Android Studio 记单词翻译插件,可以将英文翻译为中文并记录到生词本提供查阅。，项目地址为：<a href="https://github.com/BolexLiu/ReciteWords" target="_blank" rel="noopener">ReciteWords</a></p>
<p>功能： </p>
<ul>
<li>划词翻译 整句翻译 拆分驼峰命名翻译等</li>
<li>生词本保存翻译过后的历史记录  </li>
</ul>
<p>使用方法：  </p>
<ul>
<li><p>Clone项目，获取根目录下的ReciteWords.jar。</p>
</li>
<li><p>打开Android Studio， Preferences -&gt; Plugins -&gt; Install plugin from disk -&gt; 获取ReciteWords.jar安装并重启Android Studio。</p>
</li>
<li><p>选中代码，按下 Alt+Q(也可以自己设定)。即可翻译。效果如下:<br><img src="https://github.com/BolexLiu/ReciteWords/raw/master/img/1.png" alt=""></p>
</li>
<li><p>设置快捷键<br>使用键盘快捷键触发，Preferences -&gt; Keymap -&gt; 获取ReciteWords - &gt; 右键 add Keyboard Shortcut. 输入你想要的快捷键即可。</p>
</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>这里我推荐一个<code>MaterialDesign AS UI Theme</code> 这个主题比较好用，尤其是配合黑色的AS主题的时候。</p>
<p>顺便推荐一个<a href="http://color-themes.com/" target="_blank" rel="noopener">http://color-themes.com/</a> 这个网站下载你喜欢的主题，然后导入主题即可。<br><img src="http://img.blog.csdn.net/20171224222110962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI0NTQ1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>插件及常用的快捷键请看我之前的博客：<a href="http://blog.csdn.net/qq_32454537/article/details/77870200" target="_blank" rel="noopener">http://blog.csdn.net/qq_32454537/article/details/77870200</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
